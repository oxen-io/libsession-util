// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SessionProtos.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_SessionProtos_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_SessionProtos_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_SessionProtos_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_SessionProtos_2eproto {
  static const uint32_t offsets[];
};
namespace SessionProtos {
class AttachmentPointer;
struct AttachmentPointerDefaultTypeInternal;
extern AttachmentPointerDefaultTypeInternal _AttachmentPointer_default_instance_;
class CallMessage;
struct CallMessageDefaultTypeInternal;
extern CallMessageDefaultTypeInternal _CallMessage_default_instance_;
class ConfigurationMessage;
struct ConfigurationMessageDefaultTypeInternal;
extern ConfigurationMessageDefaultTypeInternal _ConfigurationMessage_default_instance_;
class ConfigurationMessage_ClosedGroup;
struct ConfigurationMessage_ClosedGroupDefaultTypeInternal;
extern ConfigurationMessage_ClosedGroupDefaultTypeInternal _ConfigurationMessage_ClosedGroup_default_instance_;
class ConfigurationMessage_Contact;
struct ConfigurationMessage_ContactDefaultTypeInternal;
extern ConfigurationMessage_ContactDefaultTypeInternal _ConfigurationMessage_Contact_default_instance_;
class Content;
struct ContentDefaultTypeInternal;
extern ContentDefaultTypeInternal _Content_default_instance_;
class DataExtractionNotification;
struct DataExtractionNotificationDefaultTypeInternal;
extern DataExtractionNotificationDefaultTypeInternal _DataExtractionNotification_default_instance_;
class DataMessage;
struct DataMessageDefaultTypeInternal;
extern DataMessageDefaultTypeInternal _DataMessage_default_instance_;
class DataMessage_ClosedGroupControlMessage;
struct DataMessage_ClosedGroupControlMessageDefaultTypeInternal;
extern DataMessage_ClosedGroupControlMessageDefaultTypeInternal _DataMessage_ClosedGroupControlMessage_default_instance_;
class DataMessage_ClosedGroupControlMessage_KeyPairWrapper;
struct DataMessage_ClosedGroupControlMessage_KeyPairWrapperDefaultTypeInternal;
extern DataMessage_ClosedGroupControlMessage_KeyPairWrapperDefaultTypeInternal _DataMessage_ClosedGroupControlMessage_KeyPairWrapper_default_instance_;
class DataMessage_OpenGroupInvitation;
struct DataMessage_OpenGroupInvitationDefaultTypeInternal;
extern DataMessage_OpenGroupInvitationDefaultTypeInternal _DataMessage_OpenGroupInvitation_default_instance_;
class DataMessage_Preview;
struct DataMessage_PreviewDefaultTypeInternal;
extern DataMessage_PreviewDefaultTypeInternal _DataMessage_Preview_default_instance_;
class DataMessage_Quote;
struct DataMessage_QuoteDefaultTypeInternal;
extern DataMessage_QuoteDefaultTypeInternal _DataMessage_Quote_default_instance_;
class DataMessage_Quote_QuotedAttachment;
struct DataMessage_Quote_QuotedAttachmentDefaultTypeInternal;
extern DataMessage_Quote_QuotedAttachmentDefaultTypeInternal _DataMessage_Quote_QuotedAttachment_default_instance_;
class DataMessage_Reaction;
struct DataMessage_ReactionDefaultTypeInternal;
extern DataMessage_ReactionDefaultTypeInternal _DataMessage_Reaction_default_instance_;
class Envelope;
struct EnvelopeDefaultTypeInternal;
extern EnvelopeDefaultTypeInternal _Envelope_default_instance_;
class KeyPair;
struct KeyPairDefaultTypeInternal;
extern KeyPairDefaultTypeInternal _KeyPair_default_instance_;
class LokiProfile;
struct LokiProfileDefaultTypeInternal;
extern LokiProfileDefaultTypeInternal _LokiProfile_default_instance_;
class MessageRequestResponse;
struct MessageRequestResponseDefaultTypeInternal;
extern MessageRequestResponseDefaultTypeInternal _MessageRequestResponse_default_instance_;
class ReceiptMessage;
struct ReceiptMessageDefaultTypeInternal;
extern ReceiptMessageDefaultTypeInternal _ReceiptMessage_default_instance_;
class SharedConfigMessage;
struct SharedConfigMessageDefaultTypeInternal;
extern SharedConfigMessageDefaultTypeInternal _SharedConfigMessage_default_instance_;
class TypingMessage;
struct TypingMessageDefaultTypeInternal;
extern TypingMessageDefaultTypeInternal _TypingMessage_default_instance_;
class UnsendRequest;
struct UnsendRequestDefaultTypeInternal;
extern UnsendRequestDefaultTypeInternal _UnsendRequest_default_instance_;
}  // namespace SessionProtos
PROTOBUF_NAMESPACE_OPEN
template<> ::SessionProtos::AttachmentPointer* Arena::CreateMaybeMessage<::SessionProtos::AttachmentPointer>(Arena*);
template<> ::SessionProtos::CallMessage* Arena::CreateMaybeMessage<::SessionProtos::CallMessage>(Arena*);
template<> ::SessionProtos::ConfigurationMessage* Arena::CreateMaybeMessage<::SessionProtos::ConfigurationMessage>(Arena*);
template<> ::SessionProtos::ConfigurationMessage_ClosedGroup* Arena::CreateMaybeMessage<::SessionProtos::ConfigurationMessage_ClosedGroup>(Arena*);
template<> ::SessionProtos::ConfigurationMessage_Contact* Arena::CreateMaybeMessage<::SessionProtos::ConfigurationMessage_Contact>(Arena*);
template<> ::SessionProtos::Content* Arena::CreateMaybeMessage<::SessionProtos::Content>(Arena*);
template<> ::SessionProtos::DataExtractionNotification* Arena::CreateMaybeMessage<::SessionProtos::DataExtractionNotification>(Arena*);
template<> ::SessionProtos::DataMessage* Arena::CreateMaybeMessage<::SessionProtos::DataMessage>(Arena*);
template<> ::SessionProtos::DataMessage_ClosedGroupControlMessage* Arena::CreateMaybeMessage<::SessionProtos::DataMessage_ClosedGroupControlMessage>(Arena*);
template<> ::SessionProtos::DataMessage_ClosedGroupControlMessage_KeyPairWrapper* Arena::CreateMaybeMessage<::SessionProtos::DataMessage_ClosedGroupControlMessage_KeyPairWrapper>(Arena*);
template<> ::SessionProtos::DataMessage_OpenGroupInvitation* Arena::CreateMaybeMessage<::SessionProtos::DataMessage_OpenGroupInvitation>(Arena*);
template<> ::SessionProtos::DataMessage_Preview* Arena::CreateMaybeMessage<::SessionProtos::DataMessage_Preview>(Arena*);
template<> ::SessionProtos::DataMessage_Quote* Arena::CreateMaybeMessage<::SessionProtos::DataMessage_Quote>(Arena*);
template<> ::SessionProtos::DataMessage_Quote_QuotedAttachment* Arena::CreateMaybeMessage<::SessionProtos::DataMessage_Quote_QuotedAttachment>(Arena*);
template<> ::SessionProtos::DataMessage_Reaction* Arena::CreateMaybeMessage<::SessionProtos::DataMessage_Reaction>(Arena*);
template<> ::SessionProtos::Envelope* Arena::CreateMaybeMessage<::SessionProtos::Envelope>(Arena*);
template<> ::SessionProtos::KeyPair* Arena::CreateMaybeMessage<::SessionProtos::KeyPair>(Arena*);
template<> ::SessionProtos::LokiProfile* Arena::CreateMaybeMessage<::SessionProtos::LokiProfile>(Arena*);
template<> ::SessionProtos::MessageRequestResponse* Arena::CreateMaybeMessage<::SessionProtos::MessageRequestResponse>(Arena*);
template<> ::SessionProtos::ReceiptMessage* Arena::CreateMaybeMessage<::SessionProtos::ReceiptMessage>(Arena*);
template<> ::SessionProtos::SharedConfigMessage* Arena::CreateMaybeMessage<::SessionProtos::SharedConfigMessage>(Arena*);
template<> ::SessionProtos::TypingMessage* Arena::CreateMaybeMessage<::SessionProtos::TypingMessage>(Arena*);
template<> ::SessionProtos::UnsendRequest* Arena::CreateMaybeMessage<::SessionProtos::UnsendRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace SessionProtos {

enum Envelope_Type : int {
  Envelope_Type_SESSION_MESSAGE = 6,
  Envelope_Type_CLOSED_GROUP_MESSAGE = 7
};
bool Envelope_Type_IsValid(int value);
constexpr Envelope_Type Envelope_Type_Type_MIN = Envelope_Type_SESSION_MESSAGE;
constexpr Envelope_Type Envelope_Type_Type_MAX = Envelope_Type_CLOSED_GROUP_MESSAGE;
constexpr int Envelope_Type_Type_ARRAYSIZE = Envelope_Type_Type_MAX + 1;

const std::string& Envelope_Type_Name(Envelope_Type value);
template<typename T>
inline const std::string& Envelope_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Envelope_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Envelope_Type_Name.");
  return Envelope_Type_Name(static_cast<Envelope_Type>(enum_t_value));
}
bool Envelope_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Envelope_Type* value);
enum TypingMessage_Action : int {
  TypingMessage_Action_STARTED = 0,
  TypingMessage_Action_STOPPED = 1
};
bool TypingMessage_Action_IsValid(int value);
constexpr TypingMessage_Action TypingMessage_Action_Action_MIN = TypingMessage_Action_STARTED;
constexpr TypingMessage_Action TypingMessage_Action_Action_MAX = TypingMessage_Action_STOPPED;
constexpr int TypingMessage_Action_Action_ARRAYSIZE = TypingMessage_Action_Action_MAX + 1;

const std::string& TypingMessage_Action_Name(TypingMessage_Action value);
template<typename T>
inline const std::string& TypingMessage_Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TypingMessage_Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TypingMessage_Action_Name.");
  return TypingMessage_Action_Name(static_cast<TypingMessage_Action>(enum_t_value));
}
bool TypingMessage_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TypingMessage_Action* value);
enum CallMessage_Type : int {
  CallMessage_Type_PRE_OFFER = 6,
  CallMessage_Type_OFFER = 1,
  CallMessage_Type_ANSWER = 2,
  CallMessage_Type_PROVISIONAL_ANSWER = 3,
  CallMessage_Type_ICE_CANDIDATES = 4,
  CallMessage_Type_END_CALL = 5
};
bool CallMessage_Type_IsValid(int value);
constexpr CallMessage_Type CallMessage_Type_Type_MIN = CallMessage_Type_OFFER;
constexpr CallMessage_Type CallMessage_Type_Type_MAX = CallMessage_Type_PRE_OFFER;
constexpr int CallMessage_Type_Type_ARRAYSIZE = CallMessage_Type_Type_MAX + 1;

const std::string& CallMessage_Type_Name(CallMessage_Type value);
template<typename T>
inline const std::string& CallMessage_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CallMessage_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CallMessage_Type_Name.");
  return CallMessage_Type_Name(static_cast<CallMessage_Type>(enum_t_value));
}
bool CallMessage_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CallMessage_Type* value);
enum DataExtractionNotification_Type : int {
  DataExtractionNotification_Type_SCREENSHOT = 1,
  DataExtractionNotification_Type_MEDIA_SAVED = 2
};
bool DataExtractionNotification_Type_IsValid(int value);
constexpr DataExtractionNotification_Type DataExtractionNotification_Type_Type_MIN = DataExtractionNotification_Type_SCREENSHOT;
constexpr DataExtractionNotification_Type DataExtractionNotification_Type_Type_MAX = DataExtractionNotification_Type_MEDIA_SAVED;
constexpr int DataExtractionNotification_Type_Type_ARRAYSIZE = DataExtractionNotification_Type_Type_MAX + 1;

const std::string& DataExtractionNotification_Type_Name(DataExtractionNotification_Type value);
template<typename T>
inline const std::string& DataExtractionNotification_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataExtractionNotification_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataExtractionNotification_Type_Name.");
  return DataExtractionNotification_Type_Name(static_cast<DataExtractionNotification_Type>(enum_t_value));
}
bool DataExtractionNotification_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataExtractionNotification_Type* value);
enum DataMessage_Quote_QuotedAttachment_Flags : int {
  DataMessage_Quote_QuotedAttachment_Flags_VOICE_MESSAGE = 1
};
bool DataMessage_Quote_QuotedAttachment_Flags_IsValid(int value);
constexpr DataMessage_Quote_QuotedAttachment_Flags DataMessage_Quote_QuotedAttachment_Flags_Flags_MIN = DataMessage_Quote_QuotedAttachment_Flags_VOICE_MESSAGE;
constexpr DataMessage_Quote_QuotedAttachment_Flags DataMessage_Quote_QuotedAttachment_Flags_Flags_MAX = DataMessage_Quote_QuotedAttachment_Flags_VOICE_MESSAGE;
constexpr int DataMessage_Quote_QuotedAttachment_Flags_Flags_ARRAYSIZE = DataMessage_Quote_QuotedAttachment_Flags_Flags_MAX + 1;

const std::string& DataMessage_Quote_QuotedAttachment_Flags_Name(DataMessage_Quote_QuotedAttachment_Flags value);
template<typename T>
inline const std::string& DataMessage_Quote_QuotedAttachment_Flags_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataMessage_Quote_QuotedAttachment_Flags>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataMessage_Quote_QuotedAttachment_Flags_Name.");
  return DataMessage_Quote_QuotedAttachment_Flags_Name(static_cast<DataMessage_Quote_QuotedAttachment_Flags>(enum_t_value));
}
bool DataMessage_Quote_QuotedAttachment_Flags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataMessage_Quote_QuotedAttachment_Flags* value);
enum DataMessage_Reaction_Action : int {
  DataMessage_Reaction_Action_REACT = 0,
  DataMessage_Reaction_Action_REMOVE = 1
};
bool DataMessage_Reaction_Action_IsValid(int value);
constexpr DataMessage_Reaction_Action DataMessage_Reaction_Action_Action_MIN = DataMessage_Reaction_Action_REACT;
constexpr DataMessage_Reaction_Action DataMessage_Reaction_Action_Action_MAX = DataMessage_Reaction_Action_REMOVE;
constexpr int DataMessage_Reaction_Action_Action_ARRAYSIZE = DataMessage_Reaction_Action_Action_MAX + 1;

const std::string& DataMessage_Reaction_Action_Name(DataMessage_Reaction_Action value);
template<typename T>
inline const std::string& DataMessage_Reaction_Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataMessage_Reaction_Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataMessage_Reaction_Action_Name.");
  return DataMessage_Reaction_Action_Name(static_cast<DataMessage_Reaction_Action>(enum_t_value));
}
bool DataMessage_Reaction_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataMessage_Reaction_Action* value);
enum DataMessage_ClosedGroupControlMessage_Type : int {
  DataMessage_ClosedGroupControlMessage_Type_NEW = 1,
  DataMessage_ClosedGroupControlMessage_Type_ENCRYPTION_KEY_PAIR = 3,
  DataMessage_ClosedGroupControlMessage_Type_NAME_CHANGE = 4,
  DataMessage_ClosedGroupControlMessage_Type_MEMBERS_ADDED = 5,
  DataMessage_ClosedGroupControlMessage_Type_MEMBERS_REMOVED = 6,
  DataMessage_ClosedGroupControlMessage_Type_MEMBER_LEFT = 7,
  DataMessage_ClosedGroupControlMessage_Type_ENCRYPTION_KEY_PAIR_REQUEST = 8
};
bool DataMessage_ClosedGroupControlMessage_Type_IsValid(int value);
constexpr DataMessage_ClosedGroupControlMessage_Type DataMessage_ClosedGroupControlMessage_Type_Type_MIN = DataMessage_ClosedGroupControlMessage_Type_NEW;
constexpr DataMessage_ClosedGroupControlMessage_Type DataMessage_ClosedGroupControlMessage_Type_Type_MAX = DataMessage_ClosedGroupControlMessage_Type_ENCRYPTION_KEY_PAIR_REQUEST;
constexpr int DataMessage_ClosedGroupControlMessage_Type_Type_ARRAYSIZE = DataMessage_ClosedGroupControlMessage_Type_Type_MAX + 1;

const std::string& DataMessage_ClosedGroupControlMessage_Type_Name(DataMessage_ClosedGroupControlMessage_Type value);
template<typename T>
inline const std::string& DataMessage_ClosedGroupControlMessage_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataMessage_ClosedGroupControlMessage_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataMessage_ClosedGroupControlMessage_Type_Name.");
  return DataMessage_ClosedGroupControlMessage_Type_Name(static_cast<DataMessage_ClosedGroupControlMessage_Type>(enum_t_value));
}
bool DataMessage_ClosedGroupControlMessage_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataMessage_ClosedGroupControlMessage_Type* value);
enum DataMessage_Flags : int {
  DataMessage_Flags_EXPIRATION_TIMER_UPDATE = 2
};
bool DataMessage_Flags_IsValid(int value);
constexpr DataMessage_Flags DataMessage_Flags_Flags_MIN = DataMessage_Flags_EXPIRATION_TIMER_UPDATE;
constexpr DataMessage_Flags DataMessage_Flags_Flags_MAX = DataMessage_Flags_EXPIRATION_TIMER_UPDATE;
constexpr int DataMessage_Flags_Flags_ARRAYSIZE = DataMessage_Flags_Flags_MAX + 1;

const std::string& DataMessage_Flags_Name(DataMessage_Flags value);
template<typename T>
inline const std::string& DataMessage_Flags_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataMessage_Flags>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataMessage_Flags_Name.");
  return DataMessage_Flags_Name(static_cast<DataMessage_Flags>(enum_t_value));
}
bool DataMessage_Flags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataMessage_Flags* value);
enum ReceiptMessage_Type : int {
  ReceiptMessage_Type_DELIVERY = 0,
  ReceiptMessage_Type_READ = 1
};
bool ReceiptMessage_Type_IsValid(int value);
constexpr ReceiptMessage_Type ReceiptMessage_Type_Type_MIN = ReceiptMessage_Type_DELIVERY;
constexpr ReceiptMessage_Type ReceiptMessage_Type_Type_MAX = ReceiptMessage_Type_READ;
constexpr int ReceiptMessage_Type_Type_ARRAYSIZE = ReceiptMessage_Type_Type_MAX + 1;

const std::string& ReceiptMessage_Type_Name(ReceiptMessage_Type value);
template<typename T>
inline const std::string& ReceiptMessage_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReceiptMessage_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReceiptMessage_Type_Name.");
  return ReceiptMessage_Type_Name(static_cast<ReceiptMessage_Type>(enum_t_value));
}
bool ReceiptMessage_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReceiptMessage_Type* value);
enum AttachmentPointer_Flags : int {
  AttachmentPointer_Flags_VOICE_MESSAGE = 1
};
bool AttachmentPointer_Flags_IsValid(int value);
constexpr AttachmentPointer_Flags AttachmentPointer_Flags_Flags_MIN = AttachmentPointer_Flags_VOICE_MESSAGE;
constexpr AttachmentPointer_Flags AttachmentPointer_Flags_Flags_MAX = AttachmentPointer_Flags_VOICE_MESSAGE;
constexpr int AttachmentPointer_Flags_Flags_ARRAYSIZE = AttachmentPointer_Flags_Flags_MAX + 1;

const std::string& AttachmentPointer_Flags_Name(AttachmentPointer_Flags value);
template<typename T>
inline const std::string& AttachmentPointer_Flags_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AttachmentPointer_Flags>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AttachmentPointer_Flags_Name.");
  return AttachmentPointer_Flags_Name(static_cast<AttachmentPointer_Flags>(enum_t_value));
}
bool AttachmentPointer_Flags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AttachmentPointer_Flags* value);
enum SharedConfigMessage_Kind : int {
  SharedConfigMessage_Kind_USER_PROFILE = 1,
  SharedConfigMessage_Kind_CONTACTS = 2,
  SharedConfigMessage_Kind_CONVO_INFO_VOLATILE = 3,
  SharedConfigMessage_Kind_USER_GROUPS = 4
};
bool SharedConfigMessage_Kind_IsValid(int value);
constexpr SharedConfigMessage_Kind SharedConfigMessage_Kind_Kind_MIN = SharedConfigMessage_Kind_USER_PROFILE;
constexpr SharedConfigMessage_Kind SharedConfigMessage_Kind_Kind_MAX = SharedConfigMessage_Kind_USER_GROUPS;
constexpr int SharedConfigMessage_Kind_Kind_ARRAYSIZE = SharedConfigMessage_Kind_Kind_MAX + 1;

const std::string& SharedConfigMessage_Kind_Name(SharedConfigMessage_Kind value);
template<typename T>
inline const std::string& SharedConfigMessage_Kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SharedConfigMessage_Kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SharedConfigMessage_Kind_Name.");
  return SharedConfigMessage_Kind_Name(static_cast<SharedConfigMessage_Kind>(enum_t_value));
}
bool SharedConfigMessage_Kind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SharedConfigMessage_Kind* value);
// ===================================================================

class Envelope final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SessionProtos.Envelope) */ {
 public:
  inline Envelope() : Envelope(nullptr) {}
  ~Envelope() override;
  explicit PROTOBUF_CONSTEXPR Envelope(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Envelope(const Envelope& from);
  Envelope(Envelope&& from) noexcept
    : Envelope() {
    *this = ::std::move(from);
  }

  inline Envelope& operator=(const Envelope& from) {
    CopyFrom(from);
    return *this;
  }
  inline Envelope& operator=(Envelope&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Envelope& default_instance() {
    return *internal_default_instance();
  }
  static inline const Envelope* internal_default_instance() {
    return reinterpret_cast<const Envelope*>(
               &_Envelope_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Envelope& a, Envelope& b) {
    a.Swap(&b);
  }
  inline void Swap(Envelope* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Envelope* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Envelope* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Envelope>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Envelope& from);
  void MergeFrom(const Envelope& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Envelope* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SessionProtos.Envelope";
  }
  protected:
  explicit Envelope(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Envelope_Type Type;
  static constexpr Type SESSION_MESSAGE =
    Envelope_Type_SESSION_MESSAGE;
  static constexpr Type CLOSED_GROUP_MESSAGE =
    Envelope_Type_CLOSED_GROUP_MESSAGE;
  static inline bool Type_IsValid(int value) {
    return Envelope_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Envelope_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Envelope_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Envelope_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Envelope_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Envelope_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSourceFieldNumber = 2,
    kContentFieldNumber = 8,
    kTimestampFieldNumber = 5,
    kServerTimestampFieldNumber = 10,
    kSourceDeviceFieldNumber = 7,
    kTypeFieldNumber = 1,
  };
  // optional string source = 2;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const std::string& source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* source);
  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  // optional bytes content = 8;
  bool has_content() const;
  private:
  bool _internal_has_content() const;
  public:
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // required uint64 timestamp = 5;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // optional uint64 serverTimestamp = 10;
  bool has_servertimestamp() const;
  private:
  bool _internal_has_servertimestamp() const;
  public:
  void clear_servertimestamp();
  uint64_t servertimestamp() const;
  void set_servertimestamp(uint64_t value);
  private:
  uint64_t _internal_servertimestamp() const;
  void _internal_set_servertimestamp(uint64_t value);
  public:

  // optional uint32 sourceDevice = 7;
  bool has_sourcedevice() const;
  private:
  bool _internal_has_sourcedevice() const;
  public:
  void clear_sourcedevice();
  uint32_t sourcedevice() const;
  void set_sourcedevice(uint32_t value);
  private:
  uint32_t _internal_sourcedevice() const;
  void _internal_set_sourcedevice(uint32_t value);
  public:

  // required .SessionProtos.Envelope.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::SessionProtos::Envelope_Type type() const;
  void set_type(::SessionProtos::Envelope_Type value);
  private:
  ::SessionProtos::Envelope_Type _internal_type() const;
  void _internal_set_type(::SessionProtos::Envelope_Type value);
  public:

  // @@protoc_insertion_point(class_scope:SessionProtos.Envelope)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    uint64_t timestamp_;
    uint64_t servertimestamp_;
    uint32_t sourcedevice_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SessionProtos_2eproto;
};
// -------------------------------------------------------------------

class TypingMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SessionProtos.TypingMessage) */ {
 public:
  inline TypingMessage() : TypingMessage(nullptr) {}
  ~TypingMessage() override;
  explicit PROTOBUF_CONSTEXPR TypingMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TypingMessage(const TypingMessage& from);
  TypingMessage(TypingMessage&& from) noexcept
    : TypingMessage() {
    *this = ::std::move(from);
  }

  inline TypingMessage& operator=(const TypingMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypingMessage& operator=(TypingMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TypingMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TypingMessage* internal_default_instance() {
    return reinterpret_cast<const TypingMessage*>(
               &_TypingMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TypingMessage& a, TypingMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TypingMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypingMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypingMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TypingMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TypingMessage& from);
  void MergeFrom(const TypingMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TypingMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SessionProtos.TypingMessage";
  }
  protected:
  explicit TypingMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TypingMessage_Action Action;
  static constexpr Action STARTED =
    TypingMessage_Action_STARTED;
  static constexpr Action STOPPED =
    TypingMessage_Action_STOPPED;
  static inline bool Action_IsValid(int value) {
    return TypingMessage_Action_IsValid(value);
  }
  static constexpr Action Action_MIN =
    TypingMessage_Action_Action_MIN;
  static constexpr Action Action_MAX =
    TypingMessage_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE =
    TypingMessage_Action_Action_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Action_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Action>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Action_Name.");
    return TypingMessage_Action_Name(enum_t_value);
  }
  static inline bool Action_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Action* value) {
    return TypingMessage_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kActionFieldNumber = 2,
  };
  // required uint64 timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // required .SessionProtos.TypingMessage.Action action = 2;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  ::SessionProtos::TypingMessage_Action action() const;
  void set_action(::SessionProtos::TypingMessage_Action value);
  private:
  ::SessionProtos::TypingMessage_Action _internal_action() const;
  void _internal_set_action(::SessionProtos::TypingMessage_Action value);
  public:

  // @@protoc_insertion_point(class_scope:SessionProtos.TypingMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t timestamp_;
    int action_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SessionProtos_2eproto;
};
// -------------------------------------------------------------------

class UnsendRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SessionProtos.UnsendRequest) */ {
 public:
  inline UnsendRequest() : UnsendRequest(nullptr) {}
  ~UnsendRequest() override;
  explicit PROTOBUF_CONSTEXPR UnsendRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnsendRequest(const UnsendRequest& from);
  UnsendRequest(UnsendRequest&& from) noexcept
    : UnsendRequest() {
    *this = ::std::move(from);
  }

  inline UnsendRequest& operator=(const UnsendRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnsendRequest& operator=(UnsendRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UnsendRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnsendRequest* internal_default_instance() {
    return reinterpret_cast<const UnsendRequest*>(
               &_UnsendRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UnsendRequest& a, UnsendRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UnsendRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnsendRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnsendRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnsendRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UnsendRequest& from);
  void MergeFrom(const UnsendRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnsendRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SessionProtos.UnsendRequest";
  }
  protected:
  explicit UnsendRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorFieldNumber = 2,
    kTimestampFieldNumber = 1,
  };
  // required string author = 2;
  bool has_author() const;
  private:
  bool _internal_has_author() const;
  public:
  void clear_author();
  const std::string& author() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_author(ArgT0&& arg0, ArgT... args);
  std::string* mutable_author();
  PROTOBUF_NODISCARD std::string* release_author();
  void set_allocated_author(std::string* author);
  private:
  const std::string& _internal_author() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_author(const std::string& value);
  std::string* _internal_mutable_author();
  public:

  // required uint64 timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:SessionProtos.UnsendRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr author_;
    uint64_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SessionProtos_2eproto;
};
// -------------------------------------------------------------------

class MessageRequestResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SessionProtos.MessageRequestResponse) */ {
 public:
  inline MessageRequestResponse() : MessageRequestResponse(nullptr) {}
  ~MessageRequestResponse() override;
  explicit PROTOBUF_CONSTEXPR MessageRequestResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageRequestResponse(const MessageRequestResponse& from);
  MessageRequestResponse(MessageRequestResponse&& from) noexcept
    : MessageRequestResponse() {
    *this = ::std::move(from);
  }

  inline MessageRequestResponse& operator=(const MessageRequestResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageRequestResponse& operator=(MessageRequestResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MessageRequestResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageRequestResponse* internal_default_instance() {
    return reinterpret_cast<const MessageRequestResponse*>(
               &_MessageRequestResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MessageRequestResponse& a, MessageRequestResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageRequestResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageRequestResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageRequestResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageRequestResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MessageRequestResponse& from);
  void MergeFrom(const MessageRequestResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MessageRequestResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SessionProtos.MessageRequestResponse";
  }
  protected:
  explicit MessageRequestResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProfileKeyFieldNumber = 2,
    kProfileFieldNumber = 3,
    kIsApprovedFieldNumber = 1,
  };
  // optional bytes profileKey = 2;
  bool has_profilekey() const;
  private:
  bool _internal_has_profilekey() const;
  public:
  void clear_profilekey();
  const std::string& profilekey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_profilekey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_profilekey();
  PROTOBUF_NODISCARD std::string* release_profilekey();
  void set_allocated_profilekey(std::string* profilekey);
  private:
  const std::string& _internal_profilekey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_profilekey(const std::string& value);
  std::string* _internal_mutable_profilekey();
  public:

  // optional .SessionProtos.LokiProfile profile = 3;
  bool has_profile() const;
  private:
  bool _internal_has_profile() const;
  public:
  void clear_profile();
  const ::SessionProtos::LokiProfile& profile() const;
  PROTOBUF_NODISCARD ::SessionProtos::LokiProfile* release_profile();
  ::SessionProtos::LokiProfile* mutable_profile();
  void set_allocated_profile(::SessionProtos::LokiProfile* profile);
  private:
  const ::SessionProtos::LokiProfile& _internal_profile() const;
  ::SessionProtos::LokiProfile* _internal_mutable_profile();
  public:
  void unsafe_arena_set_allocated_profile(
      ::SessionProtos::LokiProfile* profile);
  ::SessionProtos::LokiProfile* unsafe_arena_release_profile();

  // required bool isApproved = 1;
  bool has_isapproved() const;
  private:
  bool _internal_has_isapproved() const;
  public:
  void clear_isapproved();
  bool isapproved() const;
  void set_isapproved(bool value);
  private:
  bool _internal_isapproved() const;
  void _internal_set_isapproved(bool value);
  public:

  // @@protoc_insertion_point(class_scope:SessionProtos.MessageRequestResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr profilekey_;
    ::SessionProtos::LokiProfile* profile_;
    bool isapproved_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SessionProtos_2eproto;
};
// -------------------------------------------------------------------

class Content final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SessionProtos.Content) */ {
 public:
  inline Content() : Content(nullptr) {}
  ~Content() override;
  explicit PROTOBUF_CONSTEXPR Content(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Content(const Content& from);
  Content(Content&& from) noexcept
    : Content() {
    *this = ::std::move(from);
  }

  inline Content& operator=(const Content& from) {
    CopyFrom(from);
    return *this;
  }
  inline Content& operator=(Content&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Content& default_instance() {
    return *internal_default_instance();
  }
  static inline const Content* internal_default_instance() {
    return reinterpret_cast<const Content*>(
               &_Content_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Content& a, Content& b) {
    a.Swap(&b);
  }
  inline void Swap(Content* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Content* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Content* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Content>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Content& from);
  void MergeFrom(const Content& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Content* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SessionProtos.Content";
  }
  protected:
  explicit Content(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataMessageFieldNumber = 1,
    kCallMessageFieldNumber = 3,
    kReceiptMessageFieldNumber = 5,
    kTypingMessageFieldNumber = 6,
    kConfigurationMessageFieldNumber = 7,
    kDataExtractionNotificationFieldNumber = 8,
    kUnsendRequestFieldNumber = 9,
    kMessageRequestResponseFieldNumber = 10,
    kSharedConfigMessageFieldNumber = 11,
  };
  // optional .SessionProtos.DataMessage dataMessage = 1;
  bool has_datamessage() const;
  private:
  bool _internal_has_datamessage() const;
  public:
  void clear_datamessage();
  const ::SessionProtos::DataMessage& datamessage() const;
  PROTOBUF_NODISCARD ::SessionProtos::DataMessage* release_datamessage();
  ::SessionProtos::DataMessage* mutable_datamessage();
  void set_allocated_datamessage(::SessionProtos::DataMessage* datamessage);
  private:
  const ::SessionProtos::DataMessage& _internal_datamessage() const;
  ::SessionProtos::DataMessage* _internal_mutable_datamessage();
  public:
  void unsafe_arena_set_allocated_datamessage(
      ::SessionProtos::DataMessage* datamessage);
  ::SessionProtos::DataMessage* unsafe_arena_release_datamessage();

  // optional .SessionProtos.CallMessage callMessage = 3;
  bool has_callmessage() const;
  private:
  bool _internal_has_callmessage() const;
  public:
  void clear_callmessage();
  const ::SessionProtos::CallMessage& callmessage() const;
  PROTOBUF_NODISCARD ::SessionProtos::CallMessage* release_callmessage();
  ::SessionProtos::CallMessage* mutable_callmessage();
  void set_allocated_callmessage(::SessionProtos::CallMessage* callmessage);
  private:
  const ::SessionProtos::CallMessage& _internal_callmessage() const;
  ::SessionProtos::CallMessage* _internal_mutable_callmessage();
  public:
  void unsafe_arena_set_allocated_callmessage(
      ::SessionProtos::CallMessage* callmessage);
  ::SessionProtos::CallMessage* unsafe_arena_release_callmessage();

  // optional .SessionProtos.ReceiptMessage receiptMessage = 5;
  bool has_receiptmessage() const;
  private:
  bool _internal_has_receiptmessage() const;
  public:
  void clear_receiptmessage();
  const ::SessionProtos::ReceiptMessage& receiptmessage() const;
  PROTOBUF_NODISCARD ::SessionProtos::ReceiptMessage* release_receiptmessage();
  ::SessionProtos::ReceiptMessage* mutable_receiptmessage();
  void set_allocated_receiptmessage(::SessionProtos::ReceiptMessage* receiptmessage);
  private:
  const ::SessionProtos::ReceiptMessage& _internal_receiptmessage() const;
  ::SessionProtos::ReceiptMessage* _internal_mutable_receiptmessage();
  public:
  void unsafe_arena_set_allocated_receiptmessage(
      ::SessionProtos::ReceiptMessage* receiptmessage);
  ::SessionProtos::ReceiptMessage* unsafe_arena_release_receiptmessage();

  // optional .SessionProtos.TypingMessage typingMessage = 6;
  bool has_typingmessage() const;
  private:
  bool _internal_has_typingmessage() const;
  public:
  void clear_typingmessage();
  const ::SessionProtos::TypingMessage& typingmessage() const;
  PROTOBUF_NODISCARD ::SessionProtos::TypingMessage* release_typingmessage();
  ::SessionProtos::TypingMessage* mutable_typingmessage();
  void set_allocated_typingmessage(::SessionProtos::TypingMessage* typingmessage);
  private:
  const ::SessionProtos::TypingMessage& _internal_typingmessage() const;
  ::SessionProtos::TypingMessage* _internal_mutable_typingmessage();
  public:
  void unsafe_arena_set_allocated_typingmessage(
      ::SessionProtos::TypingMessage* typingmessage);
  ::SessionProtos::TypingMessage* unsafe_arena_release_typingmessage();

  // optional .SessionProtos.ConfigurationMessage configurationMessage = 7;
  bool has_configurationmessage() const;
  private:
  bool _internal_has_configurationmessage() const;
  public:
  void clear_configurationmessage();
  const ::SessionProtos::ConfigurationMessage& configurationmessage() const;
  PROTOBUF_NODISCARD ::SessionProtos::ConfigurationMessage* release_configurationmessage();
  ::SessionProtos::ConfigurationMessage* mutable_configurationmessage();
  void set_allocated_configurationmessage(::SessionProtos::ConfigurationMessage* configurationmessage);
  private:
  const ::SessionProtos::ConfigurationMessage& _internal_configurationmessage() const;
  ::SessionProtos::ConfigurationMessage* _internal_mutable_configurationmessage();
  public:
  void unsafe_arena_set_allocated_configurationmessage(
      ::SessionProtos::ConfigurationMessage* configurationmessage);
  ::SessionProtos::ConfigurationMessage* unsafe_arena_release_configurationmessage();

  // optional .SessionProtos.DataExtractionNotification dataExtractionNotification = 8;
  bool has_dataextractionnotification() const;
  private:
  bool _internal_has_dataextractionnotification() const;
  public:
  void clear_dataextractionnotification();
  const ::SessionProtos::DataExtractionNotification& dataextractionnotification() const;
  PROTOBUF_NODISCARD ::SessionProtos::DataExtractionNotification* release_dataextractionnotification();
  ::SessionProtos::DataExtractionNotification* mutable_dataextractionnotification();
  void set_allocated_dataextractionnotification(::SessionProtos::DataExtractionNotification* dataextractionnotification);
  private:
  const ::SessionProtos::DataExtractionNotification& _internal_dataextractionnotification() const;
  ::SessionProtos::DataExtractionNotification* _internal_mutable_dataextractionnotification();
  public:
  void unsafe_arena_set_allocated_dataextractionnotification(
      ::SessionProtos::DataExtractionNotification* dataextractionnotification);
  ::SessionProtos::DataExtractionNotification* unsafe_arena_release_dataextractionnotification();

  // optional .SessionProtos.UnsendRequest unsendRequest = 9;
  bool has_unsendrequest() const;
  private:
  bool _internal_has_unsendrequest() const;
  public:
  void clear_unsendrequest();
  const ::SessionProtos::UnsendRequest& unsendrequest() const;
  PROTOBUF_NODISCARD ::SessionProtos::UnsendRequest* release_unsendrequest();
  ::SessionProtos::UnsendRequest* mutable_unsendrequest();
  void set_allocated_unsendrequest(::SessionProtos::UnsendRequest* unsendrequest);
  private:
  const ::SessionProtos::UnsendRequest& _internal_unsendrequest() const;
  ::SessionProtos::UnsendRequest* _internal_mutable_unsendrequest();
  public:
  void unsafe_arena_set_allocated_unsendrequest(
      ::SessionProtos::UnsendRequest* unsendrequest);
  ::SessionProtos::UnsendRequest* unsafe_arena_release_unsendrequest();

  // optional .SessionProtos.MessageRequestResponse messageRequestResponse = 10;
  bool has_messagerequestresponse() const;
  private:
  bool _internal_has_messagerequestresponse() const;
  public:
  void clear_messagerequestresponse();
  const ::SessionProtos::MessageRequestResponse& messagerequestresponse() const;
  PROTOBUF_NODISCARD ::SessionProtos::MessageRequestResponse* release_messagerequestresponse();
  ::SessionProtos::MessageRequestResponse* mutable_messagerequestresponse();
  void set_allocated_messagerequestresponse(::SessionProtos::MessageRequestResponse* messagerequestresponse);
  private:
  const ::SessionProtos::MessageRequestResponse& _internal_messagerequestresponse() const;
  ::SessionProtos::MessageRequestResponse* _internal_mutable_messagerequestresponse();
  public:
  void unsafe_arena_set_allocated_messagerequestresponse(
      ::SessionProtos::MessageRequestResponse* messagerequestresponse);
  ::SessionProtos::MessageRequestResponse* unsafe_arena_release_messagerequestresponse();

  // optional .SessionProtos.SharedConfigMessage sharedConfigMessage = 11;
  bool has_sharedconfigmessage() const;
  private:
  bool _internal_has_sharedconfigmessage() const;
  public:
  void clear_sharedconfigmessage();
  const ::SessionProtos::SharedConfigMessage& sharedconfigmessage() const;
  PROTOBUF_NODISCARD ::SessionProtos::SharedConfigMessage* release_sharedconfigmessage();
  ::SessionProtos::SharedConfigMessage* mutable_sharedconfigmessage();
  void set_allocated_sharedconfigmessage(::SessionProtos::SharedConfigMessage* sharedconfigmessage);
  private:
  const ::SessionProtos::SharedConfigMessage& _internal_sharedconfigmessage() const;
  ::SessionProtos::SharedConfigMessage* _internal_mutable_sharedconfigmessage();
  public:
  void unsafe_arena_set_allocated_sharedconfigmessage(
      ::SessionProtos::SharedConfigMessage* sharedconfigmessage);
  ::SessionProtos::SharedConfigMessage* unsafe_arena_release_sharedconfigmessage();

  // @@protoc_insertion_point(class_scope:SessionProtos.Content)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::SessionProtos::DataMessage* datamessage_;
    ::SessionProtos::CallMessage* callmessage_;
    ::SessionProtos::ReceiptMessage* receiptmessage_;
    ::SessionProtos::TypingMessage* typingmessage_;
    ::SessionProtos::ConfigurationMessage* configurationmessage_;
    ::SessionProtos::DataExtractionNotification* dataextractionnotification_;
    ::SessionProtos::UnsendRequest* unsendrequest_;
    ::SessionProtos::MessageRequestResponse* messagerequestresponse_;
    ::SessionProtos::SharedConfigMessage* sharedconfigmessage_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SessionProtos_2eproto;
};
// -------------------------------------------------------------------

class CallMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SessionProtos.CallMessage) */ {
 public:
  inline CallMessage() : CallMessage(nullptr) {}
  ~CallMessage() override;
  explicit PROTOBUF_CONSTEXPR CallMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallMessage(const CallMessage& from);
  CallMessage(CallMessage&& from) noexcept
    : CallMessage() {
    *this = ::std::move(from);
  }

  inline CallMessage& operator=(const CallMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallMessage& operator=(CallMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CallMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallMessage* internal_default_instance() {
    return reinterpret_cast<const CallMessage*>(
               &_CallMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CallMessage& a, CallMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CallMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CallMessage& from);
  void MergeFrom(const CallMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CallMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SessionProtos.CallMessage";
  }
  protected:
  explicit CallMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CallMessage_Type Type;
  static constexpr Type PRE_OFFER =
    CallMessage_Type_PRE_OFFER;
  static constexpr Type OFFER =
    CallMessage_Type_OFFER;
  static constexpr Type ANSWER =
    CallMessage_Type_ANSWER;
  static constexpr Type PROVISIONAL_ANSWER =
    CallMessage_Type_PROVISIONAL_ANSWER;
  static constexpr Type ICE_CANDIDATES =
    CallMessage_Type_ICE_CANDIDATES;
  static constexpr Type END_CALL =
    CallMessage_Type_END_CALL;
  static inline bool Type_IsValid(int value) {
    return CallMessage_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    CallMessage_Type_Type_MIN;
  static constexpr Type Type_MAX =
    CallMessage_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    CallMessage_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return CallMessage_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return CallMessage_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSdpsFieldNumber = 2,
    kSdpMLineIndexesFieldNumber = 3,
    kSdpMidsFieldNumber = 4,
    kUuidFieldNumber = 5,
    kTypeFieldNumber = 1,
  };
  // repeated string sdps = 2;
  int sdps_size() const;
  private:
  int _internal_sdps_size() const;
  public:
  void clear_sdps();
  const std::string& sdps(int index) const;
  std::string* mutable_sdps(int index);
  void set_sdps(int index, const std::string& value);
  void set_sdps(int index, std::string&& value);
  void set_sdps(int index, const char* value);
  void set_sdps(int index, const char* value, size_t size);
  std::string* add_sdps();
  void add_sdps(const std::string& value);
  void add_sdps(std::string&& value);
  void add_sdps(const char* value);
  void add_sdps(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& sdps() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_sdps();
  private:
  const std::string& _internal_sdps(int index) const;
  std::string* _internal_add_sdps();
  public:

  // repeated uint32 sdpMLineIndexes = 3;
  int sdpmlineindexes_size() const;
  private:
  int _internal_sdpmlineindexes_size() const;
  public:
  void clear_sdpmlineindexes();
  private:
  uint32_t _internal_sdpmlineindexes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_sdpmlineindexes() const;
  void _internal_add_sdpmlineindexes(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_sdpmlineindexes();
  public:
  uint32_t sdpmlineindexes(int index) const;
  void set_sdpmlineindexes(int index, uint32_t value);
  void add_sdpmlineindexes(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      sdpmlineindexes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_sdpmlineindexes();

  // repeated string sdpMids = 4;
  int sdpmids_size() const;
  private:
  int _internal_sdpmids_size() const;
  public:
  void clear_sdpmids();
  const std::string& sdpmids(int index) const;
  std::string* mutable_sdpmids(int index);
  void set_sdpmids(int index, const std::string& value);
  void set_sdpmids(int index, std::string&& value);
  void set_sdpmids(int index, const char* value);
  void set_sdpmids(int index, const char* value, size_t size);
  std::string* add_sdpmids();
  void add_sdpmids(const std::string& value);
  void add_sdpmids(std::string&& value);
  void add_sdpmids(const char* value);
  void add_sdpmids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& sdpmids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_sdpmids();
  private:
  const std::string& _internal_sdpmids(int index) const;
  std::string* _internal_add_sdpmids();
  public:

  // required string uuid = 5;
  bool has_uuid() const;
  private:
  bool _internal_has_uuid() const;
  public:
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // required .SessionProtos.CallMessage.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::SessionProtos::CallMessage_Type type() const;
  void set_type(::SessionProtos::CallMessage_Type value);
  private:
  ::SessionProtos::CallMessage_Type _internal_type() const;
  void _internal_set_type(::SessionProtos::CallMessage_Type value);
  public:

  // @@protoc_insertion_point(class_scope:SessionProtos.CallMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> sdps_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > sdpmlineindexes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> sdpmids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SessionProtos_2eproto;
};
// -------------------------------------------------------------------

class KeyPair final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SessionProtos.KeyPair) */ {
 public:
  inline KeyPair() : KeyPair(nullptr) {}
  ~KeyPair() override;
  explicit PROTOBUF_CONSTEXPR KeyPair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyPair(const KeyPair& from);
  KeyPair(KeyPair&& from) noexcept
    : KeyPair() {
    *this = ::std::move(from);
  }

  inline KeyPair& operator=(const KeyPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyPair& operator=(KeyPair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const KeyPair& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyPair* internal_default_instance() {
    return reinterpret_cast<const KeyPair*>(
               &_KeyPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(KeyPair& a, KeyPair& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyPair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyPair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyPair>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const KeyPair& from);
  void MergeFrom(const KeyPair& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KeyPair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SessionProtos.KeyPair";
  }
  protected:
  explicit KeyPair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 1,
    kPrivateKeyFieldNumber = 2,
  };
  // required bytes publicKey = 1;
  bool has_publickey() const;
  private:
  bool _internal_has_publickey() const;
  public:
  void clear_publickey();
  const std::string& publickey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_publickey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_publickey();
  PROTOBUF_NODISCARD std::string* release_publickey();
  void set_allocated_publickey(std::string* publickey);
  private:
  const std::string& _internal_publickey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publickey(const std::string& value);
  std::string* _internal_mutable_publickey();
  public:

  // required bytes privateKey = 2;
  bool has_privatekey() const;
  private:
  bool _internal_has_privatekey() const;
  public:
  void clear_privatekey();
  const std::string& privatekey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_privatekey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_privatekey();
  PROTOBUF_NODISCARD std::string* release_privatekey();
  void set_allocated_privatekey(std::string* privatekey);
  private:
  const std::string& _internal_privatekey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_privatekey(const std::string& value);
  std::string* _internal_mutable_privatekey();
  public:

  // @@protoc_insertion_point(class_scope:SessionProtos.KeyPair)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publickey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr privatekey_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SessionProtos_2eproto;
};
// -------------------------------------------------------------------

class DataExtractionNotification final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SessionProtos.DataExtractionNotification) */ {
 public:
  inline DataExtractionNotification() : DataExtractionNotification(nullptr) {}
  ~DataExtractionNotification() override;
  explicit PROTOBUF_CONSTEXPR DataExtractionNotification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataExtractionNotification(const DataExtractionNotification& from);
  DataExtractionNotification(DataExtractionNotification&& from) noexcept
    : DataExtractionNotification() {
    *this = ::std::move(from);
  }

  inline DataExtractionNotification& operator=(const DataExtractionNotification& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataExtractionNotification& operator=(DataExtractionNotification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DataExtractionNotification& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataExtractionNotification* internal_default_instance() {
    return reinterpret_cast<const DataExtractionNotification*>(
               &_DataExtractionNotification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DataExtractionNotification& a, DataExtractionNotification& b) {
    a.Swap(&b);
  }
  inline void Swap(DataExtractionNotification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataExtractionNotification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataExtractionNotification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataExtractionNotification>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DataExtractionNotification& from);
  void MergeFrom(const DataExtractionNotification& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataExtractionNotification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SessionProtos.DataExtractionNotification";
  }
  protected:
  explicit DataExtractionNotification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DataExtractionNotification_Type Type;
  static constexpr Type SCREENSHOT =
    DataExtractionNotification_Type_SCREENSHOT;
  static constexpr Type MEDIA_SAVED =
    DataExtractionNotification_Type_MEDIA_SAVED;
  static inline bool Type_IsValid(int value) {
    return DataExtractionNotification_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    DataExtractionNotification_Type_Type_MIN;
  static constexpr Type Type_MAX =
    DataExtractionNotification_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    DataExtractionNotification_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return DataExtractionNotification_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return DataExtractionNotification_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional uint64 timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // required .SessionProtos.DataExtractionNotification.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::SessionProtos::DataExtractionNotification_Type type() const;
  void set_type(::SessionProtos::DataExtractionNotification_Type value);
  private:
  ::SessionProtos::DataExtractionNotification_Type _internal_type() const;
  void _internal_set_type(::SessionProtos::DataExtractionNotification_Type value);
  public:

  // @@protoc_insertion_point(class_scope:SessionProtos.DataExtractionNotification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t timestamp_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SessionProtos_2eproto;
};
// -------------------------------------------------------------------

class LokiProfile final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SessionProtos.LokiProfile) */ {
 public:
  inline LokiProfile() : LokiProfile(nullptr) {}
  ~LokiProfile() override;
  explicit PROTOBUF_CONSTEXPR LokiProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LokiProfile(const LokiProfile& from);
  LokiProfile(LokiProfile&& from) noexcept
    : LokiProfile() {
    *this = ::std::move(from);
  }

  inline LokiProfile& operator=(const LokiProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline LokiProfile& operator=(LokiProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LokiProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const LokiProfile* internal_default_instance() {
    return reinterpret_cast<const LokiProfile*>(
               &_LokiProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LokiProfile& a, LokiProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(LokiProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LokiProfile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LokiProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LokiProfile>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LokiProfile& from);
  void MergeFrom(const LokiProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LokiProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SessionProtos.LokiProfile";
  }
  protected:
  explicit LokiProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisplayNameFieldNumber = 1,
    kProfilePictureFieldNumber = 2,
  };
  // optional string displayName = 1;
  bool has_displayname() const;
  private:
  bool _internal_has_displayname() const;
  public:
  void clear_displayname();
  const std::string& displayname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_displayname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_displayname();
  PROTOBUF_NODISCARD std::string* release_displayname();
  void set_allocated_displayname(std::string* displayname);
  private:
  const std::string& _internal_displayname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_displayname(const std::string& value);
  std::string* _internal_mutable_displayname();
  public:

  // optional string profilePicture = 2;
  bool has_profilepicture() const;
  private:
  bool _internal_has_profilepicture() const;
  public:
  void clear_profilepicture();
  const std::string& profilepicture() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_profilepicture(ArgT0&& arg0, ArgT... args);
  std::string* mutable_profilepicture();
  PROTOBUF_NODISCARD std::string* release_profilepicture();
  void set_allocated_profilepicture(std::string* profilepicture);
  private:
  const std::string& _internal_profilepicture() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_profilepicture(const std::string& value);
  std::string* _internal_mutable_profilepicture();
  public:

  // @@protoc_insertion_point(class_scope:SessionProtos.LokiProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr displayname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr profilepicture_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SessionProtos_2eproto;
};
// -------------------------------------------------------------------

class DataMessage_Quote_QuotedAttachment final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SessionProtos.DataMessage.Quote.QuotedAttachment) */ {
 public:
  inline DataMessage_Quote_QuotedAttachment() : DataMessage_Quote_QuotedAttachment(nullptr) {}
  ~DataMessage_Quote_QuotedAttachment() override;
  explicit PROTOBUF_CONSTEXPR DataMessage_Quote_QuotedAttachment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataMessage_Quote_QuotedAttachment(const DataMessage_Quote_QuotedAttachment& from);
  DataMessage_Quote_QuotedAttachment(DataMessage_Quote_QuotedAttachment&& from) noexcept
    : DataMessage_Quote_QuotedAttachment() {
    *this = ::std::move(from);
  }

  inline DataMessage_Quote_QuotedAttachment& operator=(const DataMessage_Quote_QuotedAttachment& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataMessage_Quote_QuotedAttachment& operator=(DataMessage_Quote_QuotedAttachment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DataMessage_Quote_QuotedAttachment& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataMessage_Quote_QuotedAttachment* internal_default_instance() {
    return reinterpret_cast<const DataMessage_Quote_QuotedAttachment*>(
               &_DataMessage_Quote_QuotedAttachment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DataMessage_Quote_QuotedAttachment& a, DataMessage_Quote_QuotedAttachment& b) {
    a.Swap(&b);
  }
  inline void Swap(DataMessage_Quote_QuotedAttachment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataMessage_Quote_QuotedAttachment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataMessage_Quote_QuotedAttachment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataMessage_Quote_QuotedAttachment>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DataMessage_Quote_QuotedAttachment& from);
  void MergeFrom(const DataMessage_Quote_QuotedAttachment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataMessage_Quote_QuotedAttachment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SessionProtos.DataMessage.Quote.QuotedAttachment";
  }
  protected:
  explicit DataMessage_Quote_QuotedAttachment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DataMessage_Quote_QuotedAttachment_Flags Flags;
  static constexpr Flags VOICE_MESSAGE =
    DataMessage_Quote_QuotedAttachment_Flags_VOICE_MESSAGE;
  static inline bool Flags_IsValid(int value) {
    return DataMessage_Quote_QuotedAttachment_Flags_IsValid(value);
  }
  static constexpr Flags Flags_MIN =
    DataMessage_Quote_QuotedAttachment_Flags_Flags_MIN;
  static constexpr Flags Flags_MAX =
    DataMessage_Quote_QuotedAttachment_Flags_Flags_MAX;
  static constexpr int Flags_ARRAYSIZE =
    DataMessage_Quote_QuotedAttachment_Flags_Flags_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Flags_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Flags>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Flags_Name.");
    return DataMessage_Quote_QuotedAttachment_Flags_Name(enum_t_value);
  }
  static inline bool Flags_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Flags* value) {
    return DataMessage_Quote_QuotedAttachment_Flags_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kContentTypeFieldNumber = 1,
    kFileNameFieldNumber = 2,
    kThumbnailFieldNumber = 3,
    kFlagsFieldNumber = 4,
  };
  // optional string contentType = 1;
  bool has_contenttype() const;
  private:
  bool _internal_has_contenttype() const;
  public:
  void clear_contenttype();
  const std::string& contenttype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contenttype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contenttype();
  PROTOBUF_NODISCARD std::string* release_contenttype();
  void set_allocated_contenttype(std::string* contenttype);
  private:
  const std::string& _internal_contenttype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contenttype(const std::string& value);
  std::string* _internal_mutable_contenttype();
  public:

  // optional string fileName = 2;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // optional .SessionProtos.AttachmentPointer thumbnail = 3;
  bool has_thumbnail() const;
  private:
  bool _internal_has_thumbnail() const;
  public:
  void clear_thumbnail();
  const ::SessionProtos::AttachmentPointer& thumbnail() const;
  PROTOBUF_NODISCARD ::SessionProtos::AttachmentPointer* release_thumbnail();
  ::SessionProtos::AttachmentPointer* mutable_thumbnail();
  void set_allocated_thumbnail(::SessionProtos::AttachmentPointer* thumbnail);
  private:
  const ::SessionProtos::AttachmentPointer& _internal_thumbnail() const;
  ::SessionProtos::AttachmentPointer* _internal_mutable_thumbnail();
  public:
  void unsafe_arena_set_allocated_thumbnail(
      ::SessionProtos::AttachmentPointer* thumbnail);
  ::SessionProtos::AttachmentPointer* unsafe_arena_release_thumbnail();

  // optional uint32 flags = 4;
  bool has_flags() const;
  private:
  bool _internal_has_flags() const;
  public:
  void clear_flags();
  uint32_t flags() const;
  void set_flags(uint32_t value);
  private:
  uint32_t _internal_flags() const;
  void _internal_set_flags(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SessionProtos.DataMessage.Quote.QuotedAttachment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contenttype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::SessionProtos::AttachmentPointer* thumbnail_;
    uint32_t flags_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SessionProtos_2eproto;
};
// -------------------------------------------------------------------

class DataMessage_Quote final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SessionProtos.DataMessage.Quote) */ {
 public:
  inline DataMessage_Quote() : DataMessage_Quote(nullptr) {}
  ~DataMessage_Quote() override;
  explicit PROTOBUF_CONSTEXPR DataMessage_Quote(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataMessage_Quote(const DataMessage_Quote& from);
  DataMessage_Quote(DataMessage_Quote&& from) noexcept
    : DataMessage_Quote() {
    *this = ::std::move(from);
  }

  inline DataMessage_Quote& operator=(const DataMessage_Quote& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataMessage_Quote& operator=(DataMessage_Quote&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DataMessage_Quote& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataMessage_Quote* internal_default_instance() {
    return reinterpret_cast<const DataMessage_Quote*>(
               &_DataMessage_Quote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DataMessage_Quote& a, DataMessage_Quote& b) {
    a.Swap(&b);
  }
  inline void Swap(DataMessage_Quote* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataMessage_Quote* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataMessage_Quote* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataMessage_Quote>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DataMessage_Quote& from);
  void MergeFrom(const DataMessage_Quote& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataMessage_Quote* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SessionProtos.DataMessage.Quote";
  }
  protected:
  explicit DataMessage_Quote(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DataMessage_Quote_QuotedAttachment QuotedAttachment;

  // accessors -------------------------------------------------------

  enum : int {
    kAttachmentsFieldNumber = 4,
    kAuthorFieldNumber = 2,
    kTextFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // repeated .SessionProtos.DataMessage.Quote.QuotedAttachment attachments = 4;
  int attachments_size() const;
  private:
  int _internal_attachments_size() const;
  public:
  void clear_attachments();
  ::SessionProtos::DataMessage_Quote_QuotedAttachment* mutable_attachments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::DataMessage_Quote_QuotedAttachment >*
      mutable_attachments();
  private:
  const ::SessionProtos::DataMessage_Quote_QuotedAttachment& _internal_attachments(int index) const;
  ::SessionProtos::DataMessage_Quote_QuotedAttachment* _internal_add_attachments();
  public:
  const ::SessionProtos::DataMessage_Quote_QuotedAttachment& attachments(int index) const;
  ::SessionProtos::DataMessage_Quote_QuotedAttachment* add_attachments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::DataMessage_Quote_QuotedAttachment >&
      attachments() const;

  // required string author = 2;
  bool has_author() const;
  private:
  bool _internal_has_author() const;
  public:
  void clear_author();
  const std::string& author() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_author(ArgT0&& arg0, ArgT... args);
  std::string* mutable_author();
  PROTOBUF_NODISCARD std::string* release_author();
  void set_allocated_author(std::string* author);
  private:
  const std::string& _internal_author() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_author(const std::string& value);
  std::string* _internal_mutable_author();
  public:

  // optional string text = 3;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // required uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:SessionProtos.DataMessage.Quote)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::DataMessage_Quote_QuotedAttachment > attachments_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr author_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    uint64_t id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SessionProtos_2eproto;
};
// -------------------------------------------------------------------

class DataMessage_Preview final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SessionProtos.DataMessage.Preview) */ {
 public:
  inline DataMessage_Preview() : DataMessage_Preview(nullptr) {}
  ~DataMessage_Preview() override;
  explicit PROTOBUF_CONSTEXPR DataMessage_Preview(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataMessage_Preview(const DataMessage_Preview& from);
  DataMessage_Preview(DataMessage_Preview&& from) noexcept
    : DataMessage_Preview() {
    *this = ::std::move(from);
  }

  inline DataMessage_Preview& operator=(const DataMessage_Preview& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataMessage_Preview& operator=(DataMessage_Preview&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DataMessage_Preview& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataMessage_Preview* internal_default_instance() {
    return reinterpret_cast<const DataMessage_Preview*>(
               &_DataMessage_Preview_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DataMessage_Preview& a, DataMessage_Preview& b) {
    a.Swap(&b);
  }
  inline void Swap(DataMessage_Preview* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataMessage_Preview* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataMessage_Preview* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataMessage_Preview>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DataMessage_Preview& from);
  void MergeFrom(const DataMessage_Preview& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataMessage_Preview* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SessionProtos.DataMessage.Preview";
  }
  protected:
  explicit DataMessage_Preview(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kTitleFieldNumber = 2,
    kImageFieldNumber = 3,
  };
  // required string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string title = 2;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional .SessionProtos.AttachmentPointer image = 3;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::SessionProtos::AttachmentPointer& image() const;
  PROTOBUF_NODISCARD ::SessionProtos::AttachmentPointer* release_image();
  ::SessionProtos::AttachmentPointer* mutable_image();
  void set_allocated_image(::SessionProtos::AttachmentPointer* image);
  private:
  const ::SessionProtos::AttachmentPointer& _internal_image() const;
  ::SessionProtos::AttachmentPointer* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::SessionProtos::AttachmentPointer* image);
  ::SessionProtos::AttachmentPointer* unsafe_arena_release_image();

  // @@protoc_insertion_point(class_scope:SessionProtos.DataMessage.Preview)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::SessionProtos::AttachmentPointer* image_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SessionProtos_2eproto;
};
// -------------------------------------------------------------------

class DataMessage_Reaction final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SessionProtos.DataMessage.Reaction) */ {
 public:
  inline DataMessage_Reaction() : DataMessage_Reaction(nullptr) {}
  ~DataMessage_Reaction() override;
  explicit PROTOBUF_CONSTEXPR DataMessage_Reaction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataMessage_Reaction(const DataMessage_Reaction& from);
  DataMessage_Reaction(DataMessage_Reaction&& from) noexcept
    : DataMessage_Reaction() {
    *this = ::std::move(from);
  }

  inline DataMessage_Reaction& operator=(const DataMessage_Reaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataMessage_Reaction& operator=(DataMessage_Reaction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DataMessage_Reaction& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataMessage_Reaction* internal_default_instance() {
    return reinterpret_cast<const DataMessage_Reaction*>(
               &_DataMessage_Reaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DataMessage_Reaction& a, DataMessage_Reaction& b) {
    a.Swap(&b);
  }
  inline void Swap(DataMessage_Reaction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataMessage_Reaction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataMessage_Reaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataMessage_Reaction>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DataMessage_Reaction& from);
  void MergeFrom(const DataMessage_Reaction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataMessage_Reaction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SessionProtos.DataMessage.Reaction";
  }
  protected:
  explicit DataMessage_Reaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DataMessage_Reaction_Action Action;
  static constexpr Action REACT =
    DataMessage_Reaction_Action_REACT;
  static constexpr Action REMOVE =
    DataMessage_Reaction_Action_REMOVE;
  static inline bool Action_IsValid(int value) {
    return DataMessage_Reaction_Action_IsValid(value);
  }
  static constexpr Action Action_MIN =
    DataMessage_Reaction_Action_Action_MIN;
  static constexpr Action Action_MAX =
    DataMessage_Reaction_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE =
    DataMessage_Reaction_Action_Action_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Action_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Action>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Action_Name.");
    return DataMessage_Reaction_Action_Name(enum_t_value);
  }
  static inline bool Action_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Action* value) {
    return DataMessage_Reaction_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorFieldNumber = 2,
    kEmojiFieldNumber = 3,
    kIdFieldNumber = 1,
    kActionFieldNumber = 4,
  };
  // required string author = 2;
  bool has_author() const;
  private:
  bool _internal_has_author() const;
  public:
  void clear_author();
  const std::string& author() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_author(ArgT0&& arg0, ArgT... args);
  std::string* mutable_author();
  PROTOBUF_NODISCARD std::string* release_author();
  void set_allocated_author(std::string* author);
  private:
  const std::string& _internal_author() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_author(const std::string& value);
  std::string* _internal_mutable_author();
  public:

  // optional string emoji = 3;
  bool has_emoji() const;
  private:
  bool _internal_has_emoji() const;
  public:
  void clear_emoji();
  const std::string& emoji() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_emoji(ArgT0&& arg0, ArgT... args);
  std::string* mutable_emoji();
  PROTOBUF_NODISCARD std::string* release_emoji();
  void set_allocated_emoji(std::string* emoji);
  private:
  const std::string& _internal_emoji() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_emoji(const std::string& value);
  std::string* _internal_mutable_emoji();
  public:

  // required uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // required .SessionProtos.DataMessage.Reaction.Action action = 4;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  ::SessionProtos::DataMessage_Reaction_Action action() const;
  void set_action(::SessionProtos::DataMessage_Reaction_Action value);
  private:
  ::SessionProtos::DataMessage_Reaction_Action _internal_action() const;
  void _internal_set_action(::SessionProtos::DataMessage_Reaction_Action value);
  public:

  // @@protoc_insertion_point(class_scope:SessionProtos.DataMessage.Reaction)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr author_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr emoji_;
    uint64_t id_;
    int action_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SessionProtos_2eproto;
};
// -------------------------------------------------------------------

class DataMessage_OpenGroupInvitation final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SessionProtos.DataMessage.OpenGroupInvitation) */ {
 public:
  inline DataMessage_OpenGroupInvitation() : DataMessage_OpenGroupInvitation(nullptr) {}
  ~DataMessage_OpenGroupInvitation() override;
  explicit PROTOBUF_CONSTEXPR DataMessage_OpenGroupInvitation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataMessage_OpenGroupInvitation(const DataMessage_OpenGroupInvitation& from);
  DataMessage_OpenGroupInvitation(DataMessage_OpenGroupInvitation&& from) noexcept
    : DataMessage_OpenGroupInvitation() {
    *this = ::std::move(from);
  }

  inline DataMessage_OpenGroupInvitation& operator=(const DataMessage_OpenGroupInvitation& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataMessage_OpenGroupInvitation& operator=(DataMessage_OpenGroupInvitation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DataMessage_OpenGroupInvitation& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataMessage_OpenGroupInvitation* internal_default_instance() {
    return reinterpret_cast<const DataMessage_OpenGroupInvitation*>(
               &_DataMessage_OpenGroupInvitation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DataMessage_OpenGroupInvitation& a, DataMessage_OpenGroupInvitation& b) {
    a.Swap(&b);
  }
  inline void Swap(DataMessage_OpenGroupInvitation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataMessage_OpenGroupInvitation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataMessage_OpenGroupInvitation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataMessage_OpenGroupInvitation>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DataMessage_OpenGroupInvitation& from);
  void MergeFrom(const DataMessage_OpenGroupInvitation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataMessage_OpenGroupInvitation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SessionProtos.DataMessage.OpenGroupInvitation";
  }
  protected:
  explicit DataMessage_OpenGroupInvitation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kNameFieldNumber = 3,
  };
  // required string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // required string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:SessionProtos.DataMessage.OpenGroupInvitation)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SessionProtos_2eproto;
};
// -------------------------------------------------------------------

class DataMessage_ClosedGroupControlMessage_KeyPairWrapper final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper) */ {
 public:
  inline DataMessage_ClosedGroupControlMessage_KeyPairWrapper() : DataMessage_ClosedGroupControlMessage_KeyPairWrapper(nullptr) {}
  ~DataMessage_ClosedGroupControlMessage_KeyPairWrapper() override;
  explicit PROTOBUF_CONSTEXPR DataMessage_ClosedGroupControlMessage_KeyPairWrapper(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataMessage_ClosedGroupControlMessage_KeyPairWrapper(const DataMessage_ClosedGroupControlMessage_KeyPairWrapper& from);
  DataMessage_ClosedGroupControlMessage_KeyPairWrapper(DataMessage_ClosedGroupControlMessage_KeyPairWrapper&& from) noexcept
    : DataMessage_ClosedGroupControlMessage_KeyPairWrapper() {
    *this = ::std::move(from);
  }

  inline DataMessage_ClosedGroupControlMessage_KeyPairWrapper& operator=(const DataMessage_ClosedGroupControlMessage_KeyPairWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataMessage_ClosedGroupControlMessage_KeyPairWrapper& operator=(DataMessage_ClosedGroupControlMessage_KeyPairWrapper&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DataMessage_ClosedGroupControlMessage_KeyPairWrapper& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataMessage_ClosedGroupControlMessage_KeyPairWrapper* internal_default_instance() {
    return reinterpret_cast<const DataMessage_ClosedGroupControlMessage_KeyPairWrapper*>(
               &_DataMessage_ClosedGroupControlMessage_KeyPairWrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DataMessage_ClosedGroupControlMessage_KeyPairWrapper& a, DataMessage_ClosedGroupControlMessage_KeyPairWrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(DataMessage_ClosedGroupControlMessage_KeyPairWrapper* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataMessage_ClosedGroupControlMessage_KeyPairWrapper* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataMessage_ClosedGroupControlMessage_KeyPairWrapper* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataMessage_ClosedGroupControlMessage_KeyPairWrapper>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DataMessage_ClosedGroupControlMessage_KeyPairWrapper& from);
  void MergeFrom(const DataMessage_ClosedGroupControlMessage_KeyPairWrapper& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataMessage_ClosedGroupControlMessage_KeyPairWrapper* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper";
  }
  protected:
  explicit DataMessage_ClosedGroupControlMessage_KeyPairWrapper(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 1,
    kEncryptedKeyPairFieldNumber = 2,
  };
  // required bytes publicKey = 1;
  bool has_publickey() const;
  private:
  bool _internal_has_publickey() const;
  public:
  void clear_publickey();
  const std::string& publickey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_publickey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_publickey();
  PROTOBUF_NODISCARD std::string* release_publickey();
  void set_allocated_publickey(std::string* publickey);
  private:
  const std::string& _internal_publickey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publickey(const std::string& value);
  std::string* _internal_mutable_publickey();
  public:

  // required bytes encryptedKeyPair = 2;
  bool has_encryptedkeypair() const;
  private:
  bool _internal_has_encryptedkeypair() const;
  public:
  void clear_encryptedkeypair();
  const std::string& encryptedkeypair() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encryptedkeypair(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encryptedkeypair();
  PROTOBUF_NODISCARD std::string* release_encryptedkeypair();
  void set_allocated_encryptedkeypair(std::string* encryptedkeypair);
  private:
  const std::string& _internal_encryptedkeypair() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encryptedkeypair(const std::string& value);
  std::string* _internal_mutable_encryptedkeypair();
  public:

  // @@protoc_insertion_point(class_scope:SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publickey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encryptedkeypair_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SessionProtos_2eproto;
};
// -------------------------------------------------------------------

class DataMessage_ClosedGroupControlMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SessionProtos.DataMessage.ClosedGroupControlMessage) */ {
 public:
  inline DataMessage_ClosedGroupControlMessage() : DataMessage_ClosedGroupControlMessage(nullptr) {}
  ~DataMessage_ClosedGroupControlMessage() override;
  explicit PROTOBUF_CONSTEXPR DataMessage_ClosedGroupControlMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataMessage_ClosedGroupControlMessage(const DataMessage_ClosedGroupControlMessage& from);
  DataMessage_ClosedGroupControlMessage(DataMessage_ClosedGroupControlMessage&& from) noexcept
    : DataMessage_ClosedGroupControlMessage() {
    *this = ::std::move(from);
  }

  inline DataMessage_ClosedGroupControlMessage& operator=(const DataMessage_ClosedGroupControlMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataMessage_ClosedGroupControlMessage& operator=(DataMessage_ClosedGroupControlMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DataMessage_ClosedGroupControlMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataMessage_ClosedGroupControlMessage* internal_default_instance() {
    return reinterpret_cast<const DataMessage_ClosedGroupControlMessage*>(
               &_DataMessage_ClosedGroupControlMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(DataMessage_ClosedGroupControlMessage& a, DataMessage_ClosedGroupControlMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DataMessage_ClosedGroupControlMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataMessage_ClosedGroupControlMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataMessage_ClosedGroupControlMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataMessage_ClosedGroupControlMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DataMessage_ClosedGroupControlMessage& from);
  void MergeFrom(const DataMessage_ClosedGroupControlMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataMessage_ClosedGroupControlMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SessionProtos.DataMessage.ClosedGroupControlMessage";
  }
  protected:
  explicit DataMessage_ClosedGroupControlMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DataMessage_ClosedGroupControlMessage_KeyPairWrapper KeyPairWrapper;

  typedef DataMessage_ClosedGroupControlMessage_Type Type;
  static constexpr Type NEW =
    DataMessage_ClosedGroupControlMessage_Type_NEW;
  static constexpr Type ENCRYPTION_KEY_PAIR =
    DataMessage_ClosedGroupControlMessage_Type_ENCRYPTION_KEY_PAIR;
  static constexpr Type NAME_CHANGE =
    DataMessage_ClosedGroupControlMessage_Type_NAME_CHANGE;
  static constexpr Type MEMBERS_ADDED =
    DataMessage_ClosedGroupControlMessage_Type_MEMBERS_ADDED;
  static constexpr Type MEMBERS_REMOVED =
    DataMessage_ClosedGroupControlMessage_Type_MEMBERS_REMOVED;
  static constexpr Type MEMBER_LEFT =
    DataMessage_ClosedGroupControlMessage_Type_MEMBER_LEFT;
  static constexpr Type ENCRYPTION_KEY_PAIR_REQUEST =
    DataMessage_ClosedGroupControlMessage_Type_ENCRYPTION_KEY_PAIR_REQUEST;
  static inline bool Type_IsValid(int value) {
    return DataMessage_ClosedGroupControlMessage_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    DataMessage_ClosedGroupControlMessage_Type_Type_MIN;
  static constexpr Type Type_MAX =
    DataMessage_ClosedGroupControlMessage_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    DataMessage_ClosedGroupControlMessage_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return DataMessage_ClosedGroupControlMessage_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return DataMessage_ClosedGroupControlMessage_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 5,
    kAdminsFieldNumber = 6,
    kWrappersFieldNumber = 7,
    kPublicKeyFieldNumber = 2,
    kNameFieldNumber = 3,
    kEncryptionKeyPairFieldNumber = 4,
    kExpirationTimerFieldNumber = 8,
    kTypeFieldNumber = 1,
  };
  // repeated bytes members = 5;
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  const std::string& members(int index) const;
  std::string* mutable_members(int index);
  void set_members(int index, const std::string& value);
  void set_members(int index, std::string&& value);
  void set_members(int index, const char* value);
  void set_members(int index, const void* value, size_t size);
  std::string* add_members();
  void add_members(const std::string& value);
  void add_members(std::string&& value);
  void add_members(const char* value);
  void add_members(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& members() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_members();
  private:
  const std::string& _internal_members(int index) const;
  std::string* _internal_add_members();
  public:

  // repeated bytes admins = 6;
  int admins_size() const;
  private:
  int _internal_admins_size() const;
  public:
  void clear_admins();
  const std::string& admins(int index) const;
  std::string* mutable_admins(int index);
  void set_admins(int index, const std::string& value);
  void set_admins(int index, std::string&& value);
  void set_admins(int index, const char* value);
  void set_admins(int index, const void* value, size_t size);
  std::string* add_admins();
  void add_admins(const std::string& value);
  void add_admins(std::string&& value);
  void add_admins(const char* value);
  void add_admins(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& admins() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_admins();
  private:
  const std::string& _internal_admins(int index) const;
  std::string* _internal_add_admins();
  public:

  // repeated .SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper wrappers = 7;
  int wrappers_size() const;
  private:
  int _internal_wrappers_size() const;
  public:
  void clear_wrappers();
  ::SessionProtos::DataMessage_ClosedGroupControlMessage_KeyPairWrapper* mutable_wrappers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::DataMessage_ClosedGroupControlMessage_KeyPairWrapper >*
      mutable_wrappers();
  private:
  const ::SessionProtos::DataMessage_ClosedGroupControlMessage_KeyPairWrapper& _internal_wrappers(int index) const;
  ::SessionProtos::DataMessage_ClosedGroupControlMessage_KeyPairWrapper* _internal_add_wrappers();
  public:
  const ::SessionProtos::DataMessage_ClosedGroupControlMessage_KeyPairWrapper& wrappers(int index) const;
  ::SessionProtos::DataMessage_ClosedGroupControlMessage_KeyPairWrapper* add_wrappers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::DataMessage_ClosedGroupControlMessage_KeyPairWrapper >&
      wrappers() const;

  // optional bytes publicKey = 2;
  bool has_publickey() const;
  private:
  bool _internal_has_publickey() const;
  public:
  void clear_publickey();
  const std::string& publickey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_publickey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_publickey();
  PROTOBUF_NODISCARD std::string* release_publickey();
  void set_allocated_publickey(std::string* publickey);
  private:
  const std::string& _internal_publickey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publickey(const std::string& value);
  std::string* _internal_mutable_publickey();
  public:

  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .SessionProtos.KeyPair encryptionKeyPair = 4;
  bool has_encryptionkeypair() const;
  private:
  bool _internal_has_encryptionkeypair() const;
  public:
  void clear_encryptionkeypair();
  const ::SessionProtos::KeyPair& encryptionkeypair() const;
  PROTOBUF_NODISCARD ::SessionProtos::KeyPair* release_encryptionkeypair();
  ::SessionProtos::KeyPair* mutable_encryptionkeypair();
  void set_allocated_encryptionkeypair(::SessionProtos::KeyPair* encryptionkeypair);
  private:
  const ::SessionProtos::KeyPair& _internal_encryptionkeypair() const;
  ::SessionProtos::KeyPair* _internal_mutable_encryptionkeypair();
  public:
  void unsafe_arena_set_allocated_encryptionkeypair(
      ::SessionProtos::KeyPair* encryptionkeypair);
  ::SessionProtos::KeyPair* unsafe_arena_release_encryptionkeypair();

  // optional uint32 expirationTimer = 8;
  bool has_expirationtimer() const;
  private:
  bool _internal_has_expirationtimer() const;
  public:
  void clear_expirationtimer();
  uint32_t expirationtimer() const;
  void set_expirationtimer(uint32_t value);
  private:
  uint32_t _internal_expirationtimer() const;
  void _internal_set_expirationtimer(uint32_t value);
  public:

  // required .SessionProtos.DataMessage.ClosedGroupControlMessage.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::SessionProtos::DataMessage_ClosedGroupControlMessage_Type type() const;
  void set_type(::SessionProtos::DataMessage_ClosedGroupControlMessage_Type value);
  private:
  ::SessionProtos::DataMessage_ClosedGroupControlMessage_Type _internal_type() const;
  void _internal_set_type(::SessionProtos::DataMessage_ClosedGroupControlMessage_Type value);
  public:

  // @@protoc_insertion_point(class_scope:SessionProtos.DataMessage.ClosedGroupControlMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> members_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> admins_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::DataMessage_ClosedGroupControlMessage_KeyPairWrapper > wrappers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publickey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::SessionProtos::KeyPair* encryptionkeypair_;
    uint32_t expirationtimer_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SessionProtos_2eproto;
};
// -------------------------------------------------------------------

class DataMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SessionProtos.DataMessage) */ {
 public:
  inline DataMessage() : DataMessage(nullptr) {}
  ~DataMessage() override;
  explicit PROTOBUF_CONSTEXPR DataMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataMessage(const DataMessage& from);
  DataMessage(DataMessage&& from) noexcept
    : DataMessage() {
    *this = ::std::move(from);
  }

  inline DataMessage& operator=(const DataMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataMessage& operator=(DataMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DataMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataMessage* internal_default_instance() {
    return reinterpret_cast<const DataMessage*>(
               &_DataMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(DataMessage& a, DataMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DataMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DataMessage& from);
  void MergeFrom(const DataMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SessionProtos.DataMessage";
  }
  protected:
  explicit DataMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DataMessage_Quote Quote;
  typedef DataMessage_Preview Preview;
  typedef DataMessage_Reaction Reaction;
  typedef DataMessage_OpenGroupInvitation OpenGroupInvitation;
  typedef DataMessage_ClosedGroupControlMessage ClosedGroupControlMessage;

  typedef DataMessage_Flags Flags;
  static constexpr Flags EXPIRATION_TIMER_UPDATE =
    DataMessage_Flags_EXPIRATION_TIMER_UPDATE;
  static inline bool Flags_IsValid(int value) {
    return DataMessage_Flags_IsValid(value);
  }
  static constexpr Flags Flags_MIN =
    DataMessage_Flags_Flags_MIN;
  static constexpr Flags Flags_MAX =
    DataMessage_Flags_Flags_MAX;
  static constexpr int Flags_ARRAYSIZE =
    DataMessage_Flags_Flags_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Flags_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Flags>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Flags_Name.");
    return DataMessage_Flags_Name(enum_t_value);
  }
  static inline bool Flags_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Flags* value) {
    return DataMessage_Flags_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAttachmentsFieldNumber = 2,
    kPreviewFieldNumber = 10,
    kBodyFieldNumber = 1,
    kProfileKeyFieldNumber = 6,
    kSyncTargetFieldNumber = 105,
    kQuoteFieldNumber = 8,
    kReactionFieldNumber = 11,
    kProfileFieldNumber = 101,
    kOpenGroupInvitationFieldNumber = 102,
    kClosedGroupControlMessageFieldNumber = 104,
    kFlagsFieldNumber = 4,
    kExpireTimerFieldNumber = 5,
    kTimestampFieldNumber = 7,
    kBlocksCommunityMessageRequestsFieldNumber = 106,
  };
  // repeated .SessionProtos.AttachmentPointer attachments = 2;
  int attachments_size() const;
  private:
  int _internal_attachments_size() const;
  public:
  void clear_attachments();
  ::SessionProtos::AttachmentPointer* mutable_attachments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::AttachmentPointer >*
      mutable_attachments();
  private:
  const ::SessionProtos::AttachmentPointer& _internal_attachments(int index) const;
  ::SessionProtos::AttachmentPointer* _internal_add_attachments();
  public:
  const ::SessionProtos::AttachmentPointer& attachments(int index) const;
  ::SessionProtos::AttachmentPointer* add_attachments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::AttachmentPointer >&
      attachments() const;

  // repeated .SessionProtos.DataMessage.Preview preview = 10;
  int preview_size() const;
  private:
  int _internal_preview_size() const;
  public:
  void clear_preview();
  ::SessionProtos::DataMessage_Preview* mutable_preview(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::DataMessage_Preview >*
      mutable_preview();
  private:
  const ::SessionProtos::DataMessage_Preview& _internal_preview(int index) const;
  ::SessionProtos::DataMessage_Preview* _internal_add_preview();
  public:
  const ::SessionProtos::DataMessage_Preview& preview(int index) const;
  ::SessionProtos::DataMessage_Preview* add_preview();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::DataMessage_Preview >&
      preview() const;

  // optional string body = 1;
  bool has_body() const;
  private:
  bool _internal_has_body() const;
  public:
  void clear_body();
  const std::string& body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // optional bytes profileKey = 6;
  bool has_profilekey() const;
  private:
  bool _internal_has_profilekey() const;
  public:
  void clear_profilekey();
  const std::string& profilekey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_profilekey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_profilekey();
  PROTOBUF_NODISCARD std::string* release_profilekey();
  void set_allocated_profilekey(std::string* profilekey);
  private:
  const std::string& _internal_profilekey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_profilekey(const std::string& value);
  std::string* _internal_mutable_profilekey();
  public:

  // optional string syncTarget = 105;
  bool has_synctarget() const;
  private:
  bool _internal_has_synctarget() const;
  public:
  void clear_synctarget();
  const std::string& synctarget() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_synctarget(ArgT0&& arg0, ArgT... args);
  std::string* mutable_synctarget();
  PROTOBUF_NODISCARD std::string* release_synctarget();
  void set_allocated_synctarget(std::string* synctarget);
  private:
  const std::string& _internal_synctarget() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_synctarget(const std::string& value);
  std::string* _internal_mutable_synctarget();
  public:

  // optional .SessionProtos.DataMessage.Quote quote = 8;
  bool has_quote() const;
  private:
  bool _internal_has_quote() const;
  public:
  void clear_quote();
  const ::SessionProtos::DataMessage_Quote& quote() const;
  PROTOBUF_NODISCARD ::SessionProtos::DataMessage_Quote* release_quote();
  ::SessionProtos::DataMessage_Quote* mutable_quote();
  void set_allocated_quote(::SessionProtos::DataMessage_Quote* quote);
  private:
  const ::SessionProtos::DataMessage_Quote& _internal_quote() const;
  ::SessionProtos::DataMessage_Quote* _internal_mutable_quote();
  public:
  void unsafe_arena_set_allocated_quote(
      ::SessionProtos::DataMessage_Quote* quote);
  ::SessionProtos::DataMessage_Quote* unsafe_arena_release_quote();

  // optional .SessionProtos.DataMessage.Reaction reaction = 11;
  bool has_reaction() const;
  private:
  bool _internal_has_reaction() const;
  public:
  void clear_reaction();
  const ::SessionProtos::DataMessage_Reaction& reaction() const;
  PROTOBUF_NODISCARD ::SessionProtos::DataMessage_Reaction* release_reaction();
  ::SessionProtos::DataMessage_Reaction* mutable_reaction();
  void set_allocated_reaction(::SessionProtos::DataMessage_Reaction* reaction);
  private:
  const ::SessionProtos::DataMessage_Reaction& _internal_reaction() const;
  ::SessionProtos::DataMessage_Reaction* _internal_mutable_reaction();
  public:
  void unsafe_arena_set_allocated_reaction(
      ::SessionProtos::DataMessage_Reaction* reaction);
  ::SessionProtos::DataMessage_Reaction* unsafe_arena_release_reaction();

  // optional .SessionProtos.LokiProfile profile = 101;
  bool has_profile() const;
  private:
  bool _internal_has_profile() const;
  public:
  void clear_profile();
  const ::SessionProtos::LokiProfile& profile() const;
  PROTOBUF_NODISCARD ::SessionProtos::LokiProfile* release_profile();
  ::SessionProtos::LokiProfile* mutable_profile();
  void set_allocated_profile(::SessionProtos::LokiProfile* profile);
  private:
  const ::SessionProtos::LokiProfile& _internal_profile() const;
  ::SessionProtos::LokiProfile* _internal_mutable_profile();
  public:
  void unsafe_arena_set_allocated_profile(
      ::SessionProtos::LokiProfile* profile);
  ::SessionProtos::LokiProfile* unsafe_arena_release_profile();

  // optional .SessionProtos.DataMessage.OpenGroupInvitation openGroupInvitation = 102;
  bool has_opengroupinvitation() const;
  private:
  bool _internal_has_opengroupinvitation() const;
  public:
  void clear_opengroupinvitation();
  const ::SessionProtos::DataMessage_OpenGroupInvitation& opengroupinvitation() const;
  PROTOBUF_NODISCARD ::SessionProtos::DataMessage_OpenGroupInvitation* release_opengroupinvitation();
  ::SessionProtos::DataMessage_OpenGroupInvitation* mutable_opengroupinvitation();
  void set_allocated_opengroupinvitation(::SessionProtos::DataMessage_OpenGroupInvitation* opengroupinvitation);
  private:
  const ::SessionProtos::DataMessage_OpenGroupInvitation& _internal_opengroupinvitation() const;
  ::SessionProtos::DataMessage_OpenGroupInvitation* _internal_mutable_opengroupinvitation();
  public:
  void unsafe_arena_set_allocated_opengroupinvitation(
      ::SessionProtos::DataMessage_OpenGroupInvitation* opengroupinvitation);
  ::SessionProtos::DataMessage_OpenGroupInvitation* unsafe_arena_release_opengroupinvitation();

  // optional .SessionProtos.DataMessage.ClosedGroupControlMessage closedGroupControlMessage = 104;
  bool has_closedgroupcontrolmessage() const;
  private:
  bool _internal_has_closedgroupcontrolmessage() const;
  public:
  void clear_closedgroupcontrolmessage();
  const ::SessionProtos::DataMessage_ClosedGroupControlMessage& closedgroupcontrolmessage() const;
  PROTOBUF_NODISCARD ::SessionProtos::DataMessage_ClosedGroupControlMessage* release_closedgroupcontrolmessage();
  ::SessionProtos::DataMessage_ClosedGroupControlMessage* mutable_closedgroupcontrolmessage();
  void set_allocated_closedgroupcontrolmessage(::SessionProtos::DataMessage_ClosedGroupControlMessage* closedgroupcontrolmessage);
  private:
  const ::SessionProtos::DataMessage_ClosedGroupControlMessage& _internal_closedgroupcontrolmessage() const;
  ::SessionProtos::DataMessage_ClosedGroupControlMessage* _internal_mutable_closedgroupcontrolmessage();
  public:
  void unsafe_arena_set_allocated_closedgroupcontrolmessage(
      ::SessionProtos::DataMessage_ClosedGroupControlMessage* closedgroupcontrolmessage);
  ::SessionProtos::DataMessage_ClosedGroupControlMessage* unsafe_arena_release_closedgroupcontrolmessage();

  // optional uint32 flags = 4;
  bool has_flags() const;
  private:
  bool _internal_has_flags() const;
  public:
  void clear_flags();
  uint32_t flags() const;
  void set_flags(uint32_t value);
  private:
  uint32_t _internal_flags() const;
  void _internal_set_flags(uint32_t value);
  public:

  // optional uint32 expireTimer = 5;
  bool has_expiretimer() const;
  private:
  bool _internal_has_expiretimer() const;
  public:
  void clear_expiretimer();
  uint32_t expiretimer() const;
  void set_expiretimer(uint32_t value);
  private:
  uint32_t _internal_expiretimer() const;
  void _internal_set_expiretimer(uint32_t value);
  public:

  // optional uint64 timestamp = 7;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // optional bool blocksCommunityMessageRequests = 106;
  bool has_blockscommunitymessagerequests() const;
  private:
  bool _internal_has_blockscommunitymessagerequests() const;
  public:
  void clear_blockscommunitymessagerequests();
  bool blockscommunitymessagerequests() const;
  void set_blockscommunitymessagerequests(bool value);
  private:
  bool _internal_blockscommunitymessagerequests() const;
  void _internal_set_blockscommunitymessagerequests(bool value);
  public:

  // @@protoc_insertion_point(class_scope:SessionProtos.DataMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::AttachmentPointer > attachments_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::DataMessage_Preview > preview_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr profilekey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr synctarget_;
    ::SessionProtos::DataMessage_Quote* quote_;
    ::SessionProtos::DataMessage_Reaction* reaction_;
    ::SessionProtos::LokiProfile* profile_;
    ::SessionProtos::DataMessage_OpenGroupInvitation* opengroupinvitation_;
    ::SessionProtos::DataMessage_ClosedGroupControlMessage* closedgroupcontrolmessage_;
    uint32_t flags_;
    uint32_t expiretimer_;
    uint64_t timestamp_;
    bool blockscommunitymessagerequests_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SessionProtos_2eproto;
};
// -------------------------------------------------------------------

class ConfigurationMessage_ClosedGroup final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SessionProtos.ConfigurationMessage.ClosedGroup) */ {
 public:
  inline ConfigurationMessage_ClosedGroup() : ConfigurationMessage_ClosedGroup(nullptr) {}
  ~ConfigurationMessage_ClosedGroup() override;
  explicit PROTOBUF_CONSTEXPR ConfigurationMessage_ClosedGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigurationMessage_ClosedGroup(const ConfigurationMessage_ClosedGroup& from);
  ConfigurationMessage_ClosedGroup(ConfigurationMessage_ClosedGroup&& from) noexcept
    : ConfigurationMessage_ClosedGroup() {
    *this = ::std::move(from);
  }

  inline ConfigurationMessage_ClosedGroup& operator=(const ConfigurationMessage_ClosedGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigurationMessage_ClosedGroup& operator=(ConfigurationMessage_ClosedGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ConfigurationMessage_ClosedGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigurationMessage_ClosedGroup* internal_default_instance() {
    return reinterpret_cast<const ConfigurationMessage_ClosedGroup*>(
               &_ConfigurationMessage_ClosedGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ConfigurationMessage_ClosedGroup& a, ConfigurationMessage_ClosedGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigurationMessage_ClosedGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigurationMessage_ClosedGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigurationMessage_ClosedGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigurationMessage_ClosedGroup>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ConfigurationMessage_ClosedGroup& from);
  void MergeFrom(const ConfigurationMessage_ClosedGroup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConfigurationMessage_ClosedGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SessionProtos.ConfigurationMessage.ClosedGroup";
  }
  protected:
  explicit ConfigurationMessage_ClosedGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 4,
    kAdminsFieldNumber = 5,
    kPublicKeyFieldNumber = 1,
    kNameFieldNumber = 2,
    kEncryptionKeyPairFieldNumber = 3,
    kExpirationTimerFieldNumber = 6,
  };
  // repeated bytes members = 4;
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  const std::string& members(int index) const;
  std::string* mutable_members(int index);
  void set_members(int index, const std::string& value);
  void set_members(int index, std::string&& value);
  void set_members(int index, const char* value);
  void set_members(int index, const void* value, size_t size);
  std::string* add_members();
  void add_members(const std::string& value);
  void add_members(std::string&& value);
  void add_members(const char* value);
  void add_members(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& members() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_members();
  private:
  const std::string& _internal_members(int index) const;
  std::string* _internal_add_members();
  public:

  // repeated bytes admins = 5;
  int admins_size() const;
  private:
  int _internal_admins_size() const;
  public:
  void clear_admins();
  const std::string& admins(int index) const;
  std::string* mutable_admins(int index);
  void set_admins(int index, const std::string& value);
  void set_admins(int index, std::string&& value);
  void set_admins(int index, const char* value);
  void set_admins(int index, const void* value, size_t size);
  std::string* add_admins();
  void add_admins(const std::string& value);
  void add_admins(std::string&& value);
  void add_admins(const char* value);
  void add_admins(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& admins() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_admins();
  private:
  const std::string& _internal_admins(int index) const;
  std::string* _internal_add_admins();
  public:

  // optional bytes publicKey = 1;
  bool has_publickey() const;
  private:
  bool _internal_has_publickey() const;
  public:
  void clear_publickey();
  const std::string& publickey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_publickey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_publickey();
  PROTOBUF_NODISCARD std::string* release_publickey();
  void set_allocated_publickey(std::string* publickey);
  private:
  const std::string& _internal_publickey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publickey(const std::string& value);
  std::string* _internal_mutable_publickey();
  public:

  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .SessionProtos.KeyPair encryptionKeyPair = 3;
  bool has_encryptionkeypair() const;
  private:
  bool _internal_has_encryptionkeypair() const;
  public:
  void clear_encryptionkeypair();
  const ::SessionProtos::KeyPair& encryptionkeypair() const;
  PROTOBUF_NODISCARD ::SessionProtos::KeyPair* release_encryptionkeypair();
  ::SessionProtos::KeyPair* mutable_encryptionkeypair();
  void set_allocated_encryptionkeypair(::SessionProtos::KeyPair* encryptionkeypair);
  private:
  const ::SessionProtos::KeyPair& _internal_encryptionkeypair() const;
  ::SessionProtos::KeyPair* _internal_mutable_encryptionkeypair();
  public:
  void unsafe_arena_set_allocated_encryptionkeypair(
      ::SessionProtos::KeyPair* encryptionkeypair);
  ::SessionProtos::KeyPair* unsafe_arena_release_encryptionkeypair();

  // optional uint32 expirationTimer = 6;
  bool has_expirationtimer() const;
  private:
  bool _internal_has_expirationtimer() const;
  public:
  void clear_expirationtimer();
  uint32_t expirationtimer() const;
  void set_expirationtimer(uint32_t value);
  private:
  uint32_t _internal_expirationtimer() const;
  void _internal_set_expirationtimer(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SessionProtos.ConfigurationMessage.ClosedGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> members_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> admins_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publickey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::SessionProtos::KeyPair* encryptionkeypair_;
    uint32_t expirationtimer_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SessionProtos_2eproto;
};
// -------------------------------------------------------------------

class ConfigurationMessage_Contact final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SessionProtos.ConfigurationMessage.Contact) */ {
 public:
  inline ConfigurationMessage_Contact() : ConfigurationMessage_Contact(nullptr) {}
  ~ConfigurationMessage_Contact() override;
  explicit PROTOBUF_CONSTEXPR ConfigurationMessage_Contact(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigurationMessage_Contact(const ConfigurationMessage_Contact& from);
  ConfigurationMessage_Contact(ConfigurationMessage_Contact&& from) noexcept
    : ConfigurationMessage_Contact() {
    *this = ::std::move(from);
  }

  inline ConfigurationMessage_Contact& operator=(const ConfigurationMessage_Contact& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigurationMessage_Contact& operator=(ConfigurationMessage_Contact&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ConfigurationMessage_Contact& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigurationMessage_Contact* internal_default_instance() {
    return reinterpret_cast<const ConfigurationMessage_Contact*>(
               &_ConfigurationMessage_Contact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ConfigurationMessage_Contact& a, ConfigurationMessage_Contact& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigurationMessage_Contact* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigurationMessage_Contact* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigurationMessage_Contact* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigurationMessage_Contact>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ConfigurationMessage_Contact& from);
  void MergeFrom(const ConfigurationMessage_Contact& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConfigurationMessage_Contact* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SessionProtos.ConfigurationMessage.Contact";
  }
  protected:
  explicit ConfigurationMessage_Contact(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 1,
    kNameFieldNumber = 2,
    kProfilePictureFieldNumber = 3,
    kProfileKeyFieldNumber = 4,
    kIsApprovedFieldNumber = 5,
    kIsBlockedFieldNumber = 6,
    kDidApproveMeFieldNumber = 7,
  };
  // required bytes publicKey = 1;
  bool has_publickey() const;
  private:
  bool _internal_has_publickey() const;
  public:
  void clear_publickey();
  const std::string& publickey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_publickey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_publickey();
  PROTOBUF_NODISCARD std::string* release_publickey();
  void set_allocated_publickey(std::string* publickey);
  private:
  const std::string& _internal_publickey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publickey(const std::string& value);
  std::string* _internal_mutable_publickey();
  public:

  // required string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string profilePicture = 3;
  bool has_profilepicture() const;
  private:
  bool _internal_has_profilepicture() const;
  public:
  void clear_profilepicture();
  const std::string& profilepicture() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_profilepicture(ArgT0&& arg0, ArgT... args);
  std::string* mutable_profilepicture();
  PROTOBUF_NODISCARD std::string* release_profilepicture();
  void set_allocated_profilepicture(std::string* profilepicture);
  private:
  const std::string& _internal_profilepicture() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_profilepicture(const std::string& value);
  std::string* _internal_mutable_profilepicture();
  public:

  // optional bytes profileKey = 4;
  bool has_profilekey() const;
  private:
  bool _internal_has_profilekey() const;
  public:
  void clear_profilekey();
  const std::string& profilekey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_profilekey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_profilekey();
  PROTOBUF_NODISCARD std::string* release_profilekey();
  void set_allocated_profilekey(std::string* profilekey);
  private:
  const std::string& _internal_profilekey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_profilekey(const std::string& value);
  std::string* _internal_mutable_profilekey();
  public:

  // optional bool isApproved = 5;
  bool has_isapproved() const;
  private:
  bool _internal_has_isapproved() const;
  public:
  void clear_isapproved();
  bool isapproved() const;
  void set_isapproved(bool value);
  private:
  bool _internal_isapproved() const;
  void _internal_set_isapproved(bool value);
  public:

  // optional bool isBlocked = 6;
  bool has_isblocked() const;
  private:
  bool _internal_has_isblocked() const;
  public:
  void clear_isblocked();
  bool isblocked() const;
  void set_isblocked(bool value);
  private:
  bool _internal_isblocked() const;
  void _internal_set_isblocked(bool value);
  public:

  // optional bool didApproveMe = 7;
  bool has_didapproveme() const;
  private:
  bool _internal_has_didapproveme() const;
  public:
  void clear_didapproveme();
  bool didapproveme() const;
  void set_didapproveme(bool value);
  private:
  bool _internal_didapproveme() const;
  void _internal_set_didapproveme(bool value);
  public:

  // @@protoc_insertion_point(class_scope:SessionProtos.ConfigurationMessage.Contact)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publickey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr profilepicture_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr profilekey_;
    bool isapproved_;
    bool isblocked_;
    bool didapproveme_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SessionProtos_2eproto;
};
// -------------------------------------------------------------------

class ConfigurationMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SessionProtos.ConfigurationMessage) */ {
 public:
  inline ConfigurationMessage() : ConfigurationMessage(nullptr) {}
  ~ConfigurationMessage() override;
  explicit PROTOBUF_CONSTEXPR ConfigurationMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigurationMessage(const ConfigurationMessage& from);
  ConfigurationMessage(ConfigurationMessage&& from) noexcept
    : ConfigurationMessage() {
    *this = ::std::move(from);
  }

  inline ConfigurationMessage& operator=(const ConfigurationMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigurationMessage& operator=(ConfigurationMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ConfigurationMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigurationMessage* internal_default_instance() {
    return reinterpret_cast<const ConfigurationMessage*>(
               &_ConfigurationMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ConfigurationMessage& a, ConfigurationMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigurationMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigurationMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigurationMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigurationMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ConfigurationMessage& from);
  void MergeFrom(const ConfigurationMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConfigurationMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SessionProtos.ConfigurationMessage";
  }
  protected:
  explicit ConfigurationMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ConfigurationMessage_ClosedGroup ClosedGroup;
  typedef ConfigurationMessage_Contact Contact;

  // accessors -------------------------------------------------------

  enum : int {
    kClosedGroupsFieldNumber = 1,
    kOpenGroupsFieldNumber = 2,
    kContactsFieldNumber = 6,
    kDisplayNameFieldNumber = 3,
    kProfilePictureFieldNumber = 4,
    kProfileKeyFieldNumber = 5,
  };
  // repeated .SessionProtos.ConfigurationMessage.ClosedGroup closedGroups = 1;
  int closedgroups_size() const;
  private:
  int _internal_closedgroups_size() const;
  public:
  void clear_closedgroups();
  ::SessionProtos::ConfigurationMessage_ClosedGroup* mutable_closedgroups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::ConfigurationMessage_ClosedGroup >*
      mutable_closedgroups();
  private:
  const ::SessionProtos::ConfigurationMessage_ClosedGroup& _internal_closedgroups(int index) const;
  ::SessionProtos::ConfigurationMessage_ClosedGroup* _internal_add_closedgroups();
  public:
  const ::SessionProtos::ConfigurationMessage_ClosedGroup& closedgroups(int index) const;
  ::SessionProtos::ConfigurationMessage_ClosedGroup* add_closedgroups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::ConfigurationMessage_ClosedGroup >&
      closedgroups() const;

  // repeated string openGroups = 2;
  int opengroups_size() const;
  private:
  int _internal_opengroups_size() const;
  public:
  void clear_opengroups();
  const std::string& opengroups(int index) const;
  std::string* mutable_opengroups(int index);
  void set_opengroups(int index, const std::string& value);
  void set_opengroups(int index, std::string&& value);
  void set_opengroups(int index, const char* value);
  void set_opengroups(int index, const char* value, size_t size);
  std::string* add_opengroups();
  void add_opengroups(const std::string& value);
  void add_opengroups(std::string&& value);
  void add_opengroups(const char* value);
  void add_opengroups(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& opengroups() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_opengroups();
  private:
  const std::string& _internal_opengroups(int index) const;
  std::string* _internal_add_opengroups();
  public:

  // repeated .SessionProtos.ConfigurationMessage.Contact contacts = 6;
  int contacts_size() const;
  private:
  int _internal_contacts_size() const;
  public:
  void clear_contacts();
  ::SessionProtos::ConfigurationMessage_Contact* mutable_contacts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::ConfigurationMessage_Contact >*
      mutable_contacts();
  private:
  const ::SessionProtos::ConfigurationMessage_Contact& _internal_contacts(int index) const;
  ::SessionProtos::ConfigurationMessage_Contact* _internal_add_contacts();
  public:
  const ::SessionProtos::ConfigurationMessage_Contact& contacts(int index) const;
  ::SessionProtos::ConfigurationMessage_Contact* add_contacts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::ConfigurationMessage_Contact >&
      contacts() const;

  // optional string displayName = 3;
  bool has_displayname() const;
  private:
  bool _internal_has_displayname() const;
  public:
  void clear_displayname();
  const std::string& displayname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_displayname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_displayname();
  PROTOBUF_NODISCARD std::string* release_displayname();
  void set_allocated_displayname(std::string* displayname);
  private:
  const std::string& _internal_displayname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_displayname(const std::string& value);
  std::string* _internal_mutable_displayname();
  public:

  // optional string profilePicture = 4;
  bool has_profilepicture() const;
  private:
  bool _internal_has_profilepicture() const;
  public:
  void clear_profilepicture();
  const std::string& profilepicture() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_profilepicture(ArgT0&& arg0, ArgT... args);
  std::string* mutable_profilepicture();
  PROTOBUF_NODISCARD std::string* release_profilepicture();
  void set_allocated_profilepicture(std::string* profilepicture);
  private:
  const std::string& _internal_profilepicture() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_profilepicture(const std::string& value);
  std::string* _internal_mutable_profilepicture();
  public:

  // optional bytes profileKey = 5;
  bool has_profilekey() const;
  private:
  bool _internal_has_profilekey() const;
  public:
  void clear_profilekey();
  const std::string& profilekey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_profilekey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_profilekey();
  PROTOBUF_NODISCARD std::string* release_profilekey();
  void set_allocated_profilekey(std::string* profilekey);
  private:
  const std::string& _internal_profilekey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_profilekey(const std::string& value);
  std::string* _internal_mutable_profilekey();
  public:

  // @@protoc_insertion_point(class_scope:SessionProtos.ConfigurationMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::ConfigurationMessage_ClosedGroup > closedgroups_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> opengroups_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::ConfigurationMessage_Contact > contacts_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr displayname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr profilepicture_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr profilekey_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SessionProtos_2eproto;
};
// -------------------------------------------------------------------

class ReceiptMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SessionProtos.ReceiptMessage) */ {
 public:
  inline ReceiptMessage() : ReceiptMessage(nullptr) {}
  ~ReceiptMessage() override;
  explicit PROTOBUF_CONSTEXPR ReceiptMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReceiptMessage(const ReceiptMessage& from);
  ReceiptMessage(ReceiptMessage&& from) noexcept
    : ReceiptMessage() {
    *this = ::std::move(from);
  }

  inline ReceiptMessage& operator=(const ReceiptMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiptMessage& operator=(ReceiptMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ReceiptMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReceiptMessage* internal_default_instance() {
    return reinterpret_cast<const ReceiptMessage*>(
               &_ReceiptMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ReceiptMessage& a, ReceiptMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceiptMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceiptMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReceiptMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReceiptMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ReceiptMessage& from);
  void MergeFrom(const ReceiptMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReceiptMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SessionProtos.ReceiptMessage";
  }
  protected:
  explicit ReceiptMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ReceiptMessage_Type Type;
  static constexpr Type DELIVERY =
    ReceiptMessage_Type_DELIVERY;
  static constexpr Type READ =
    ReceiptMessage_Type_READ;
  static inline bool Type_IsValid(int value) {
    return ReceiptMessage_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    ReceiptMessage_Type_Type_MIN;
  static constexpr Type Type_MAX =
    ReceiptMessage_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    ReceiptMessage_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return ReceiptMessage_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return ReceiptMessage_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated uint64 timestamp = 2;
  int timestamp_size() const;
  private:
  int _internal_timestamp_size() const;
  public:
  void clear_timestamp();
  private:
  uint64_t _internal_timestamp(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_timestamp() const;
  void _internal_add_timestamp(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_timestamp();
  public:
  uint64_t timestamp(int index) const;
  void set_timestamp(int index, uint64_t value);
  void add_timestamp(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_timestamp();

  // required .SessionProtos.ReceiptMessage.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::SessionProtos::ReceiptMessage_Type type() const;
  void set_type(::SessionProtos::ReceiptMessage_Type value);
  private:
  ::SessionProtos::ReceiptMessage_Type _internal_type() const;
  void _internal_set_type(::SessionProtos::ReceiptMessage_Type value);
  public:

  // @@protoc_insertion_point(class_scope:SessionProtos.ReceiptMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > timestamp_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SessionProtos_2eproto;
};
// -------------------------------------------------------------------

class AttachmentPointer final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SessionProtos.AttachmentPointer) */ {
 public:
  inline AttachmentPointer() : AttachmentPointer(nullptr) {}
  ~AttachmentPointer() override;
  explicit PROTOBUF_CONSTEXPR AttachmentPointer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AttachmentPointer(const AttachmentPointer& from);
  AttachmentPointer(AttachmentPointer&& from) noexcept
    : AttachmentPointer() {
    *this = ::std::move(from);
  }

  inline AttachmentPointer& operator=(const AttachmentPointer& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttachmentPointer& operator=(AttachmentPointer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AttachmentPointer& default_instance() {
    return *internal_default_instance();
  }
  static inline const AttachmentPointer* internal_default_instance() {
    return reinterpret_cast<const AttachmentPointer*>(
               &_AttachmentPointer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(AttachmentPointer& a, AttachmentPointer& b) {
    a.Swap(&b);
  }
  inline void Swap(AttachmentPointer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttachmentPointer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttachmentPointer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AttachmentPointer>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AttachmentPointer& from);
  void MergeFrom(const AttachmentPointer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AttachmentPointer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SessionProtos.AttachmentPointer";
  }
  protected:
  explicit AttachmentPointer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AttachmentPointer_Flags Flags;
  static constexpr Flags VOICE_MESSAGE =
    AttachmentPointer_Flags_VOICE_MESSAGE;
  static inline bool Flags_IsValid(int value) {
    return AttachmentPointer_Flags_IsValid(value);
  }
  static constexpr Flags Flags_MIN =
    AttachmentPointer_Flags_Flags_MIN;
  static constexpr Flags Flags_MAX =
    AttachmentPointer_Flags_Flags_MAX;
  static constexpr int Flags_ARRAYSIZE =
    AttachmentPointer_Flags_Flags_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Flags_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Flags>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Flags_Name.");
    return AttachmentPointer_Flags_Name(enum_t_value);
  }
  static inline bool Flags_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Flags* value) {
    return AttachmentPointer_Flags_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kContentTypeFieldNumber = 2,
    kKeyFieldNumber = 3,
    kThumbnailFieldNumber = 5,
    kDigestFieldNumber = 6,
    kFileNameFieldNumber = 7,
    kCaptionFieldNumber = 11,
    kUrlFieldNumber = 101,
    kIdFieldNumber = 1,
    kSizeFieldNumber = 4,
    kFlagsFieldNumber = 8,
    kWidthFieldNumber = 9,
    kHeightFieldNumber = 10,
  };
  // optional string contentType = 2;
  bool has_contenttype() const;
  private:
  bool _internal_has_contenttype() const;
  public:
  void clear_contenttype();
  const std::string& contenttype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contenttype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contenttype();
  PROTOBUF_NODISCARD std::string* release_contenttype();
  void set_allocated_contenttype(std::string* contenttype);
  private:
  const std::string& _internal_contenttype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contenttype(const std::string& value);
  std::string* _internal_mutable_contenttype();
  public:

  // optional bytes key = 3;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional bytes thumbnail = 5;
  bool has_thumbnail() const;
  private:
  bool _internal_has_thumbnail() const;
  public:
  void clear_thumbnail();
  const std::string& thumbnail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnail();
  PROTOBUF_NODISCARD std::string* release_thumbnail();
  void set_allocated_thumbnail(std::string* thumbnail);
  private:
  const std::string& _internal_thumbnail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnail(const std::string& value);
  std::string* _internal_mutable_thumbnail();
  public:

  // optional bytes digest = 6;
  bool has_digest() const;
  private:
  bool _internal_has_digest() const;
  public:
  void clear_digest();
  const std::string& digest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_digest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_digest();
  PROTOBUF_NODISCARD std::string* release_digest();
  void set_allocated_digest(std::string* digest);
  private:
  const std::string& _internal_digest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_digest(const std::string& value);
  std::string* _internal_mutable_digest();
  public:

  // optional string fileName = 7;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // optional string caption = 11;
  bool has_caption() const;
  private:
  bool _internal_has_caption() const;
  public:
  void clear_caption();
  const std::string& caption() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_caption(ArgT0&& arg0, ArgT... args);
  std::string* mutable_caption();
  PROTOBUF_NODISCARD std::string* release_caption();
  void set_allocated_caption(std::string* caption);
  private:
  const std::string& _internal_caption() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_caption(const std::string& value);
  std::string* _internal_mutable_caption();
  public:

  // optional string url = 101;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // required fixed64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // optional uint32 size = 4;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // optional uint32 flags = 8;
  bool has_flags() const;
  private:
  bool _internal_has_flags() const;
  public:
  void clear_flags();
  uint32_t flags() const;
  void set_flags(uint32_t value);
  private:
  uint32_t _internal_flags() const;
  void _internal_set_flags(uint32_t value);
  public:

  // optional uint32 width = 9;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // optional uint32 height = 10;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SessionProtos.AttachmentPointer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contenttype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnail_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr digest_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caption_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    uint64_t id_;
    uint32_t size_;
    uint32_t flags_;
    uint32_t width_;
    uint32_t height_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SessionProtos_2eproto;
};
// -------------------------------------------------------------------

class SharedConfigMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SessionProtos.SharedConfigMessage) */ {
 public:
  inline SharedConfigMessage() : SharedConfigMessage(nullptr) {}
  ~SharedConfigMessage() override;
  explicit PROTOBUF_CONSTEXPR SharedConfigMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SharedConfigMessage(const SharedConfigMessage& from);
  SharedConfigMessage(SharedConfigMessage&& from) noexcept
    : SharedConfigMessage() {
    *this = ::std::move(from);
  }

  inline SharedConfigMessage& operator=(const SharedConfigMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SharedConfigMessage& operator=(SharedConfigMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SharedConfigMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SharedConfigMessage* internal_default_instance() {
    return reinterpret_cast<const SharedConfigMessage*>(
               &_SharedConfigMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SharedConfigMessage& a, SharedConfigMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SharedConfigMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SharedConfigMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SharedConfigMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SharedConfigMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SharedConfigMessage& from);
  void MergeFrom(const SharedConfigMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SharedConfigMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SessionProtos.SharedConfigMessage";
  }
  protected:
  explicit SharedConfigMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SharedConfigMessage_Kind Kind;
  static constexpr Kind USER_PROFILE =
    SharedConfigMessage_Kind_USER_PROFILE;
  static constexpr Kind CONTACTS =
    SharedConfigMessage_Kind_CONTACTS;
  static constexpr Kind CONVO_INFO_VOLATILE =
    SharedConfigMessage_Kind_CONVO_INFO_VOLATILE;
  static constexpr Kind USER_GROUPS =
    SharedConfigMessage_Kind_USER_GROUPS;
  static inline bool Kind_IsValid(int value) {
    return SharedConfigMessage_Kind_IsValid(value);
  }
  static constexpr Kind Kind_MIN =
    SharedConfigMessage_Kind_Kind_MIN;
  static constexpr Kind Kind_MAX =
    SharedConfigMessage_Kind_Kind_MAX;
  static constexpr int Kind_ARRAYSIZE =
    SharedConfigMessage_Kind_Kind_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Kind_Name.");
    return SharedConfigMessage_Kind_Name(enum_t_value);
  }
  static inline bool Kind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Kind* value) {
    return SharedConfigMessage_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kSeqnoFieldNumber = 2,
    kKindFieldNumber = 1,
  };
  // required bytes data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // required int64 seqno = 2;
  bool has_seqno() const;
  private:
  bool _internal_has_seqno() const;
  public:
  void clear_seqno();
  int64_t seqno() const;
  void set_seqno(int64_t value);
  private:
  int64_t _internal_seqno() const;
  void _internal_set_seqno(int64_t value);
  public:

  // required .SessionProtos.SharedConfigMessage.Kind kind = 1;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  ::SessionProtos::SharedConfigMessage_Kind kind() const;
  void set_kind(::SessionProtos::SharedConfigMessage_Kind value);
  private:
  ::SessionProtos::SharedConfigMessage_Kind _internal_kind() const;
  void _internal_set_kind(::SessionProtos::SharedConfigMessage_Kind value);
  public:

  // @@protoc_insertion_point(class_scope:SessionProtos.SharedConfigMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int64_t seqno_;
    int kind_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SessionProtos_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Envelope

// required .SessionProtos.Envelope.Type type = 1;
inline bool Envelope::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Envelope::has_type() const {
  return _internal_has_type();
}
inline void Envelope::clear_type() {
  _impl_.type_ = 6;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::SessionProtos::Envelope_Type Envelope::_internal_type() const {
  return static_cast< ::SessionProtos::Envelope_Type >(_impl_.type_);
}
inline ::SessionProtos::Envelope_Type Envelope::type() const {
  // @@protoc_insertion_point(field_get:SessionProtos.Envelope.type)
  return _internal_type();
}
inline void Envelope::_internal_set_type(::SessionProtos::Envelope_Type value) {
  assert(::SessionProtos::Envelope_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.type_ = value;
}
inline void Envelope::set_type(::SessionProtos::Envelope_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:SessionProtos.Envelope.type)
}

// optional string source = 2;
inline bool Envelope::_internal_has_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Envelope::has_source() const {
  return _internal_has_source();
}
inline void Envelope::clear_source() {
  _impl_.source_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Envelope::source() const {
  // @@protoc_insertion_point(field_get:SessionProtos.Envelope.source)
  return _internal_source();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Envelope::set_source(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.source_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.Envelope.source)
}
inline std::string* Envelope::mutable_source() {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:SessionProtos.Envelope.source)
  return _s;
}
inline const std::string& Envelope::_internal_source() const {
  return _impl_.source_.Get();
}
inline void Envelope::_internal_set_source(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.source_.Set(value, GetArenaForAllocation());
}
inline std::string* Envelope::_internal_mutable_source() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.source_.Mutable(GetArenaForAllocation());
}
inline std::string* Envelope::release_source() {
  // @@protoc_insertion_point(field_release:SessionProtos.Envelope.source)
  if (!_internal_has_source()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.source_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_.IsDefault()) {
    _impl_.source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Envelope::set_allocated_source(std::string* source) {
  if (source != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.source_.SetAllocated(source, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_.IsDefault()) {
    _impl_.source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.Envelope.source)
}

// optional uint32 sourceDevice = 7;
inline bool Envelope::_internal_has_sourcedevice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Envelope::has_sourcedevice() const {
  return _internal_has_sourcedevice();
}
inline void Envelope::clear_sourcedevice() {
  _impl_.sourcedevice_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t Envelope::_internal_sourcedevice() const {
  return _impl_.sourcedevice_;
}
inline uint32_t Envelope::sourcedevice() const {
  // @@protoc_insertion_point(field_get:SessionProtos.Envelope.sourceDevice)
  return _internal_sourcedevice();
}
inline void Envelope::_internal_set_sourcedevice(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.sourcedevice_ = value;
}
inline void Envelope::set_sourcedevice(uint32_t value) {
  _internal_set_sourcedevice(value);
  // @@protoc_insertion_point(field_set:SessionProtos.Envelope.sourceDevice)
}

// required uint64 timestamp = 5;
inline bool Envelope::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Envelope::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void Envelope::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t Envelope::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t Envelope::timestamp() const {
  // @@protoc_insertion_point(field_get:SessionProtos.Envelope.timestamp)
  return _internal_timestamp();
}
inline void Envelope::_internal_set_timestamp(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.timestamp_ = value;
}
inline void Envelope::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:SessionProtos.Envelope.timestamp)
}

// optional bytes content = 8;
inline bool Envelope::_internal_has_content() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Envelope::has_content() const {
  return _internal_has_content();
}
inline void Envelope::clear_content() {
  _impl_.content_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Envelope::content() const {
  // @@protoc_insertion_point(field_get:SessionProtos.Envelope.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Envelope::set_content(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.Envelope.content)
}
inline std::string* Envelope::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:SessionProtos.Envelope.content)
  return _s;
}
inline const std::string& Envelope::_internal_content() const {
  return _impl_.content_.Get();
}
inline void Envelope::_internal_set_content(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* Envelope::_internal_mutable_content() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* Envelope::release_content() {
  // @@protoc_insertion_point(field_release:SessionProtos.Envelope.content)
  if (!_internal_has_content()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.content_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Envelope::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.Envelope.content)
}

// optional uint64 serverTimestamp = 10;
inline bool Envelope::_internal_has_servertimestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Envelope::has_servertimestamp() const {
  return _internal_has_servertimestamp();
}
inline void Envelope::clear_servertimestamp() {
  _impl_.servertimestamp_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t Envelope::_internal_servertimestamp() const {
  return _impl_.servertimestamp_;
}
inline uint64_t Envelope::servertimestamp() const {
  // @@protoc_insertion_point(field_get:SessionProtos.Envelope.serverTimestamp)
  return _internal_servertimestamp();
}
inline void Envelope::_internal_set_servertimestamp(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.servertimestamp_ = value;
}
inline void Envelope::set_servertimestamp(uint64_t value) {
  _internal_set_servertimestamp(value);
  // @@protoc_insertion_point(field_set:SessionProtos.Envelope.serverTimestamp)
}

// -------------------------------------------------------------------

// TypingMessage

// required uint64 timestamp = 1;
inline bool TypingMessage::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TypingMessage::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void TypingMessage::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t TypingMessage::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t TypingMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:SessionProtos.TypingMessage.timestamp)
  return _internal_timestamp();
}
inline void TypingMessage::_internal_set_timestamp(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ = value;
}
inline void TypingMessage::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:SessionProtos.TypingMessage.timestamp)
}

// required .SessionProtos.TypingMessage.Action action = 2;
inline bool TypingMessage::_internal_has_action() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TypingMessage::has_action() const {
  return _internal_has_action();
}
inline void TypingMessage::clear_action() {
  _impl_.action_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::SessionProtos::TypingMessage_Action TypingMessage::_internal_action() const {
  return static_cast< ::SessionProtos::TypingMessage_Action >(_impl_.action_);
}
inline ::SessionProtos::TypingMessage_Action TypingMessage::action() const {
  // @@protoc_insertion_point(field_get:SessionProtos.TypingMessage.action)
  return _internal_action();
}
inline void TypingMessage::_internal_set_action(::SessionProtos::TypingMessage_Action value) {
  assert(::SessionProtos::TypingMessage_Action_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.action_ = value;
}
inline void TypingMessage::set_action(::SessionProtos::TypingMessage_Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:SessionProtos.TypingMessage.action)
}

// -------------------------------------------------------------------

// UnsendRequest

// required uint64 timestamp = 1;
inline bool UnsendRequest::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UnsendRequest::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void UnsendRequest::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t UnsendRequest::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t UnsendRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:SessionProtos.UnsendRequest.timestamp)
  return _internal_timestamp();
}
inline void UnsendRequest::_internal_set_timestamp(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.timestamp_ = value;
}
inline void UnsendRequest::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:SessionProtos.UnsendRequest.timestamp)
}

// required string author = 2;
inline bool UnsendRequest::_internal_has_author() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnsendRequest::has_author() const {
  return _internal_has_author();
}
inline void UnsendRequest::clear_author() {
  _impl_.author_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnsendRequest::author() const {
  // @@protoc_insertion_point(field_get:SessionProtos.UnsendRequest.author)
  return _internal_author();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnsendRequest::set_author(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.author_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.UnsendRequest.author)
}
inline std::string* UnsendRequest::mutable_author() {
  std::string* _s = _internal_mutable_author();
  // @@protoc_insertion_point(field_mutable:SessionProtos.UnsendRequest.author)
  return _s;
}
inline const std::string& UnsendRequest::_internal_author() const {
  return _impl_.author_.Get();
}
inline void UnsendRequest::_internal_set_author(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.author_.Set(value, GetArenaForAllocation());
}
inline std::string* UnsendRequest::_internal_mutable_author() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.author_.Mutable(GetArenaForAllocation());
}
inline std::string* UnsendRequest::release_author() {
  // @@protoc_insertion_point(field_release:SessionProtos.UnsendRequest.author)
  if (!_internal_has_author()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.author_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.author_.IsDefault()) {
    _impl_.author_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UnsendRequest::set_allocated_author(std::string* author) {
  if (author != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.author_.SetAllocated(author, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.author_.IsDefault()) {
    _impl_.author_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.UnsendRequest.author)
}

// -------------------------------------------------------------------

// MessageRequestResponse

// required bool isApproved = 1;
inline bool MessageRequestResponse::_internal_has_isapproved() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MessageRequestResponse::has_isapproved() const {
  return _internal_has_isapproved();
}
inline void MessageRequestResponse::clear_isapproved() {
  _impl_.isapproved_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool MessageRequestResponse::_internal_isapproved() const {
  return _impl_.isapproved_;
}
inline bool MessageRequestResponse::isapproved() const {
  // @@protoc_insertion_point(field_get:SessionProtos.MessageRequestResponse.isApproved)
  return _internal_isapproved();
}
inline void MessageRequestResponse::_internal_set_isapproved(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.isapproved_ = value;
}
inline void MessageRequestResponse::set_isapproved(bool value) {
  _internal_set_isapproved(value);
  // @@protoc_insertion_point(field_set:SessionProtos.MessageRequestResponse.isApproved)
}

// optional bytes profileKey = 2;
inline bool MessageRequestResponse::_internal_has_profilekey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MessageRequestResponse::has_profilekey() const {
  return _internal_has_profilekey();
}
inline void MessageRequestResponse::clear_profilekey() {
  _impl_.profilekey_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MessageRequestResponse::profilekey() const {
  // @@protoc_insertion_point(field_get:SessionProtos.MessageRequestResponse.profileKey)
  return _internal_profilekey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageRequestResponse::set_profilekey(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.profilekey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.MessageRequestResponse.profileKey)
}
inline std::string* MessageRequestResponse::mutable_profilekey() {
  std::string* _s = _internal_mutable_profilekey();
  // @@protoc_insertion_point(field_mutable:SessionProtos.MessageRequestResponse.profileKey)
  return _s;
}
inline const std::string& MessageRequestResponse::_internal_profilekey() const {
  return _impl_.profilekey_.Get();
}
inline void MessageRequestResponse::_internal_set_profilekey(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.profilekey_.Set(value, GetArenaForAllocation());
}
inline std::string* MessageRequestResponse::_internal_mutable_profilekey() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.profilekey_.Mutable(GetArenaForAllocation());
}
inline std::string* MessageRequestResponse::release_profilekey() {
  // @@protoc_insertion_point(field_release:SessionProtos.MessageRequestResponse.profileKey)
  if (!_internal_has_profilekey()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.profilekey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.profilekey_.IsDefault()) {
    _impl_.profilekey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MessageRequestResponse::set_allocated_profilekey(std::string* profilekey) {
  if (profilekey != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.profilekey_.SetAllocated(profilekey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.profilekey_.IsDefault()) {
    _impl_.profilekey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.MessageRequestResponse.profileKey)
}

// optional .SessionProtos.LokiProfile profile = 3;
inline bool MessageRequestResponse::_internal_has_profile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.profile_ != nullptr);
  return value;
}
inline bool MessageRequestResponse::has_profile() const {
  return _internal_has_profile();
}
inline void MessageRequestResponse::clear_profile() {
  if (_impl_.profile_ != nullptr) _impl_.profile_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::SessionProtos::LokiProfile& MessageRequestResponse::_internal_profile() const {
  const ::SessionProtos::LokiProfile* p = _impl_.profile_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionProtos::LokiProfile&>(
      ::SessionProtos::_LokiProfile_default_instance_);
}
inline const ::SessionProtos::LokiProfile& MessageRequestResponse::profile() const {
  // @@protoc_insertion_point(field_get:SessionProtos.MessageRequestResponse.profile)
  return _internal_profile();
}
inline void MessageRequestResponse::unsafe_arena_set_allocated_profile(
    ::SessionProtos::LokiProfile* profile) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.profile_);
  }
  _impl_.profile_ = profile;
  if (profile) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SessionProtos.MessageRequestResponse.profile)
}
inline ::SessionProtos::LokiProfile* MessageRequestResponse::release_profile() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SessionProtos::LokiProfile* temp = _impl_.profile_;
  _impl_.profile_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SessionProtos::LokiProfile* MessageRequestResponse::unsafe_arena_release_profile() {
  // @@protoc_insertion_point(field_release:SessionProtos.MessageRequestResponse.profile)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SessionProtos::LokiProfile* temp = _impl_.profile_;
  _impl_.profile_ = nullptr;
  return temp;
}
inline ::SessionProtos::LokiProfile* MessageRequestResponse::_internal_mutable_profile() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.profile_ == nullptr) {
    auto* p = CreateMaybeMessage<::SessionProtos::LokiProfile>(GetArenaForAllocation());
    _impl_.profile_ = p;
  }
  return _impl_.profile_;
}
inline ::SessionProtos::LokiProfile* MessageRequestResponse::mutable_profile() {
  ::SessionProtos::LokiProfile* _msg = _internal_mutable_profile();
  // @@protoc_insertion_point(field_mutable:SessionProtos.MessageRequestResponse.profile)
  return _msg;
}
inline void MessageRequestResponse::set_allocated_profile(::SessionProtos::LokiProfile* profile) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.profile_;
  }
  if (profile) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(profile);
    if (message_arena != submessage_arena) {
      profile = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, profile, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.profile_ = profile;
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.MessageRequestResponse.profile)
}

// -------------------------------------------------------------------

// Content

// optional .SessionProtos.DataMessage dataMessage = 1;
inline bool Content::_internal_has_datamessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.datamessage_ != nullptr);
  return value;
}
inline bool Content::has_datamessage() const {
  return _internal_has_datamessage();
}
inline void Content::clear_datamessage() {
  if (_impl_.datamessage_ != nullptr) _impl_.datamessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::SessionProtos::DataMessage& Content::_internal_datamessage() const {
  const ::SessionProtos::DataMessage* p = _impl_.datamessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionProtos::DataMessage&>(
      ::SessionProtos::_DataMessage_default_instance_);
}
inline const ::SessionProtos::DataMessage& Content::datamessage() const {
  // @@protoc_insertion_point(field_get:SessionProtos.Content.dataMessage)
  return _internal_datamessage();
}
inline void Content::unsafe_arena_set_allocated_datamessage(
    ::SessionProtos::DataMessage* datamessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.datamessage_);
  }
  _impl_.datamessage_ = datamessage;
  if (datamessage) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SessionProtos.Content.dataMessage)
}
inline ::SessionProtos::DataMessage* Content::release_datamessage() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionProtos::DataMessage* temp = _impl_.datamessage_;
  _impl_.datamessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SessionProtos::DataMessage* Content::unsafe_arena_release_datamessage() {
  // @@protoc_insertion_point(field_release:SessionProtos.Content.dataMessage)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionProtos::DataMessage* temp = _impl_.datamessage_;
  _impl_.datamessage_ = nullptr;
  return temp;
}
inline ::SessionProtos::DataMessage* Content::_internal_mutable_datamessage() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.datamessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::SessionProtos::DataMessage>(GetArenaForAllocation());
    _impl_.datamessage_ = p;
  }
  return _impl_.datamessage_;
}
inline ::SessionProtos::DataMessage* Content::mutable_datamessage() {
  ::SessionProtos::DataMessage* _msg = _internal_mutable_datamessage();
  // @@protoc_insertion_point(field_mutable:SessionProtos.Content.dataMessage)
  return _msg;
}
inline void Content::set_allocated_datamessage(::SessionProtos::DataMessage* datamessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.datamessage_;
  }
  if (datamessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(datamessage);
    if (message_arena != submessage_arena) {
      datamessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, datamessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.datamessage_ = datamessage;
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.Content.dataMessage)
}

// optional .SessionProtos.CallMessage callMessage = 3;
inline bool Content::_internal_has_callmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.callmessage_ != nullptr);
  return value;
}
inline bool Content::has_callmessage() const {
  return _internal_has_callmessage();
}
inline void Content::clear_callmessage() {
  if (_impl_.callmessage_ != nullptr) _impl_.callmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::SessionProtos::CallMessage& Content::_internal_callmessage() const {
  const ::SessionProtos::CallMessage* p = _impl_.callmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionProtos::CallMessage&>(
      ::SessionProtos::_CallMessage_default_instance_);
}
inline const ::SessionProtos::CallMessage& Content::callmessage() const {
  // @@protoc_insertion_point(field_get:SessionProtos.Content.callMessage)
  return _internal_callmessage();
}
inline void Content::unsafe_arena_set_allocated_callmessage(
    ::SessionProtos::CallMessage* callmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.callmessage_);
  }
  _impl_.callmessage_ = callmessage;
  if (callmessage) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SessionProtos.Content.callMessage)
}
inline ::SessionProtos::CallMessage* Content::release_callmessage() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SessionProtos::CallMessage* temp = _impl_.callmessage_;
  _impl_.callmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SessionProtos::CallMessage* Content::unsafe_arena_release_callmessage() {
  // @@protoc_insertion_point(field_release:SessionProtos.Content.callMessage)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SessionProtos::CallMessage* temp = _impl_.callmessage_;
  _impl_.callmessage_ = nullptr;
  return temp;
}
inline ::SessionProtos::CallMessage* Content::_internal_mutable_callmessage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.callmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::SessionProtos::CallMessage>(GetArenaForAllocation());
    _impl_.callmessage_ = p;
  }
  return _impl_.callmessage_;
}
inline ::SessionProtos::CallMessage* Content::mutable_callmessage() {
  ::SessionProtos::CallMessage* _msg = _internal_mutable_callmessage();
  // @@protoc_insertion_point(field_mutable:SessionProtos.Content.callMessage)
  return _msg;
}
inline void Content::set_allocated_callmessage(::SessionProtos::CallMessage* callmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.callmessage_;
  }
  if (callmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(callmessage);
    if (message_arena != submessage_arena) {
      callmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, callmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.callmessage_ = callmessage;
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.Content.callMessage)
}

// optional .SessionProtos.ReceiptMessage receiptMessage = 5;
inline bool Content::_internal_has_receiptmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.receiptmessage_ != nullptr);
  return value;
}
inline bool Content::has_receiptmessage() const {
  return _internal_has_receiptmessage();
}
inline void Content::clear_receiptmessage() {
  if (_impl_.receiptmessage_ != nullptr) _impl_.receiptmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::SessionProtos::ReceiptMessage& Content::_internal_receiptmessage() const {
  const ::SessionProtos::ReceiptMessage* p = _impl_.receiptmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionProtos::ReceiptMessage&>(
      ::SessionProtos::_ReceiptMessage_default_instance_);
}
inline const ::SessionProtos::ReceiptMessage& Content::receiptmessage() const {
  // @@protoc_insertion_point(field_get:SessionProtos.Content.receiptMessage)
  return _internal_receiptmessage();
}
inline void Content::unsafe_arena_set_allocated_receiptmessage(
    ::SessionProtos::ReceiptMessage* receiptmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.receiptmessage_);
  }
  _impl_.receiptmessage_ = receiptmessage;
  if (receiptmessage) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SessionProtos.Content.receiptMessage)
}
inline ::SessionProtos::ReceiptMessage* Content::release_receiptmessage() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::SessionProtos::ReceiptMessage* temp = _impl_.receiptmessage_;
  _impl_.receiptmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SessionProtos::ReceiptMessage* Content::unsafe_arena_release_receiptmessage() {
  // @@protoc_insertion_point(field_release:SessionProtos.Content.receiptMessage)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::SessionProtos::ReceiptMessage* temp = _impl_.receiptmessage_;
  _impl_.receiptmessage_ = nullptr;
  return temp;
}
inline ::SessionProtos::ReceiptMessage* Content::_internal_mutable_receiptmessage() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.receiptmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::SessionProtos::ReceiptMessage>(GetArenaForAllocation());
    _impl_.receiptmessage_ = p;
  }
  return _impl_.receiptmessage_;
}
inline ::SessionProtos::ReceiptMessage* Content::mutable_receiptmessage() {
  ::SessionProtos::ReceiptMessage* _msg = _internal_mutable_receiptmessage();
  // @@protoc_insertion_point(field_mutable:SessionProtos.Content.receiptMessage)
  return _msg;
}
inline void Content::set_allocated_receiptmessage(::SessionProtos::ReceiptMessage* receiptmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.receiptmessage_;
  }
  if (receiptmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(receiptmessage);
    if (message_arena != submessage_arena) {
      receiptmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, receiptmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.receiptmessage_ = receiptmessage;
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.Content.receiptMessage)
}

// optional .SessionProtos.TypingMessage typingMessage = 6;
inline bool Content::_internal_has_typingmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.typingmessage_ != nullptr);
  return value;
}
inline bool Content::has_typingmessage() const {
  return _internal_has_typingmessage();
}
inline void Content::clear_typingmessage() {
  if (_impl_.typingmessage_ != nullptr) _impl_.typingmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::SessionProtos::TypingMessage& Content::_internal_typingmessage() const {
  const ::SessionProtos::TypingMessage* p = _impl_.typingmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionProtos::TypingMessage&>(
      ::SessionProtos::_TypingMessage_default_instance_);
}
inline const ::SessionProtos::TypingMessage& Content::typingmessage() const {
  // @@protoc_insertion_point(field_get:SessionProtos.Content.typingMessage)
  return _internal_typingmessage();
}
inline void Content::unsafe_arena_set_allocated_typingmessage(
    ::SessionProtos::TypingMessage* typingmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.typingmessage_);
  }
  _impl_.typingmessage_ = typingmessage;
  if (typingmessage) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SessionProtos.Content.typingMessage)
}
inline ::SessionProtos::TypingMessage* Content::release_typingmessage() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::SessionProtos::TypingMessage* temp = _impl_.typingmessage_;
  _impl_.typingmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SessionProtos::TypingMessage* Content::unsafe_arena_release_typingmessage() {
  // @@protoc_insertion_point(field_release:SessionProtos.Content.typingMessage)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::SessionProtos::TypingMessage* temp = _impl_.typingmessage_;
  _impl_.typingmessage_ = nullptr;
  return temp;
}
inline ::SessionProtos::TypingMessage* Content::_internal_mutable_typingmessage() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.typingmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::SessionProtos::TypingMessage>(GetArenaForAllocation());
    _impl_.typingmessage_ = p;
  }
  return _impl_.typingmessage_;
}
inline ::SessionProtos::TypingMessage* Content::mutable_typingmessage() {
  ::SessionProtos::TypingMessage* _msg = _internal_mutable_typingmessage();
  // @@protoc_insertion_point(field_mutable:SessionProtos.Content.typingMessage)
  return _msg;
}
inline void Content::set_allocated_typingmessage(::SessionProtos::TypingMessage* typingmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.typingmessage_;
  }
  if (typingmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(typingmessage);
    if (message_arena != submessage_arena) {
      typingmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, typingmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.typingmessage_ = typingmessage;
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.Content.typingMessage)
}

// optional .SessionProtos.ConfigurationMessage configurationMessage = 7;
inline bool Content::_internal_has_configurationmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.configurationmessage_ != nullptr);
  return value;
}
inline bool Content::has_configurationmessage() const {
  return _internal_has_configurationmessage();
}
inline void Content::clear_configurationmessage() {
  if (_impl_.configurationmessage_ != nullptr) _impl_.configurationmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::SessionProtos::ConfigurationMessage& Content::_internal_configurationmessage() const {
  const ::SessionProtos::ConfigurationMessage* p = _impl_.configurationmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionProtos::ConfigurationMessage&>(
      ::SessionProtos::_ConfigurationMessage_default_instance_);
}
inline const ::SessionProtos::ConfigurationMessage& Content::configurationmessage() const {
  // @@protoc_insertion_point(field_get:SessionProtos.Content.configurationMessage)
  return _internal_configurationmessage();
}
inline void Content::unsafe_arena_set_allocated_configurationmessage(
    ::SessionProtos::ConfigurationMessage* configurationmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.configurationmessage_);
  }
  _impl_.configurationmessage_ = configurationmessage;
  if (configurationmessage) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SessionProtos.Content.configurationMessage)
}
inline ::SessionProtos::ConfigurationMessage* Content::release_configurationmessage() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::SessionProtos::ConfigurationMessage* temp = _impl_.configurationmessage_;
  _impl_.configurationmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SessionProtos::ConfigurationMessage* Content::unsafe_arena_release_configurationmessage() {
  // @@protoc_insertion_point(field_release:SessionProtos.Content.configurationMessage)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::SessionProtos::ConfigurationMessage* temp = _impl_.configurationmessage_;
  _impl_.configurationmessage_ = nullptr;
  return temp;
}
inline ::SessionProtos::ConfigurationMessage* Content::_internal_mutable_configurationmessage() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.configurationmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::SessionProtos::ConfigurationMessage>(GetArenaForAllocation());
    _impl_.configurationmessage_ = p;
  }
  return _impl_.configurationmessage_;
}
inline ::SessionProtos::ConfigurationMessage* Content::mutable_configurationmessage() {
  ::SessionProtos::ConfigurationMessage* _msg = _internal_mutable_configurationmessage();
  // @@protoc_insertion_point(field_mutable:SessionProtos.Content.configurationMessage)
  return _msg;
}
inline void Content::set_allocated_configurationmessage(::SessionProtos::ConfigurationMessage* configurationmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.configurationmessage_;
  }
  if (configurationmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(configurationmessage);
    if (message_arena != submessage_arena) {
      configurationmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, configurationmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.configurationmessage_ = configurationmessage;
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.Content.configurationMessage)
}

// optional .SessionProtos.DataExtractionNotification dataExtractionNotification = 8;
inline bool Content::_internal_has_dataextractionnotification() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dataextractionnotification_ != nullptr);
  return value;
}
inline bool Content::has_dataextractionnotification() const {
  return _internal_has_dataextractionnotification();
}
inline void Content::clear_dataextractionnotification() {
  if (_impl_.dataextractionnotification_ != nullptr) _impl_.dataextractionnotification_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::SessionProtos::DataExtractionNotification& Content::_internal_dataextractionnotification() const {
  const ::SessionProtos::DataExtractionNotification* p = _impl_.dataextractionnotification_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionProtos::DataExtractionNotification&>(
      ::SessionProtos::_DataExtractionNotification_default_instance_);
}
inline const ::SessionProtos::DataExtractionNotification& Content::dataextractionnotification() const {
  // @@protoc_insertion_point(field_get:SessionProtos.Content.dataExtractionNotification)
  return _internal_dataextractionnotification();
}
inline void Content::unsafe_arena_set_allocated_dataextractionnotification(
    ::SessionProtos::DataExtractionNotification* dataextractionnotification) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dataextractionnotification_);
  }
  _impl_.dataextractionnotification_ = dataextractionnotification;
  if (dataextractionnotification) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SessionProtos.Content.dataExtractionNotification)
}
inline ::SessionProtos::DataExtractionNotification* Content::release_dataextractionnotification() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::SessionProtos::DataExtractionNotification* temp = _impl_.dataextractionnotification_;
  _impl_.dataextractionnotification_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SessionProtos::DataExtractionNotification* Content::unsafe_arena_release_dataextractionnotification() {
  // @@protoc_insertion_point(field_release:SessionProtos.Content.dataExtractionNotification)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::SessionProtos::DataExtractionNotification* temp = _impl_.dataextractionnotification_;
  _impl_.dataextractionnotification_ = nullptr;
  return temp;
}
inline ::SessionProtos::DataExtractionNotification* Content::_internal_mutable_dataextractionnotification() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.dataextractionnotification_ == nullptr) {
    auto* p = CreateMaybeMessage<::SessionProtos::DataExtractionNotification>(GetArenaForAllocation());
    _impl_.dataextractionnotification_ = p;
  }
  return _impl_.dataextractionnotification_;
}
inline ::SessionProtos::DataExtractionNotification* Content::mutable_dataextractionnotification() {
  ::SessionProtos::DataExtractionNotification* _msg = _internal_mutable_dataextractionnotification();
  // @@protoc_insertion_point(field_mutable:SessionProtos.Content.dataExtractionNotification)
  return _msg;
}
inline void Content::set_allocated_dataextractionnotification(::SessionProtos::DataExtractionNotification* dataextractionnotification) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dataextractionnotification_;
  }
  if (dataextractionnotification) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dataextractionnotification);
    if (message_arena != submessage_arena) {
      dataextractionnotification = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dataextractionnotification, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.dataextractionnotification_ = dataextractionnotification;
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.Content.dataExtractionNotification)
}

// optional .SessionProtos.UnsendRequest unsendRequest = 9;
inline bool Content::_internal_has_unsendrequest() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.unsendrequest_ != nullptr);
  return value;
}
inline bool Content::has_unsendrequest() const {
  return _internal_has_unsendrequest();
}
inline void Content::clear_unsendrequest() {
  if (_impl_.unsendrequest_ != nullptr) _impl_.unsendrequest_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::SessionProtos::UnsendRequest& Content::_internal_unsendrequest() const {
  const ::SessionProtos::UnsendRequest* p = _impl_.unsendrequest_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionProtos::UnsendRequest&>(
      ::SessionProtos::_UnsendRequest_default_instance_);
}
inline const ::SessionProtos::UnsendRequest& Content::unsendrequest() const {
  // @@protoc_insertion_point(field_get:SessionProtos.Content.unsendRequest)
  return _internal_unsendrequest();
}
inline void Content::unsafe_arena_set_allocated_unsendrequest(
    ::SessionProtos::UnsendRequest* unsendrequest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unsendrequest_);
  }
  _impl_.unsendrequest_ = unsendrequest;
  if (unsendrequest) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SessionProtos.Content.unsendRequest)
}
inline ::SessionProtos::UnsendRequest* Content::release_unsendrequest() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::SessionProtos::UnsendRequest* temp = _impl_.unsendrequest_;
  _impl_.unsendrequest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SessionProtos::UnsendRequest* Content::unsafe_arena_release_unsendrequest() {
  // @@protoc_insertion_point(field_release:SessionProtos.Content.unsendRequest)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::SessionProtos::UnsendRequest* temp = _impl_.unsendrequest_;
  _impl_.unsendrequest_ = nullptr;
  return temp;
}
inline ::SessionProtos::UnsendRequest* Content::_internal_mutable_unsendrequest() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.unsendrequest_ == nullptr) {
    auto* p = CreateMaybeMessage<::SessionProtos::UnsendRequest>(GetArenaForAllocation());
    _impl_.unsendrequest_ = p;
  }
  return _impl_.unsendrequest_;
}
inline ::SessionProtos::UnsendRequest* Content::mutable_unsendrequest() {
  ::SessionProtos::UnsendRequest* _msg = _internal_mutable_unsendrequest();
  // @@protoc_insertion_point(field_mutable:SessionProtos.Content.unsendRequest)
  return _msg;
}
inline void Content::set_allocated_unsendrequest(::SessionProtos::UnsendRequest* unsendrequest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.unsendrequest_;
  }
  if (unsendrequest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(unsendrequest);
    if (message_arena != submessage_arena) {
      unsendrequest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unsendrequest, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.unsendrequest_ = unsendrequest;
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.Content.unsendRequest)
}

// optional .SessionProtos.MessageRequestResponse messageRequestResponse = 10;
inline bool Content::_internal_has_messagerequestresponse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.messagerequestresponse_ != nullptr);
  return value;
}
inline bool Content::has_messagerequestresponse() const {
  return _internal_has_messagerequestresponse();
}
inline void Content::clear_messagerequestresponse() {
  if (_impl_.messagerequestresponse_ != nullptr) _impl_.messagerequestresponse_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::SessionProtos::MessageRequestResponse& Content::_internal_messagerequestresponse() const {
  const ::SessionProtos::MessageRequestResponse* p = _impl_.messagerequestresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionProtos::MessageRequestResponse&>(
      ::SessionProtos::_MessageRequestResponse_default_instance_);
}
inline const ::SessionProtos::MessageRequestResponse& Content::messagerequestresponse() const {
  // @@protoc_insertion_point(field_get:SessionProtos.Content.messageRequestResponse)
  return _internal_messagerequestresponse();
}
inline void Content::unsafe_arena_set_allocated_messagerequestresponse(
    ::SessionProtos::MessageRequestResponse* messagerequestresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.messagerequestresponse_);
  }
  _impl_.messagerequestresponse_ = messagerequestresponse;
  if (messagerequestresponse) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SessionProtos.Content.messageRequestResponse)
}
inline ::SessionProtos::MessageRequestResponse* Content::release_messagerequestresponse() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::SessionProtos::MessageRequestResponse* temp = _impl_.messagerequestresponse_;
  _impl_.messagerequestresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SessionProtos::MessageRequestResponse* Content::unsafe_arena_release_messagerequestresponse() {
  // @@protoc_insertion_point(field_release:SessionProtos.Content.messageRequestResponse)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::SessionProtos::MessageRequestResponse* temp = _impl_.messagerequestresponse_;
  _impl_.messagerequestresponse_ = nullptr;
  return temp;
}
inline ::SessionProtos::MessageRequestResponse* Content::_internal_mutable_messagerequestresponse() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.messagerequestresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::SessionProtos::MessageRequestResponse>(GetArenaForAllocation());
    _impl_.messagerequestresponse_ = p;
  }
  return _impl_.messagerequestresponse_;
}
inline ::SessionProtos::MessageRequestResponse* Content::mutable_messagerequestresponse() {
  ::SessionProtos::MessageRequestResponse* _msg = _internal_mutable_messagerequestresponse();
  // @@protoc_insertion_point(field_mutable:SessionProtos.Content.messageRequestResponse)
  return _msg;
}
inline void Content::set_allocated_messagerequestresponse(::SessionProtos::MessageRequestResponse* messagerequestresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.messagerequestresponse_;
  }
  if (messagerequestresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(messagerequestresponse);
    if (message_arena != submessage_arena) {
      messagerequestresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, messagerequestresponse, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.messagerequestresponse_ = messagerequestresponse;
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.Content.messageRequestResponse)
}

// optional .SessionProtos.SharedConfigMessage sharedConfigMessage = 11;
inline bool Content::_internal_has_sharedconfigmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sharedconfigmessage_ != nullptr);
  return value;
}
inline bool Content::has_sharedconfigmessage() const {
  return _internal_has_sharedconfigmessage();
}
inline void Content::clear_sharedconfigmessage() {
  if (_impl_.sharedconfigmessage_ != nullptr) _impl_.sharedconfigmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::SessionProtos::SharedConfigMessage& Content::_internal_sharedconfigmessage() const {
  const ::SessionProtos::SharedConfigMessage* p = _impl_.sharedconfigmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionProtos::SharedConfigMessage&>(
      ::SessionProtos::_SharedConfigMessage_default_instance_);
}
inline const ::SessionProtos::SharedConfigMessage& Content::sharedconfigmessage() const {
  // @@protoc_insertion_point(field_get:SessionProtos.Content.sharedConfigMessage)
  return _internal_sharedconfigmessage();
}
inline void Content::unsafe_arena_set_allocated_sharedconfigmessage(
    ::SessionProtos::SharedConfigMessage* sharedconfigmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sharedconfigmessage_);
  }
  _impl_.sharedconfigmessage_ = sharedconfigmessage;
  if (sharedconfigmessage) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SessionProtos.Content.sharedConfigMessage)
}
inline ::SessionProtos::SharedConfigMessage* Content::release_sharedconfigmessage() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::SessionProtos::SharedConfigMessage* temp = _impl_.sharedconfigmessage_;
  _impl_.sharedconfigmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SessionProtos::SharedConfigMessage* Content::unsafe_arena_release_sharedconfigmessage() {
  // @@protoc_insertion_point(field_release:SessionProtos.Content.sharedConfigMessage)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::SessionProtos::SharedConfigMessage* temp = _impl_.sharedconfigmessage_;
  _impl_.sharedconfigmessage_ = nullptr;
  return temp;
}
inline ::SessionProtos::SharedConfigMessage* Content::_internal_mutable_sharedconfigmessage() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.sharedconfigmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::SessionProtos::SharedConfigMessage>(GetArenaForAllocation());
    _impl_.sharedconfigmessage_ = p;
  }
  return _impl_.sharedconfigmessage_;
}
inline ::SessionProtos::SharedConfigMessage* Content::mutable_sharedconfigmessage() {
  ::SessionProtos::SharedConfigMessage* _msg = _internal_mutable_sharedconfigmessage();
  // @@protoc_insertion_point(field_mutable:SessionProtos.Content.sharedConfigMessage)
  return _msg;
}
inline void Content::set_allocated_sharedconfigmessage(::SessionProtos::SharedConfigMessage* sharedconfigmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sharedconfigmessage_;
  }
  if (sharedconfigmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sharedconfigmessage);
    if (message_arena != submessage_arena) {
      sharedconfigmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sharedconfigmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.sharedconfigmessage_ = sharedconfigmessage;
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.Content.sharedConfigMessage)
}

// -------------------------------------------------------------------

// CallMessage

// required .SessionProtos.CallMessage.Type type = 1;
inline bool CallMessage::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CallMessage::has_type() const {
  return _internal_has_type();
}
inline void CallMessage::clear_type() {
  _impl_.type_ = 6;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::SessionProtos::CallMessage_Type CallMessage::_internal_type() const {
  return static_cast< ::SessionProtos::CallMessage_Type >(_impl_.type_);
}
inline ::SessionProtos::CallMessage_Type CallMessage::type() const {
  // @@protoc_insertion_point(field_get:SessionProtos.CallMessage.type)
  return _internal_type();
}
inline void CallMessage::_internal_set_type(::SessionProtos::CallMessage_Type value) {
  assert(::SessionProtos::CallMessage_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void CallMessage::set_type(::SessionProtos::CallMessage_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:SessionProtos.CallMessage.type)
}

// repeated string sdps = 2;
inline int CallMessage::_internal_sdps_size() const {
  return _impl_.sdps_.size();
}
inline int CallMessage::sdps_size() const {
  return _internal_sdps_size();
}
inline void CallMessage::clear_sdps() {
  _impl_.sdps_.Clear();
}
inline std::string* CallMessage::add_sdps() {
  std::string* _s = _internal_add_sdps();
  // @@protoc_insertion_point(field_add_mutable:SessionProtos.CallMessage.sdps)
  return _s;
}
inline const std::string& CallMessage::_internal_sdps(int index) const {
  return _impl_.sdps_.Get(index);
}
inline const std::string& CallMessage::sdps(int index) const {
  // @@protoc_insertion_point(field_get:SessionProtos.CallMessage.sdps)
  return _internal_sdps(index);
}
inline std::string* CallMessage::mutable_sdps(int index) {
  // @@protoc_insertion_point(field_mutable:SessionProtos.CallMessage.sdps)
  return _impl_.sdps_.Mutable(index);
}
inline void CallMessage::set_sdps(int index, const std::string& value) {
  _impl_.sdps_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SessionProtos.CallMessage.sdps)
}
inline void CallMessage::set_sdps(int index, std::string&& value) {
  _impl_.sdps_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SessionProtos.CallMessage.sdps)
}
inline void CallMessage::set_sdps(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.sdps_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SessionProtos.CallMessage.sdps)
}
inline void CallMessage::set_sdps(int index, const char* value, size_t size) {
  _impl_.sdps_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SessionProtos.CallMessage.sdps)
}
inline std::string* CallMessage::_internal_add_sdps() {
  return _impl_.sdps_.Add();
}
inline void CallMessage::add_sdps(const std::string& value) {
  _impl_.sdps_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SessionProtos.CallMessage.sdps)
}
inline void CallMessage::add_sdps(std::string&& value) {
  _impl_.sdps_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SessionProtos.CallMessage.sdps)
}
inline void CallMessage::add_sdps(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.sdps_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SessionProtos.CallMessage.sdps)
}
inline void CallMessage::add_sdps(const char* value, size_t size) {
  _impl_.sdps_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SessionProtos.CallMessage.sdps)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CallMessage::sdps() const {
  // @@protoc_insertion_point(field_list:SessionProtos.CallMessage.sdps)
  return _impl_.sdps_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CallMessage::mutable_sdps() {
  // @@protoc_insertion_point(field_mutable_list:SessionProtos.CallMessage.sdps)
  return &_impl_.sdps_;
}

// repeated uint32 sdpMLineIndexes = 3;
inline int CallMessage::_internal_sdpmlineindexes_size() const {
  return _impl_.sdpmlineindexes_.size();
}
inline int CallMessage::sdpmlineindexes_size() const {
  return _internal_sdpmlineindexes_size();
}
inline void CallMessage::clear_sdpmlineindexes() {
  _impl_.sdpmlineindexes_.Clear();
}
inline uint32_t CallMessage::_internal_sdpmlineindexes(int index) const {
  return _impl_.sdpmlineindexes_.Get(index);
}
inline uint32_t CallMessage::sdpmlineindexes(int index) const {
  // @@protoc_insertion_point(field_get:SessionProtos.CallMessage.sdpMLineIndexes)
  return _internal_sdpmlineindexes(index);
}
inline void CallMessage::set_sdpmlineindexes(int index, uint32_t value) {
  _impl_.sdpmlineindexes_.Set(index, value);
  // @@protoc_insertion_point(field_set:SessionProtos.CallMessage.sdpMLineIndexes)
}
inline void CallMessage::_internal_add_sdpmlineindexes(uint32_t value) {
  _impl_.sdpmlineindexes_.Add(value);
}
inline void CallMessage::add_sdpmlineindexes(uint32_t value) {
  _internal_add_sdpmlineindexes(value);
  // @@protoc_insertion_point(field_add:SessionProtos.CallMessage.sdpMLineIndexes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CallMessage::_internal_sdpmlineindexes() const {
  return _impl_.sdpmlineindexes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CallMessage::sdpmlineindexes() const {
  // @@protoc_insertion_point(field_list:SessionProtos.CallMessage.sdpMLineIndexes)
  return _internal_sdpmlineindexes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CallMessage::_internal_mutable_sdpmlineindexes() {
  return &_impl_.sdpmlineindexes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CallMessage::mutable_sdpmlineindexes() {
  // @@protoc_insertion_point(field_mutable_list:SessionProtos.CallMessage.sdpMLineIndexes)
  return _internal_mutable_sdpmlineindexes();
}

// repeated string sdpMids = 4;
inline int CallMessage::_internal_sdpmids_size() const {
  return _impl_.sdpmids_.size();
}
inline int CallMessage::sdpmids_size() const {
  return _internal_sdpmids_size();
}
inline void CallMessage::clear_sdpmids() {
  _impl_.sdpmids_.Clear();
}
inline std::string* CallMessage::add_sdpmids() {
  std::string* _s = _internal_add_sdpmids();
  // @@protoc_insertion_point(field_add_mutable:SessionProtos.CallMessage.sdpMids)
  return _s;
}
inline const std::string& CallMessage::_internal_sdpmids(int index) const {
  return _impl_.sdpmids_.Get(index);
}
inline const std::string& CallMessage::sdpmids(int index) const {
  // @@protoc_insertion_point(field_get:SessionProtos.CallMessage.sdpMids)
  return _internal_sdpmids(index);
}
inline std::string* CallMessage::mutable_sdpmids(int index) {
  // @@protoc_insertion_point(field_mutable:SessionProtos.CallMessage.sdpMids)
  return _impl_.sdpmids_.Mutable(index);
}
inline void CallMessage::set_sdpmids(int index, const std::string& value) {
  _impl_.sdpmids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SessionProtos.CallMessage.sdpMids)
}
inline void CallMessage::set_sdpmids(int index, std::string&& value) {
  _impl_.sdpmids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SessionProtos.CallMessage.sdpMids)
}
inline void CallMessage::set_sdpmids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.sdpmids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SessionProtos.CallMessage.sdpMids)
}
inline void CallMessage::set_sdpmids(int index, const char* value, size_t size) {
  _impl_.sdpmids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SessionProtos.CallMessage.sdpMids)
}
inline std::string* CallMessage::_internal_add_sdpmids() {
  return _impl_.sdpmids_.Add();
}
inline void CallMessage::add_sdpmids(const std::string& value) {
  _impl_.sdpmids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SessionProtos.CallMessage.sdpMids)
}
inline void CallMessage::add_sdpmids(std::string&& value) {
  _impl_.sdpmids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SessionProtos.CallMessage.sdpMids)
}
inline void CallMessage::add_sdpmids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.sdpmids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SessionProtos.CallMessage.sdpMids)
}
inline void CallMessage::add_sdpmids(const char* value, size_t size) {
  _impl_.sdpmids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SessionProtos.CallMessage.sdpMids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CallMessage::sdpmids() const {
  // @@protoc_insertion_point(field_list:SessionProtos.CallMessage.sdpMids)
  return _impl_.sdpmids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CallMessage::mutable_sdpmids() {
  // @@protoc_insertion_point(field_mutable_list:SessionProtos.CallMessage.sdpMids)
  return &_impl_.sdpmids_;
}

// required string uuid = 5;
inline bool CallMessage::_internal_has_uuid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CallMessage::has_uuid() const {
  return _internal_has_uuid();
}
inline void CallMessage::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CallMessage::uuid() const {
  // @@protoc_insertion_point(field_get:SessionProtos.CallMessage.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallMessage::set_uuid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.CallMessage.uuid)
}
inline std::string* CallMessage::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:SessionProtos.CallMessage.uuid)
  return _s;
}
inline const std::string& CallMessage::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void CallMessage::_internal_set_uuid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* CallMessage::_internal_mutable_uuid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* CallMessage::release_uuid() {
  // @@protoc_insertion_point(field_release:SessionProtos.CallMessage.uuid)
  if (!_internal_has_uuid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.uuid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CallMessage::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.CallMessage.uuid)
}

// -------------------------------------------------------------------

// KeyPair

// required bytes publicKey = 1;
inline bool KeyPair::_internal_has_publickey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KeyPair::has_publickey() const {
  return _internal_has_publickey();
}
inline void KeyPair::clear_publickey() {
  _impl_.publickey_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KeyPair::publickey() const {
  // @@protoc_insertion_point(field_get:SessionProtos.KeyPair.publicKey)
  return _internal_publickey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyPair::set_publickey(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.publickey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.KeyPair.publicKey)
}
inline std::string* KeyPair::mutable_publickey() {
  std::string* _s = _internal_mutable_publickey();
  // @@protoc_insertion_point(field_mutable:SessionProtos.KeyPair.publicKey)
  return _s;
}
inline const std::string& KeyPair::_internal_publickey() const {
  return _impl_.publickey_.Get();
}
inline void KeyPair::_internal_set_publickey(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.publickey_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyPair::_internal_mutable_publickey() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.publickey_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyPair::release_publickey() {
  // @@protoc_insertion_point(field_release:SessionProtos.KeyPair.publicKey)
  if (!_internal_has_publickey()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.publickey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publickey_.IsDefault()) {
    _impl_.publickey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KeyPair::set_allocated_publickey(std::string* publickey) {
  if (publickey != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.publickey_.SetAllocated(publickey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publickey_.IsDefault()) {
    _impl_.publickey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.KeyPair.publicKey)
}

// required bytes privateKey = 2;
inline bool KeyPair::_internal_has_privatekey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KeyPair::has_privatekey() const {
  return _internal_has_privatekey();
}
inline void KeyPair::clear_privatekey() {
  _impl_.privatekey_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& KeyPair::privatekey() const {
  // @@protoc_insertion_point(field_get:SessionProtos.KeyPair.privateKey)
  return _internal_privatekey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyPair::set_privatekey(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.privatekey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.KeyPair.privateKey)
}
inline std::string* KeyPair::mutable_privatekey() {
  std::string* _s = _internal_mutable_privatekey();
  // @@protoc_insertion_point(field_mutable:SessionProtos.KeyPair.privateKey)
  return _s;
}
inline const std::string& KeyPair::_internal_privatekey() const {
  return _impl_.privatekey_.Get();
}
inline void KeyPair::_internal_set_privatekey(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.privatekey_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyPair::_internal_mutable_privatekey() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.privatekey_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyPair::release_privatekey() {
  // @@protoc_insertion_point(field_release:SessionProtos.KeyPair.privateKey)
  if (!_internal_has_privatekey()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.privatekey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.privatekey_.IsDefault()) {
    _impl_.privatekey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KeyPair::set_allocated_privatekey(std::string* privatekey) {
  if (privatekey != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.privatekey_.SetAllocated(privatekey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.privatekey_.IsDefault()) {
    _impl_.privatekey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.KeyPair.privateKey)
}

// -------------------------------------------------------------------

// DataExtractionNotification

// required .SessionProtos.DataExtractionNotification.Type type = 1;
inline bool DataExtractionNotification::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataExtractionNotification::has_type() const {
  return _internal_has_type();
}
inline void DataExtractionNotification::clear_type() {
  _impl_.type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::SessionProtos::DataExtractionNotification_Type DataExtractionNotification::_internal_type() const {
  return static_cast< ::SessionProtos::DataExtractionNotification_Type >(_impl_.type_);
}
inline ::SessionProtos::DataExtractionNotification_Type DataExtractionNotification::type() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataExtractionNotification.type)
  return _internal_type();
}
inline void DataExtractionNotification::_internal_set_type(::SessionProtos::DataExtractionNotification_Type value) {
  assert(::SessionProtos::DataExtractionNotification_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void DataExtractionNotification::set_type(::SessionProtos::DataExtractionNotification_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:SessionProtos.DataExtractionNotification.type)
}

// optional uint64 timestamp = 2;
inline bool DataExtractionNotification::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataExtractionNotification::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void DataExtractionNotification::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t DataExtractionNotification::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t DataExtractionNotification::timestamp() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataExtractionNotification.timestamp)
  return _internal_timestamp();
}
inline void DataExtractionNotification::_internal_set_timestamp(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ = value;
}
inline void DataExtractionNotification::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:SessionProtos.DataExtractionNotification.timestamp)
}

// -------------------------------------------------------------------

// LokiProfile

// optional string displayName = 1;
inline bool LokiProfile::_internal_has_displayname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LokiProfile::has_displayname() const {
  return _internal_has_displayname();
}
inline void LokiProfile::clear_displayname() {
  _impl_.displayname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LokiProfile::displayname() const {
  // @@protoc_insertion_point(field_get:SessionProtos.LokiProfile.displayName)
  return _internal_displayname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LokiProfile::set_displayname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.displayname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.LokiProfile.displayName)
}
inline std::string* LokiProfile::mutable_displayname() {
  std::string* _s = _internal_mutable_displayname();
  // @@protoc_insertion_point(field_mutable:SessionProtos.LokiProfile.displayName)
  return _s;
}
inline const std::string& LokiProfile::_internal_displayname() const {
  return _impl_.displayname_.Get();
}
inline void LokiProfile::_internal_set_displayname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.displayname_.Set(value, GetArenaForAllocation());
}
inline std::string* LokiProfile::_internal_mutable_displayname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.displayname_.Mutable(GetArenaForAllocation());
}
inline std::string* LokiProfile::release_displayname() {
  // @@protoc_insertion_point(field_release:SessionProtos.LokiProfile.displayName)
  if (!_internal_has_displayname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.displayname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.displayname_.IsDefault()) {
    _impl_.displayname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LokiProfile::set_allocated_displayname(std::string* displayname) {
  if (displayname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.displayname_.SetAllocated(displayname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.displayname_.IsDefault()) {
    _impl_.displayname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.LokiProfile.displayName)
}

// optional string profilePicture = 2;
inline bool LokiProfile::_internal_has_profilepicture() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LokiProfile::has_profilepicture() const {
  return _internal_has_profilepicture();
}
inline void LokiProfile::clear_profilepicture() {
  _impl_.profilepicture_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LokiProfile::profilepicture() const {
  // @@protoc_insertion_point(field_get:SessionProtos.LokiProfile.profilePicture)
  return _internal_profilepicture();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LokiProfile::set_profilepicture(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.profilepicture_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.LokiProfile.profilePicture)
}
inline std::string* LokiProfile::mutable_profilepicture() {
  std::string* _s = _internal_mutable_profilepicture();
  // @@protoc_insertion_point(field_mutable:SessionProtos.LokiProfile.profilePicture)
  return _s;
}
inline const std::string& LokiProfile::_internal_profilepicture() const {
  return _impl_.profilepicture_.Get();
}
inline void LokiProfile::_internal_set_profilepicture(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.profilepicture_.Set(value, GetArenaForAllocation());
}
inline std::string* LokiProfile::_internal_mutable_profilepicture() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.profilepicture_.Mutable(GetArenaForAllocation());
}
inline std::string* LokiProfile::release_profilepicture() {
  // @@protoc_insertion_point(field_release:SessionProtos.LokiProfile.profilePicture)
  if (!_internal_has_profilepicture()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.profilepicture_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.profilepicture_.IsDefault()) {
    _impl_.profilepicture_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LokiProfile::set_allocated_profilepicture(std::string* profilepicture) {
  if (profilepicture != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.profilepicture_.SetAllocated(profilepicture, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.profilepicture_.IsDefault()) {
    _impl_.profilepicture_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.LokiProfile.profilePicture)
}

// -------------------------------------------------------------------

// DataMessage_Quote_QuotedAttachment

// optional string contentType = 1;
inline bool DataMessage_Quote_QuotedAttachment::_internal_has_contenttype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataMessage_Quote_QuotedAttachment::has_contenttype() const {
  return _internal_has_contenttype();
}
inline void DataMessage_Quote_QuotedAttachment::clear_contenttype() {
  _impl_.contenttype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataMessage_Quote_QuotedAttachment::contenttype() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.Quote.QuotedAttachment.contentType)
  return _internal_contenttype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMessage_Quote_QuotedAttachment::set_contenttype(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.contenttype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.Quote.QuotedAttachment.contentType)
}
inline std::string* DataMessage_Quote_QuotedAttachment::mutable_contenttype() {
  std::string* _s = _internal_mutable_contenttype();
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.Quote.QuotedAttachment.contentType)
  return _s;
}
inline const std::string& DataMessage_Quote_QuotedAttachment::_internal_contenttype() const {
  return _impl_.contenttype_.Get();
}
inline void DataMessage_Quote_QuotedAttachment::_internal_set_contenttype(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.contenttype_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMessage_Quote_QuotedAttachment::_internal_mutable_contenttype() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.contenttype_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMessage_Quote_QuotedAttachment::release_contenttype() {
  // @@protoc_insertion_point(field_release:SessionProtos.DataMessage.Quote.QuotedAttachment.contentType)
  if (!_internal_has_contenttype()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.contenttype_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contenttype_.IsDefault()) {
    _impl_.contenttype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataMessage_Quote_QuotedAttachment::set_allocated_contenttype(std::string* contenttype) {
  if (contenttype != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.contenttype_.SetAllocated(contenttype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contenttype_.IsDefault()) {
    _impl_.contenttype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.DataMessage.Quote.QuotedAttachment.contentType)
}

// optional string fileName = 2;
inline bool DataMessage_Quote_QuotedAttachment::_internal_has_filename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataMessage_Quote_QuotedAttachment::has_filename() const {
  return _internal_has_filename();
}
inline void DataMessage_Quote_QuotedAttachment::clear_filename() {
  _impl_.filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DataMessage_Quote_QuotedAttachment::filename() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.Quote.QuotedAttachment.fileName)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMessage_Quote_QuotedAttachment::set_filename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.Quote.QuotedAttachment.fileName)
}
inline std::string* DataMessage_Quote_QuotedAttachment::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.Quote.QuotedAttachment.fileName)
  return _s;
}
inline const std::string& DataMessage_Quote_QuotedAttachment::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void DataMessage_Quote_QuotedAttachment::_internal_set_filename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMessage_Quote_QuotedAttachment::_internal_mutable_filename() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMessage_Quote_QuotedAttachment::release_filename() {
  // @@protoc_insertion_point(field_release:SessionProtos.DataMessage.Quote.QuotedAttachment.fileName)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.filename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataMessage_Quote_QuotedAttachment::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.DataMessage.Quote.QuotedAttachment.fileName)
}

// optional .SessionProtos.AttachmentPointer thumbnail = 3;
inline bool DataMessage_Quote_QuotedAttachment::_internal_has_thumbnail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.thumbnail_ != nullptr);
  return value;
}
inline bool DataMessage_Quote_QuotedAttachment::has_thumbnail() const {
  return _internal_has_thumbnail();
}
inline void DataMessage_Quote_QuotedAttachment::clear_thumbnail() {
  if (_impl_.thumbnail_ != nullptr) _impl_.thumbnail_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::SessionProtos::AttachmentPointer& DataMessage_Quote_QuotedAttachment::_internal_thumbnail() const {
  const ::SessionProtos::AttachmentPointer* p = _impl_.thumbnail_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionProtos::AttachmentPointer&>(
      ::SessionProtos::_AttachmentPointer_default_instance_);
}
inline const ::SessionProtos::AttachmentPointer& DataMessage_Quote_QuotedAttachment::thumbnail() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.Quote.QuotedAttachment.thumbnail)
  return _internal_thumbnail();
}
inline void DataMessage_Quote_QuotedAttachment::unsafe_arena_set_allocated_thumbnail(
    ::SessionProtos::AttachmentPointer* thumbnail) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.thumbnail_);
  }
  _impl_.thumbnail_ = thumbnail;
  if (thumbnail) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SessionProtos.DataMessage.Quote.QuotedAttachment.thumbnail)
}
inline ::SessionProtos::AttachmentPointer* DataMessage_Quote_QuotedAttachment::release_thumbnail() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::SessionProtos::AttachmentPointer* temp = _impl_.thumbnail_;
  _impl_.thumbnail_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SessionProtos::AttachmentPointer* DataMessage_Quote_QuotedAttachment::unsafe_arena_release_thumbnail() {
  // @@protoc_insertion_point(field_release:SessionProtos.DataMessage.Quote.QuotedAttachment.thumbnail)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::SessionProtos::AttachmentPointer* temp = _impl_.thumbnail_;
  _impl_.thumbnail_ = nullptr;
  return temp;
}
inline ::SessionProtos::AttachmentPointer* DataMessage_Quote_QuotedAttachment::_internal_mutable_thumbnail() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.thumbnail_ == nullptr) {
    auto* p = CreateMaybeMessage<::SessionProtos::AttachmentPointer>(GetArenaForAllocation());
    _impl_.thumbnail_ = p;
  }
  return _impl_.thumbnail_;
}
inline ::SessionProtos::AttachmentPointer* DataMessage_Quote_QuotedAttachment::mutable_thumbnail() {
  ::SessionProtos::AttachmentPointer* _msg = _internal_mutable_thumbnail();
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.Quote.QuotedAttachment.thumbnail)
  return _msg;
}
inline void DataMessage_Quote_QuotedAttachment::set_allocated_thumbnail(::SessionProtos::AttachmentPointer* thumbnail) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.thumbnail_;
  }
  if (thumbnail) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(thumbnail);
    if (message_arena != submessage_arena) {
      thumbnail = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, thumbnail, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.thumbnail_ = thumbnail;
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.DataMessage.Quote.QuotedAttachment.thumbnail)
}

// optional uint32 flags = 4;
inline bool DataMessage_Quote_QuotedAttachment::_internal_has_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DataMessage_Quote_QuotedAttachment::has_flags() const {
  return _internal_has_flags();
}
inline void DataMessage_Quote_QuotedAttachment::clear_flags() {
  _impl_.flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t DataMessage_Quote_QuotedAttachment::_internal_flags() const {
  return _impl_.flags_;
}
inline uint32_t DataMessage_Quote_QuotedAttachment::flags() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.Quote.QuotedAttachment.flags)
  return _internal_flags();
}
inline void DataMessage_Quote_QuotedAttachment::_internal_set_flags(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.flags_ = value;
}
inline void DataMessage_Quote_QuotedAttachment::set_flags(uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.Quote.QuotedAttachment.flags)
}

// -------------------------------------------------------------------

// DataMessage_Quote

// required uint64 id = 1;
inline bool DataMessage_Quote::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DataMessage_Quote::has_id() const {
  return _internal_has_id();
}
inline void DataMessage_Quote::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t DataMessage_Quote::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t DataMessage_Quote::id() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.Quote.id)
  return _internal_id();
}
inline void DataMessage_Quote::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.id_ = value;
}
inline void DataMessage_Quote::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.Quote.id)
}

// required string author = 2;
inline bool DataMessage_Quote::_internal_has_author() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataMessage_Quote::has_author() const {
  return _internal_has_author();
}
inline void DataMessage_Quote::clear_author() {
  _impl_.author_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataMessage_Quote::author() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.Quote.author)
  return _internal_author();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMessage_Quote::set_author(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.author_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.Quote.author)
}
inline std::string* DataMessage_Quote::mutable_author() {
  std::string* _s = _internal_mutable_author();
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.Quote.author)
  return _s;
}
inline const std::string& DataMessage_Quote::_internal_author() const {
  return _impl_.author_.Get();
}
inline void DataMessage_Quote::_internal_set_author(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.author_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMessage_Quote::_internal_mutable_author() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.author_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMessage_Quote::release_author() {
  // @@protoc_insertion_point(field_release:SessionProtos.DataMessage.Quote.author)
  if (!_internal_has_author()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.author_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.author_.IsDefault()) {
    _impl_.author_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataMessage_Quote::set_allocated_author(std::string* author) {
  if (author != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.author_.SetAllocated(author, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.author_.IsDefault()) {
    _impl_.author_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.DataMessage.Quote.author)
}

// optional string text = 3;
inline bool DataMessage_Quote::_internal_has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataMessage_Quote::has_text() const {
  return _internal_has_text();
}
inline void DataMessage_Quote::clear_text() {
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DataMessage_Quote::text() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.Quote.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMessage_Quote::set_text(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.Quote.text)
}
inline std::string* DataMessage_Quote::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.Quote.text)
  return _s;
}
inline const std::string& DataMessage_Quote::_internal_text() const {
  return _impl_.text_.Get();
}
inline void DataMessage_Quote::_internal_set_text(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMessage_Quote::_internal_mutable_text() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMessage_Quote::release_text() {
  // @@protoc_insertion_point(field_release:SessionProtos.DataMessage.Quote.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataMessage_Quote::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.DataMessage.Quote.text)
}

// repeated .SessionProtos.DataMessage.Quote.QuotedAttachment attachments = 4;
inline int DataMessage_Quote::_internal_attachments_size() const {
  return _impl_.attachments_.size();
}
inline int DataMessage_Quote::attachments_size() const {
  return _internal_attachments_size();
}
inline void DataMessage_Quote::clear_attachments() {
  _impl_.attachments_.Clear();
}
inline ::SessionProtos::DataMessage_Quote_QuotedAttachment* DataMessage_Quote::mutable_attachments(int index) {
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.Quote.attachments)
  return _impl_.attachments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::DataMessage_Quote_QuotedAttachment >*
DataMessage_Quote::mutable_attachments() {
  // @@protoc_insertion_point(field_mutable_list:SessionProtos.DataMessage.Quote.attachments)
  return &_impl_.attachments_;
}
inline const ::SessionProtos::DataMessage_Quote_QuotedAttachment& DataMessage_Quote::_internal_attachments(int index) const {
  return _impl_.attachments_.Get(index);
}
inline const ::SessionProtos::DataMessage_Quote_QuotedAttachment& DataMessage_Quote::attachments(int index) const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.Quote.attachments)
  return _internal_attachments(index);
}
inline ::SessionProtos::DataMessage_Quote_QuotedAttachment* DataMessage_Quote::_internal_add_attachments() {
  return _impl_.attachments_.Add();
}
inline ::SessionProtos::DataMessage_Quote_QuotedAttachment* DataMessage_Quote::add_attachments() {
  ::SessionProtos::DataMessage_Quote_QuotedAttachment* _add = _internal_add_attachments();
  // @@protoc_insertion_point(field_add:SessionProtos.DataMessage.Quote.attachments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::DataMessage_Quote_QuotedAttachment >&
DataMessage_Quote::attachments() const {
  // @@protoc_insertion_point(field_list:SessionProtos.DataMessage.Quote.attachments)
  return _impl_.attachments_;
}

// -------------------------------------------------------------------

// DataMessage_Preview

// required string url = 1;
inline bool DataMessage_Preview::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataMessage_Preview::has_url() const {
  return _internal_has_url();
}
inline void DataMessage_Preview::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataMessage_Preview::url() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.Preview.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMessage_Preview::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.Preview.url)
}
inline std::string* DataMessage_Preview::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.Preview.url)
  return _s;
}
inline const std::string& DataMessage_Preview::_internal_url() const {
  return _impl_.url_.Get();
}
inline void DataMessage_Preview::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMessage_Preview::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMessage_Preview::release_url() {
  // @@protoc_insertion_point(field_release:SessionProtos.DataMessage.Preview.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataMessage_Preview::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.DataMessage.Preview.url)
}

// optional string title = 2;
inline bool DataMessage_Preview::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataMessage_Preview::has_title() const {
  return _internal_has_title();
}
inline void DataMessage_Preview::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DataMessage_Preview::title() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.Preview.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMessage_Preview::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.Preview.title)
}
inline std::string* DataMessage_Preview::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.Preview.title)
  return _s;
}
inline const std::string& DataMessage_Preview::_internal_title() const {
  return _impl_.title_.Get();
}
inline void DataMessage_Preview::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMessage_Preview::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMessage_Preview::release_title() {
  // @@protoc_insertion_point(field_release:SessionProtos.DataMessage.Preview.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataMessage_Preview::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.DataMessage.Preview.title)
}

// optional .SessionProtos.AttachmentPointer image = 3;
inline bool DataMessage_Preview::_internal_has_image() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.image_ != nullptr);
  return value;
}
inline bool DataMessage_Preview::has_image() const {
  return _internal_has_image();
}
inline void DataMessage_Preview::clear_image() {
  if (_impl_.image_ != nullptr) _impl_.image_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::SessionProtos::AttachmentPointer& DataMessage_Preview::_internal_image() const {
  const ::SessionProtos::AttachmentPointer* p = _impl_.image_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionProtos::AttachmentPointer&>(
      ::SessionProtos::_AttachmentPointer_default_instance_);
}
inline const ::SessionProtos::AttachmentPointer& DataMessage_Preview::image() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.Preview.image)
  return _internal_image();
}
inline void DataMessage_Preview::unsafe_arena_set_allocated_image(
    ::SessionProtos::AttachmentPointer* image) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_);
  }
  _impl_.image_ = image;
  if (image) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SessionProtos.DataMessage.Preview.image)
}
inline ::SessionProtos::AttachmentPointer* DataMessage_Preview::release_image() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::SessionProtos::AttachmentPointer* temp = _impl_.image_;
  _impl_.image_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SessionProtos::AttachmentPointer* DataMessage_Preview::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_release:SessionProtos.DataMessage.Preview.image)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::SessionProtos::AttachmentPointer* temp = _impl_.image_;
  _impl_.image_ = nullptr;
  return temp;
}
inline ::SessionProtos::AttachmentPointer* DataMessage_Preview::_internal_mutable_image() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.image_ == nullptr) {
    auto* p = CreateMaybeMessage<::SessionProtos::AttachmentPointer>(GetArenaForAllocation());
    _impl_.image_ = p;
  }
  return _impl_.image_;
}
inline ::SessionProtos::AttachmentPointer* DataMessage_Preview::mutable_image() {
  ::SessionProtos::AttachmentPointer* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.Preview.image)
  return _msg;
}
inline void DataMessage_Preview::set_allocated_image(::SessionProtos::AttachmentPointer* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.image_;
  }
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(image);
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.image_ = image;
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.DataMessage.Preview.image)
}

// -------------------------------------------------------------------

// DataMessage_Reaction

// required uint64 id = 1;
inline bool DataMessage_Reaction::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DataMessage_Reaction::has_id() const {
  return _internal_has_id();
}
inline void DataMessage_Reaction::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t DataMessage_Reaction::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t DataMessage_Reaction::id() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.Reaction.id)
  return _internal_id();
}
inline void DataMessage_Reaction::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.id_ = value;
}
inline void DataMessage_Reaction::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.Reaction.id)
}

// required string author = 2;
inline bool DataMessage_Reaction::_internal_has_author() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataMessage_Reaction::has_author() const {
  return _internal_has_author();
}
inline void DataMessage_Reaction::clear_author() {
  _impl_.author_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataMessage_Reaction::author() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.Reaction.author)
  return _internal_author();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMessage_Reaction::set_author(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.author_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.Reaction.author)
}
inline std::string* DataMessage_Reaction::mutable_author() {
  std::string* _s = _internal_mutable_author();
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.Reaction.author)
  return _s;
}
inline const std::string& DataMessage_Reaction::_internal_author() const {
  return _impl_.author_.Get();
}
inline void DataMessage_Reaction::_internal_set_author(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.author_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMessage_Reaction::_internal_mutable_author() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.author_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMessage_Reaction::release_author() {
  // @@protoc_insertion_point(field_release:SessionProtos.DataMessage.Reaction.author)
  if (!_internal_has_author()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.author_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.author_.IsDefault()) {
    _impl_.author_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataMessage_Reaction::set_allocated_author(std::string* author) {
  if (author != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.author_.SetAllocated(author, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.author_.IsDefault()) {
    _impl_.author_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.DataMessage.Reaction.author)
}

// optional string emoji = 3;
inline bool DataMessage_Reaction::_internal_has_emoji() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataMessage_Reaction::has_emoji() const {
  return _internal_has_emoji();
}
inline void DataMessage_Reaction::clear_emoji() {
  _impl_.emoji_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DataMessage_Reaction::emoji() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.Reaction.emoji)
  return _internal_emoji();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMessage_Reaction::set_emoji(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.emoji_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.Reaction.emoji)
}
inline std::string* DataMessage_Reaction::mutable_emoji() {
  std::string* _s = _internal_mutable_emoji();
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.Reaction.emoji)
  return _s;
}
inline const std::string& DataMessage_Reaction::_internal_emoji() const {
  return _impl_.emoji_.Get();
}
inline void DataMessage_Reaction::_internal_set_emoji(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.emoji_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMessage_Reaction::_internal_mutable_emoji() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.emoji_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMessage_Reaction::release_emoji() {
  // @@protoc_insertion_point(field_release:SessionProtos.DataMessage.Reaction.emoji)
  if (!_internal_has_emoji()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.emoji_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.emoji_.IsDefault()) {
    _impl_.emoji_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataMessage_Reaction::set_allocated_emoji(std::string* emoji) {
  if (emoji != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.emoji_.SetAllocated(emoji, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.emoji_.IsDefault()) {
    _impl_.emoji_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.DataMessage.Reaction.emoji)
}

// required .SessionProtos.DataMessage.Reaction.Action action = 4;
inline bool DataMessage_Reaction::_internal_has_action() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DataMessage_Reaction::has_action() const {
  return _internal_has_action();
}
inline void DataMessage_Reaction::clear_action() {
  _impl_.action_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::SessionProtos::DataMessage_Reaction_Action DataMessage_Reaction::_internal_action() const {
  return static_cast< ::SessionProtos::DataMessage_Reaction_Action >(_impl_.action_);
}
inline ::SessionProtos::DataMessage_Reaction_Action DataMessage_Reaction::action() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.Reaction.action)
  return _internal_action();
}
inline void DataMessage_Reaction::_internal_set_action(::SessionProtos::DataMessage_Reaction_Action value) {
  assert(::SessionProtos::DataMessage_Reaction_Action_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.action_ = value;
}
inline void DataMessage_Reaction::set_action(::SessionProtos::DataMessage_Reaction_Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.Reaction.action)
}

// -------------------------------------------------------------------

// DataMessage_OpenGroupInvitation

// required string url = 1;
inline bool DataMessage_OpenGroupInvitation::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataMessage_OpenGroupInvitation::has_url() const {
  return _internal_has_url();
}
inline void DataMessage_OpenGroupInvitation::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataMessage_OpenGroupInvitation::url() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.OpenGroupInvitation.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMessage_OpenGroupInvitation::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.OpenGroupInvitation.url)
}
inline std::string* DataMessage_OpenGroupInvitation::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.OpenGroupInvitation.url)
  return _s;
}
inline const std::string& DataMessage_OpenGroupInvitation::_internal_url() const {
  return _impl_.url_.Get();
}
inline void DataMessage_OpenGroupInvitation::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMessage_OpenGroupInvitation::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMessage_OpenGroupInvitation::release_url() {
  // @@protoc_insertion_point(field_release:SessionProtos.DataMessage.OpenGroupInvitation.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataMessage_OpenGroupInvitation::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.DataMessage.OpenGroupInvitation.url)
}

// required string name = 3;
inline bool DataMessage_OpenGroupInvitation::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataMessage_OpenGroupInvitation::has_name() const {
  return _internal_has_name();
}
inline void DataMessage_OpenGroupInvitation::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DataMessage_OpenGroupInvitation::name() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.OpenGroupInvitation.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMessage_OpenGroupInvitation::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.OpenGroupInvitation.name)
}
inline std::string* DataMessage_OpenGroupInvitation::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.OpenGroupInvitation.name)
  return _s;
}
inline const std::string& DataMessage_OpenGroupInvitation::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DataMessage_OpenGroupInvitation::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMessage_OpenGroupInvitation::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMessage_OpenGroupInvitation::release_name() {
  // @@protoc_insertion_point(field_release:SessionProtos.DataMessage.OpenGroupInvitation.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataMessage_OpenGroupInvitation::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.DataMessage.OpenGroupInvitation.name)
}

// -------------------------------------------------------------------

// DataMessage_ClosedGroupControlMessage_KeyPairWrapper

// required bytes publicKey = 1;
inline bool DataMessage_ClosedGroupControlMessage_KeyPairWrapper::_internal_has_publickey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataMessage_ClosedGroupControlMessage_KeyPairWrapper::has_publickey() const {
  return _internal_has_publickey();
}
inline void DataMessage_ClosedGroupControlMessage_KeyPairWrapper::clear_publickey() {
  _impl_.publickey_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataMessage_ClosedGroupControlMessage_KeyPairWrapper::publickey() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper.publicKey)
  return _internal_publickey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMessage_ClosedGroupControlMessage_KeyPairWrapper::set_publickey(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.publickey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper.publicKey)
}
inline std::string* DataMessage_ClosedGroupControlMessage_KeyPairWrapper::mutable_publickey() {
  std::string* _s = _internal_mutable_publickey();
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper.publicKey)
  return _s;
}
inline const std::string& DataMessage_ClosedGroupControlMessage_KeyPairWrapper::_internal_publickey() const {
  return _impl_.publickey_.Get();
}
inline void DataMessage_ClosedGroupControlMessage_KeyPairWrapper::_internal_set_publickey(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.publickey_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMessage_ClosedGroupControlMessage_KeyPairWrapper::_internal_mutable_publickey() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.publickey_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMessage_ClosedGroupControlMessage_KeyPairWrapper::release_publickey() {
  // @@protoc_insertion_point(field_release:SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper.publicKey)
  if (!_internal_has_publickey()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.publickey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publickey_.IsDefault()) {
    _impl_.publickey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataMessage_ClosedGroupControlMessage_KeyPairWrapper::set_allocated_publickey(std::string* publickey) {
  if (publickey != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.publickey_.SetAllocated(publickey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publickey_.IsDefault()) {
    _impl_.publickey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper.publicKey)
}

// required bytes encryptedKeyPair = 2;
inline bool DataMessage_ClosedGroupControlMessage_KeyPairWrapper::_internal_has_encryptedkeypair() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataMessage_ClosedGroupControlMessage_KeyPairWrapper::has_encryptedkeypair() const {
  return _internal_has_encryptedkeypair();
}
inline void DataMessage_ClosedGroupControlMessage_KeyPairWrapper::clear_encryptedkeypair() {
  _impl_.encryptedkeypair_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DataMessage_ClosedGroupControlMessage_KeyPairWrapper::encryptedkeypair() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper.encryptedKeyPair)
  return _internal_encryptedkeypair();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMessage_ClosedGroupControlMessage_KeyPairWrapper::set_encryptedkeypair(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.encryptedkeypair_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper.encryptedKeyPair)
}
inline std::string* DataMessage_ClosedGroupControlMessage_KeyPairWrapper::mutable_encryptedkeypair() {
  std::string* _s = _internal_mutable_encryptedkeypair();
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper.encryptedKeyPair)
  return _s;
}
inline const std::string& DataMessage_ClosedGroupControlMessage_KeyPairWrapper::_internal_encryptedkeypair() const {
  return _impl_.encryptedkeypair_.Get();
}
inline void DataMessage_ClosedGroupControlMessage_KeyPairWrapper::_internal_set_encryptedkeypair(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.encryptedkeypair_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMessage_ClosedGroupControlMessage_KeyPairWrapper::_internal_mutable_encryptedkeypair() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.encryptedkeypair_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMessage_ClosedGroupControlMessage_KeyPairWrapper::release_encryptedkeypair() {
  // @@protoc_insertion_point(field_release:SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper.encryptedKeyPair)
  if (!_internal_has_encryptedkeypair()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.encryptedkeypair_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.encryptedkeypair_.IsDefault()) {
    _impl_.encryptedkeypair_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataMessage_ClosedGroupControlMessage_KeyPairWrapper::set_allocated_encryptedkeypair(std::string* encryptedkeypair) {
  if (encryptedkeypair != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.encryptedkeypair_.SetAllocated(encryptedkeypair, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.encryptedkeypair_.IsDefault()) {
    _impl_.encryptedkeypair_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper.encryptedKeyPair)
}

// -------------------------------------------------------------------

// DataMessage_ClosedGroupControlMessage

// required .SessionProtos.DataMessage.ClosedGroupControlMessage.Type type = 1;
inline bool DataMessage_ClosedGroupControlMessage::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DataMessage_ClosedGroupControlMessage::has_type() const {
  return _internal_has_type();
}
inline void DataMessage_ClosedGroupControlMessage::clear_type() {
  _impl_.type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::SessionProtos::DataMessage_ClosedGroupControlMessage_Type DataMessage_ClosedGroupControlMessage::_internal_type() const {
  return static_cast< ::SessionProtos::DataMessage_ClosedGroupControlMessage_Type >(_impl_.type_);
}
inline ::SessionProtos::DataMessage_ClosedGroupControlMessage_Type DataMessage_ClosedGroupControlMessage::type() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.ClosedGroupControlMessage.type)
  return _internal_type();
}
inline void DataMessage_ClosedGroupControlMessage::_internal_set_type(::SessionProtos::DataMessage_ClosedGroupControlMessage_Type value) {
  assert(::SessionProtos::DataMessage_ClosedGroupControlMessage_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.type_ = value;
}
inline void DataMessage_ClosedGroupControlMessage::set_type(::SessionProtos::DataMessage_ClosedGroupControlMessage_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.ClosedGroupControlMessage.type)
}

// optional bytes publicKey = 2;
inline bool DataMessage_ClosedGroupControlMessage::_internal_has_publickey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataMessage_ClosedGroupControlMessage::has_publickey() const {
  return _internal_has_publickey();
}
inline void DataMessage_ClosedGroupControlMessage::clear_publickey() {
  _impl_.publickey_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataMessage_ClosedGroupControlMessage::publickey() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.ClosedGroupControlMessage.publicKey)
  return _internal_publickey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMessage_ClosedGroupControlMessage::set_publickey(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.publickey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.ClosedGroupControlMessage.publicKey)
}
inline std::string* DataMessage_ClosedGroupControlMessage::mutable_publickey() {
  std::string* _s = _internal_mutable_publickey();
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.ClosedGroupControlMessage.publicKey)
  return _s;
}
inline const std::string& DataMessage_ClosedGroupControlMessage::_internal_publickey() const {
  return _impl_.publickey_.Get();
}
inline void DataMessage_ClosedGroupControlMessage::_internal_set_publickey(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.publickey_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMessage_ClosedGroupControlMessage::_internal_mutable_publickey() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.publickey_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMessage_ClosedGroupControlMessage::release_publickey() {
  // @@protoc_insertion_point(field_release:SessionProtos.DataMessage.ClosedGroupControlMessage.publicKey)
  if (!_internal_has_publickey()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.publickey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publickey_.IsDefault()) {
    _impl_.publickey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataMessage_ClosedGroupControlMessage::set_allocated_publickey(std::string* publickey) {
  if (publickey != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.publickey_.SetAllocated(publickey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publickey_.IsDefault()) {
    _impl_.publickey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.DataMessage.ClosedGroupControlMessage.publicKey)
}

// optional string name = 3;
inline bool DataMessage_ClosedGroupControlMessage::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataMessage_ClosedGroupControlMessage::has_name() const {
  return _internal_has_name();
}
inline void DataMessage_ClosedGroupControlMessage::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DataMessage_ClosedGroupControlMessage::name() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.ClosedGroupControlMessage.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMessage_ClosedGroupControlMessage::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.ClosedGroupControlMessage.name)
}
inline std::string* DataMessage_ClosedGroupControlMessage::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.ClosedGroupControlMessage.name)
  return _s;
}
inline const std::string& DataMessage_ClosedGroupControlMessage::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DataMessage_ClosedGroupControlMessage::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMessage_ClosedGroupControlMessage::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMessage_ClosedGroupControlMessage::release_name() {
  // @@protoc_insertion_point(field_release:SessionProtos.DataMessage.ClosedGroupControlMessage.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataMessage_ClosedGroupControlMessage::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.DataMessage.ClosedGroupControlMessage.name)
}

// optional .SessionProtos.KeyPair encryptionKeyPair = 4;
inline bool DataMessage_ClosedGroupControlMessage::_internal_has_encryptionkeypair() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.encryptionkeypair_ != nullptr);
  return value;
}
inline bool DataMessage_ClosedGroupControlMessage::has_encryptionkeypair() const {
  return _internal_has_encryptionkeypair();
}
inline void DataMessage_ClosedGroupControlMessage::clear_encryptionkeypair() {
  if (_impl_.encryptionkeypair_ != nullptr) _impl_.encryptionkeypair_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::SessionProtos::KeyPair& DataMessage_ClosedGroupControlMessage::_internal_encryptionkeypair() const {
  const ::SessionProtos::KeyPair* p = _impl_.encryptionkeypair_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionProtos::KeyPair&>(
      ::SessionProtos::_KeyPair_default_instance_);
}
inline const ::SessionProtos::KeyPair& DataMessage_ClosedGroupControlMessage::encryptionkeypair() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.ClosedGroupControlMessage.encryptionKeyPair)
  return _internal_encryptionkeypair();
}
inline void DataMessage_ClosedGroupControlMessage::unsafe_arena_set_allocated_encryptionkeypair(
    ::SessionProtos::KeyPair* encryptionkeypair) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.encryptionkeypair_);
  }
  _impl_.encryptionkeypair_ = encryptionkeypair;
  if (encryptionkeypair) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SessionProtos.DataMessage.ClosedGroupControlMessage.encryptionKeyPair)
}
inline ::SessionProtos::KeyPair* DataMessage_ClosedGroupControlMessage::release_encryptionkeypair() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::SessionProtos::KeyPair* temp = _impl_.encryptionkeypair_;
  _impl_.encryptionkeypair_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SessionProtos::KeyPair* DataMessage_ClosedGroupControlMessage::unsafe_arena_release_encryptionkeypair() {
  // @@protoc_insertion_point(field_release:SessionProtos.DataMessage.ClosedGroupControlMessage.encryptionKeyPair)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::SessionProtos::KeyPair* temp = _impl_.encryptionkeypair_;
  _impl_.encryptionkeypair_ = nullptr;
  return temp;
}
inline ::SessionProtos::KeyPair* DataMessage_ClosedGroupControlMessage::_internal_mutable_encryptionkeypair() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.encryptionkeypair_ == nullptr) {
    auto* p = CreateMaybeMessage<::SessionProtos::KeyPair>(GetArenaForAllocation());
    _impl_.encryptionkeypair_ = p;
  }
  return _impl_.encryptionkeypair_;
}
inline ::SessionProtos::KeyPair* DataMessage_ClosedGroupControlMessage::mutable_encryptionkeypair() {
  ::SessionProtos::KeyPair* _msg = _internal_mutable_encryptionkeypair();
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.ClosedGroupControlMessage.encryptionKeyPair)
  return _msg;
}
inline void DataMessage_ClosedGroupControlMessage::set_allocated_encryptionkeypair(::SessionProtos::KeyPair* encryptionkeypair) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.encryptionkeypair_;
  }
  if (encryptionkeypair) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(encryptionkeypair);
    if (message_arena != submessage_arena) {
      encryptionkeypair = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, encryptionkeypair, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.encryptionkeypair_ = encryptionkeypair;
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.DataMessage.ClosedGroupControlMessage.encryptionKeyPair)
}

// repeated bytes members = 5;
inline int DataMessage_ClosedGroupControlMessage::_internal_members_size() const {
  return _impl_.members_.size();
}
inline int DataMessage_ClosedGroupControlMessage::members_size() const {
  return _internal_members_size();
}
inline void DataMessage_ClosedGroupControlMessage::clear_members() {
  _impl_.members_.Clear();
}
inline std::string* DataMessage_ClosedGroupControlMessage::add_members() {
  std::string* _s = _internal_add_members();
  // @@protoc_insertion_point(field_add_mutable:SessionProtos.DataMessage.ClosedGroupControlMessage.members)
  return _s;
}
inline const std::string& DataMessage_ClosedGroupControlMessage::_internal_members(int index) const {
  return _impl_.members_.Get(index);
}
inline const std::string& DataMessage_ClosedGroupControlMessage::members(int index) const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.ClosedGroupControlMessage.members)
  return _internal_members(index);
}
inline std::string* DataMessage_ClosedGroupControlMessage::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.ClosedGroupControlMessage.members)
  return _impl_.members_.Mutable(index);
}
inline void DataMessage_ClosedGroupControlMessage::set_members(int index, const std::string& value) {
  _impl_.members_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.ClosedGroupControlMessage.members)
}
inline void DataMessage_ClosedGroupControlMessage::set_members(int index, std::string&& value) {
  _impl_.members_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.ClosedGroupControlMessage.members)
}
inline void DataMessage_ClosedGroupControlMessage::set_members(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.members_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SessionProtos.DataMessage.ClosedGroupControlMessage.members)
}
inline void DataMessage_ClosedGroupControlMessage::set_members(int index, const void* value, size_t size) {
  _impl_.members_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SessionProtos.DataMessage.ClosedGroupControlMessage.members)
}
inline std::string* DataMessage_ClosedGroupControlMessage::_internal_add_members() {
  return _impl_.members_.Add();
}
inline void DataMessage_ClosedGroupControlMessage::add_members(const std::string& value) {
  _impl_.members_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SessionProtos.DataMessage.ClosedGroupControlMessage.members)
}
inline void DataMessage_ClosedGroupControlMessage::add_members(std::string&& value) {
  _impl_.members_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SessionProtos.DataMessage.ClosedGroupControlMessage.members)
}
inline void DataMessage_ClosedGroupControlMessage::add_members(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.members_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SessionProtos.DataMessage.ClosedGroupControlMessage.members)
}
inline void DataMessage_ClosedGroupControlMessage::add_members(const void* value, size_t size) {
  _impl_.members_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SessionProtos.DataMessage.ClosedGroupControlMessage.members)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DataMessage_ClosedGroupControlMessage::members() const {
  // @@protoc_insertion_point(field_list:SessionProtos.DataMessage.ClosedGroupControlMessage.members)
  return _impl_.members_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DataMessage_ClosedGroupControlMessage::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:SessionProtos.DataMessage.ClosedGroupControlMessage.members)
  return &_impl_.members_;
}

// repeated bytes admins = 6;
inline int DataMessage_ClosedGroupControlMessage::_internal_admins_size() const {
  return _impl_.admins_.size();
}
inline int DataMessage_ClosedGroupControlMessage::admins_size() const {
  return _internal_admins_size();
}
inline void DataMessage_ClosedGroupControlMessage::clear_admins() {
  _impl_.admins_.Clear();
}
inline std::string* DataMessage_ClosedGroupControlMessage::add_admins() {
  std::string* _s = _internal_add_admins();
  // @@protoc_insertion_point(field_add_mutable:SessionProtos.DataMessage.ClosedGroupControlMessage.admins)
  return _s;
}
inline const std::string& DataMessage_ClosedGroupControlMessage::_internal_admins(int index) const {
  return _impl_.admins_.Get(index);
}
inline const std::string& DataMessage_ClosedGroupControlMessage::admins(int index) const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.ClosedGroupControlMessage.admins)
  return _internal_admins(index);
}
inline std::string* DataMessage_ClosedGroupControlMessage::mutable_admins(int index) {
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.ClosedGroupControlMessage.admins)
  return _impl_.admins_.Mutable(index);
}
inline void DataMessage_ClosedGroupControlMessage::set_admins(int index, const std::string& value) {
  _impl_.admins_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.ClosedGroupControlMessage.admins)
}
inline void DataMessage_ClosedGroupControlMessage::set_admins(int index, std::string&& value) {
  _impl_.admins_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.ClosedGroupControlMessage.admins)
}
inline void DataMessage_ClosedGroupControlMessage::set_admins(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.admins_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SessionProtos.DataMessage.ClosedGroupControlMessage.admins)
}
inline void DataMessage_ClosedGroupControlMessage::set_admins(int index, const void* value, size_t size) {
  _impl_.admins_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SessionProtos.DataMessage.ClosedGroupControlMessage.admins)
}
inline std::string* DataMessage_ClosedGroupControlMessage::_internal_add_admins() {
  return _impl_.admins_.Add();
}
inline void DataMessage_ClosedGroupControlMessage::add_admins(const std::string& value) {
  _impl_.admins_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SessionProtos.DataMessage.ClosedGroupControlMessage.admins)
}
inline void DataMessage_ClosedGroupControlMessage::add_admins(std::string&& value) {
  _impl_.admins_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SessionProtos.DataMessage.ClosedGroupControlMessage.admins)
}
inline void DataMessage_ClosedGroupControlMessage::add_admins(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.admins_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SessionProtos.DataMessage.ClosedGroupControlMessage.admins)
}
inline void DataMessage_ClosedGroupControlMessage::add_admins(const void* value, size_t size) {
  _impl_.admins_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SessionProtos.DataMessage.ClosedGroupControlMessage.admins)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DataMessage_ClosedGroupControlMessage::admins() const {
  // @@protoc_insertion_point(field_list:SessionProtos.DataMessage.ClosedGroupControlMessage.admins)
  return _impl_.admins_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DataMessage_ClosedGroupControlMessage::mutable_admins() {
  // @@protoc_insertion_point(field_mutable_list:SessionProtos.DataMessage.ClosedGroupControlMessage.admins)
  return &_impl_.admins_;
}

// repeated .SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper wrappers = 7;
inline int DataMessage_ClosedGroupControlMessage::_internal_wrappers_size() const {
  return _impl_.wrappers_.size();
}
inline int DataMessage_ClosedGroupControlMessage::wrappers_size() const {
  return _internal_wrappers_size();
}
inline void DataMessage_ClosedGroupControlMessage::clear_wrappers() {
  _impl_.wrappers_.Clear();
}
inline ::SessionProtos::DataMessage_ClosedGroupControlMessage_KeyPairWrapper* DataMessage_ClosedGroupControlMessage::mutable_wrappers(int index) {
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.ClosedGroupControlMessage.wrappers)
  return _impl_.wrappers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::DataMessage_ClosedGroupControlMessage_KeyPairWrapper >*
DataMessage_ClosedGroupControlMessage::mutable_wrappers() {
  // @@protoc_insertion_point(field_mutable_list:SessionProtos.DataMessage.ClosedGroupControlMessage.wrappers)
  return &_impl_.wrappers_;
}
inline const ::SessionProtos::DataMessage_ClosedGroupControlMessage_KeyPairWrapper& DataMessage_ClosedGroupControlMessage::_internal_wrappers(int index) const {
  return _impl_.wrappers_.Get(index);
}
inline const ::SessionProtos::DataMessage_ClosedGroupControlMessage_KeyPairWrapper& DataMessage_ClosedGroupControlMessage::wrappers(int index) const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.ClosedGroupControlMessage.wrappers)
  return _internal_wrappers(index);
}
inline ::SessionProtos::DataMessage_ClosedGroupControlMessage_KeyPairWrapper* DataMessage_ClosedGroupControlMessage::_internal_add_wrappers() {
  return _impl_.wrappers_.Add();
}
inline ::SessionProtos::DataMessage_ClosedGroupControlMessage_KeyPairWrapper* DataMessage_ClosedGroupControlMessage::add_wrappers() {
  ::SessionProtos::DataMessage_ClosedGroupControlMessage_KeyPairWrapper* _add = _internal_add_wrappers();
  // @@protoc_insertion_point(field_add:SessionProtos.DataMessage.ClosedGroupControlMessage.wrappers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::DataMessage_ClosedGroupControlMessage_KeyPairWrapper >&
DataMessage_ClosedGroupControlMessage::wrappers() const {
  // @@protoc_insertion_point(field_list:SessionProtos.DataMessage.ClosedGroupControlMessage.wrappers)
  return _impl_.wrappers_;
}

// optional uint32 expirationTimer = 8;
inline bool DataMessage_ClosedGroupControlMessage::_internal_has_expirationtimer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DataMessage_ClosedGroupControlMessage::has_expirationtimer() const {
  return _internal_has_expirationtimer();
}
inline void DataMessage_ClosedGroupControlMessage::clear_expirationtimer() {
  _impl_.expirationtimer_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t DataMessage_ClosedGroupControlMessage::_internal_expirationtimer() const {
  return _impl_.expirationtimer_;
}
inline uint32_t DataMessage_ClosedGroupControlMessage::expirationtimer() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.ClosedGroupControlMessage.expirationTimer)
  return _internal_expirationtimer();
}
inline void DataMessage_ClosedGroupControlMessage::_internal_set_expirationtimer(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.expirationtimer_ = value;
}
inline void DataMessage_ClosedGroupControlMessage::set_expirationtimer(uint32_t value) {
  _internal_set_expirationtimer(value);
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.ClosedGroupControlMessage.expirationTimer)
}

// -------------------------------------------------------------------

// DataMessage

// optional string body = 1;
inline bool DataMessage::_internal_has_body() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataMessage::has_body() const {
  return _internal_has_body();
}
inline void DataMessage::clear_body() {
  _impl_.body_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataMessage::body() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.body)
  return _internal_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMessage::set_body(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.body_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.body)
}
inline std::string* DataMessage::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.body)
  return _s;
}
inline const std::string& DataMessage::_internal_body() const {
  return _impl_.body_.Get();
}
inline void DataMessage::_internal_set_body(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.body_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMessage::_internal_mutable_body() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.body_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMessage::release_body() {
  // @@protoc_insertion_point(field_release:SessionProtos.DataMessage.body)
  if (!_internal_has_body()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.body_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.body_.IsDefault()) {
    _impl_.body_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataMessage::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.body_.SetAllocated(body, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.body_.IsDefault()) {
    _impl_.body_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.DataMessage.body)
}

// repeated .SessionProtos.AttachmentPointer attachments = 2;
inline int DataMessage::_internal_attachments_size() const {
  return _impl_.attachments_.size();
}
inline int DataMessage::attachments_size() const {
  return _internal_attachments_size();
}
inline void DataMessage::clear_attachments() {
  _impl_.attachments_.Clear();
}
inline ::SessionProtos::AttachmentPointer* DataMessage::mutable_attachments(int index) {
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.attachments)
  return _impl_.attachments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::AttachmentPointer >*
DataMessage::mutable_attachments() {
  // @@protoc_insertion_point(field_mutable_list:SessionProtos.DataMessage.attachments)
  return &_impl_.attachments_;
}
inline const ::SessionProtos::AttachmentPointer& DataMessage::_internal_attachments(int index) const {
  return _impl_.attachments_.Get(index);
}
inline const ::SessionProtos::AttachmentPointer& DataMessage::attachments(int index) const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.attachments)
  return _internal_attachments(index);
}
inline ::SessionProtos::AttachmentPointer* DataMessage::_internal_add_attachments() {
  return _impl_.attachments_.Add();
}
inline ::SessionProtos::AttachmentPointer* DataMessage::add_attachments() {
  ::SessionProtos::AttachmentPointer* _add = _internal_add_attachments();
  // @@protoc_insertion_point(field_add:SessionProtos.DataMessage.attachments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::AttachmentPointer >&
DataMessage::attachments() const {
  // @@protoc_insertion_point(field_list:SessionProtos.DataMessage.attachments)
  return _impl_.attachments_;
}

// optional uint32 flags = 4;
inline bool DataMessage::_internal_has_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool DataMessage::has_flags() const {
  return _internal_has_flags();
}
inline void DataMessage::clear_flags() {
  _impl_.flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t DataMessage::_internal_flags() const {
  return _impl_.flags_;
}
inline uint32_t DataMessage::flags() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.flags)
  return _internal_flags();
}
inline void DataMessage::_internal_set_flags(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.flags_ = value;
}
inline void DataMessage::set_flags(uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.flags)
}

// optional uint32 expireTimer = 5;
inline bool DataMessage::_internal_has_expiretimer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool DataMessage::has_expiretimer() const {
  return _internal_has_expiretimer();
}
inline void DataMessage::clear_expiretimer() {
  _impl_.expiretimer_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t DataMessage::_internal_expiretimer() const {
  return _impl_.expiretimer_;
}
inline uint32_t DataMessage::expiretimer() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.expireTimer)
  return _internal_expiretimer();
}
inline void DataMessage::_internal_set_expiretimer(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.expiretimer_ = value;
}
inline void DataMessage::set_expiretimer(uint32_t value) {
  _internal_set_expiretimer(value);
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.expireTimer)
}

// optional bytes profileKey = 6;
inline bool DataMessage::_internal_has_profilekey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataMessage::has_profilekey() const {
  return _internal_has_profilekey();
}
inline void DataMessage::clear_profilekey() {
  _impl_.profilekey_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DataMessage::profilekey() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.profileKey)
  return _internal_profilekey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMessage::set_profilekey(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.profilekey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.profileKey)
}
inline std::string* DataMessage::mutable_profilekey() {
  std::string* _s = _internal_mutable_profilekey();
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.profileKey)
  return _s;
}
inline const std::string& DataMessage::_internal_profilekey() const {
  return _impl_.profilekey_.Get();
}
inline void DataMessage::_internal_set_profilekey(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.profilekey_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMessage::_internal_mutable_profilekey() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.profilekey_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMessage::release_profilekey() {
  // @@protoc_insertion_point(field_release:SessionProtos.DataMessage.profileKey)
  if (!_internal_has_profilekey()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.profilekey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.profilekey_.IsDefault()) {
    _impl_.profilekey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataMessage::set_allocated_profilekey(std::string* profilekey) {
  if (profilekey != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.profilekey_.SetAllocated(profilekey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.profilekey_.IsDefault()) {
    _impl_.profilekey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.DataMessage.profileKey)
}

// optional uint64 timestamp = 7;
inline bool DataMessage::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool DataMessage::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void DataMessage::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline uint64_t DataMessage::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t DataMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.timestamp)
  return _internal_timestamp();
}
inline void DataMessage::_internal_set_timestamp(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.timestamp_ = value;
}
inline void DataMessage::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.timestamp)
}

// optional .SessionProtos.DataMessage.Quote quote = 8;
inline bool DataMessage::_internal_has_quote() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.quote_ != nullptr);
  return value;
}
inline bool DataMessage::has_quote() const {
  return _internal_has_quote();
}
inline void DataMessage::clear_quote() {
  if (_impl_.quote_ != nullptr) _impl_.quote_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::SessionProtos::DataMessage_Quote& DataMessage::_internal_quote() const {
  const ::SessionProtos::DataMessage_Quote* p = _impl_.quote_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionProtos::DataMessage_Quote&>(
      ::SessionProtos::_DataMessage_Quote_default_instance_);
}
inline const ::SessionProtos::DataMessage_Quote& DataMessage::quote() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.quote)
  return _internal_quote();
}
inline void DataMessage::unsafe_arena_set_allocated_quote(
    ::SessionProtos::DataMessage_Quote* quote) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.quote_);
  }
  _impl_.quote_ = quote;
  if (quote) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SessionProtos.DataMessage.quote)
}
inline ::SessionProtos::DataMessage_Quote* DataMessage::release_quote() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::SessionProtos::DataMessage_Quote* temp = _impl_.quote_;
  _impl_.quote_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SessionProtos::DataMessage_Quote* DataMessage::unsafe_arena_release_quote() {
  // @@protoc_insertion_point(field_release:SessionProtos.DataMessage.quote)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::SessionProtos::DataMessage_Quote* temp = _impl_.quote_;
  _impl_.quote_ = nullptr;
  return temp;
}
inline ::SessionProtos::DataMessage_Quote* DataMessage::_internal_mutable_quote() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.quote_ == nullptr) {
    auto* p = CreateMaybeMessage<::SessionProtos::DataMessage_Quote>(GetArenaForAllocation());
    _impl_.quote_ = p;
  }
  return _impl_.quote_;
}
inline ::SessionProtos::DataMessage_Quote* DataMessage::mutable_quote() {
  ::SessionProtos::DataMessage_Quote* _msg = _internal_mutable_quote();
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.quote)
  return _msg;
}
inline void DataMessage::set_allocated_quote(::SessionProtos::DataMessage_Quote* quote) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.quote_;
  }
  if (quote) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(quote);
    if (message_arena != submessage_arena) {
      quote = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quote, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.quote_ = quote;
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.DataMessage.quote)
}

// repeated .SessionProtos.DataMessage.Preview preview = 10;
inline int DataMessage::_internal_preview_size() const {
  return _impl_.preview_.size();
}
inline int DataMessage::preview_size() const {
  return _internal_preview_size();
}
inline void DataMessage::clear_preview() {
  _impl_.preview_.Clear();
}
inline ::SessionProtos::DataMessage_Preview* DataMessage::mutable_preview(int index) {
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.preview)
  return _impl_.preview_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::DataMessage_Preview >*
DataMessage::mutable_preview() {
  // @@protoc_insertion_point(field_mutable_list:SessionProtos.DataMessage.preview)
  return &_impl_.preview_;
}
inline const ::SessionProtos::DataMessage_Preview& DataMessage::_internal_preview(int index) const {
  return _impl_.preview_.Get(index);
}
inline const ::SessionProtos::DataMessage_Preview& DataMessage::preview(int index) const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.preview)
  return _internal_preview(index);
}
inline ::SessionProtos::DataMessage_Preview* DataMessage::_internal_add_preview() {
  return _impl_.preview_.Add();
}
inline ::SessionProtos::DataMessage_Preview* DataMessage::add_preview() {
  ::SessionProtos::DataMessage_Preview* _add = _internal_add_preview();
  // @@protoc_insertion_point(field_add:SessionProtos.DataMessage.preview)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::DataMessage_Preview >&
DataMessage::preview() const {
  // @@protoc_insertion_point(field_list:SessionProtos.DataMessage.preview)
  return _impl_.preview_;
}

// optional .SessionProtos.DataMessage.Reaction reaction = 11;
inline bool DataMessage::_internal_has_reaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.reaction_ != nullptr);
  return value;
}
inline bool DataMessage::has_reaction() const {
  return _internal_has_reaction();
}
inline void DataMessage::clear_reaction() {
  if (_impl_.reaction_ != nullptr) _impl_.reaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::SessionProtos::DataMessage_Reaction& DataMessage::_internal_reaction() const {
  const ::SessionProtos::DataMessage_Reaction* p = _impl_.reaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionProtos::DataMessage_Reaction&>(
      ::SessionProtos::_DataMessage_Reaction_default_instance_);
}
inline const ::SessionProtos::DataMessage_Reaction& DataMessage::reaction() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.reaction)
  return _internal_reaction();
}
inline void DataMessage::unsafe_arena_set_allocated_reaction(
    ::SessionProtos::DataMessage_Reaction* reaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reaction_);
  }
  _impl_.reaction_ = reaction;
  if (reaction) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SessionProtos.DataMessage.reaction)
}
inline ::SessionProtos::DataMessage_Reaction* DataMessage::release_reaction() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::SessionProtos::DataMessage_Reaction* temp = _impl_.reaction_;
  _impl_.reaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SessionProtos::DataMessage_Reaction* DataMessage::unsafe_arena_release_reaction() {
  // @@protoc_insertion_point(field_release:SessionProtos.DataMessage.reaction)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::SessionProtos::DataMessage_Reaction* temp = _impl_.reaction_;
  _impl_.reaction_ = nullptr;
  return temp;
}
inline ::SessionProtos::DataMessage_Reaction* DataMessage::_internal_mutable_reaction() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.reaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::SessionProtos::DataMessage_Reaction>(GetArenaForAllocation());
    _impl_.reaction_ = p;
  }
  return _impl_.reaction_;
}
inline ::SessionProtos::DataMessage_Reaction* DataMessage::mutable_reaction() {
  ::SessionProtos::DataMessage_Reaction* _msg = _internal_mutable_reaction();
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.reaction)
  return _msg;
}
inline void DataMessage::set_allocated_reaction(::SessionProtos::DataMessage_Reaction* reaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.reaction_;
  }
  if (reaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reaction);
    if (message_arena != submessage_arena) {
      reaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.reaction_ = reaction;
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.DataMessage.reaction)
}

// optional .SessionProtos.LokiProfile profile = 101;
inline bool DataMessage::_internal_has_profile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.profile_ != nullptr);
  return value;
}
inline bool DataMessage::has_profile() const {
  return _internal_has_profile();
}
inline void DataMessage::clear_profile() {
  if (_impl_.profile_ != nullptr) _impl_.profile_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::SessionProtos::LokiProfile& DataMessage::_internal_profile() const {
  const ::SessionProtos::LokiProfile* p = _impl_.profile_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionProtos::LokiProfile&>(
      ::SessionProtos::_LokiProfile_default_instance_);
}
inline const ::SessionProtos::LokiProfile& DataMessage::profile() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.profile)
  return _internal_profile();
}
inline void DataMessage::unsafe_arena_set_allocated_profile(
    ::SessionProtos::LokiProfile* profile) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.profile_);
  }
  _impl_.profile_ = profile;
  if (profile) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SessionProtos.DataMessage.profile)
}
inline ::SessionProtos::LokiProfile* DataMessage::release_profile() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::SessionProtos::LokiProfile* temp = _impl_.profile_;
  _impl_.profile_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SessionProtos::LokiProfile* DataMessage::unsafe_arena_release_profile() {
  // @@protoc_insertion_point(field_release:SessionProtos.DataMessage.profile)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::SessionProtos::LokiProfile* temp = _impl_.profile_;
  _impl_.profile_ = nullptr;
  return temp;
}
inline ::SessionProtos::LokiProfile* DataMessage::_internal_mutable_profile() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.profile_ == nullptr) {
    auto* p = CreateMaybeMessage<::SessionProtos::LokiProfile>(GetArenaForAllocation());
    _impl_.profile_ = p;
  }
  return _impl_.profile_;
}
inline ::SessionProtos::LokiProfile* DataMessage::mutable_profile() {
  ::SessionProtos::LokiProfile* _msg = _internal_mutable_profile();
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.profile)
  return _msg;
}
inline void DataMessage::set_allocated_profile(::SessionProtos::LokiProfile* profile) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.profile_;
  }
  if (profile) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(profile);
    if (message_arena != submessage_arena) {
      profile = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, profile, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.profile_ = profile;
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.DataMessage.profile)
}

// optional .SessionProtos.DataMessage.OpenGroupInvitation openGroupInvitation = 102;
inline bool DataMessage::_internal_has_opengroupinvitation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.opengroupinvitation_ != nullptr);
  return value;
}
inline bool DataMessage::has_opengroupinvitation() const {
  return _internal_has_opengroupinvitation();
}
inline void DataMessage::clear_opengroupinvitation() {
  if (_impl_.opengroupinvitation_ != nullptr) _impl_.opengroupinvitation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::SessionProtos::DataMessage_OpenGroupInvitation& DataMessage::_internal_opengroupinvitation() const {
  const ::SessionProtos::DataMessage_OpenGroupInvitation* p = _impl_.opengroupinvitation_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionProtos::DataMessage_OpenGroupInvitation&>(
      ::SessionProtos::_DataMessage_OpenGroupInvitation_default_instance_);
}
inline const ::SessionProtos::DataMessage_OpenGroupInvitation& DataMessage::opengroupinvitation() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.openGroupInvitation)
  return _internal_opengroupinvitation();
}
inline void DataMessage::unsafe_arena_set_allocated_opengroupinvitation(
    ::SessionProtos::DataMessage_OpenGroupInvitation* opengroupinvitation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.opengroupinvitation_);
  }
  _impl_.opengroupinvitation_ = opengroupinvitation;
  if (opengroupinvitation) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SessionProtos.DataMessage.openGroupInvitation)
}
inline ::SessionProtos::DataMessage_OpenGroupInvitation* DataMessage::release_opengroupinvitation() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::SessionProtos::DataMessage_OpenGroupInvitation* temp = _impl_.opengroupinvitation_;
  _impl_.opengroupinvitation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SessionProtos::DataMessage_OpenGroupInvitation* DataMessage::unsafe_arena_release_opengroupinvitation() {
  // @@protoc_insertion_point(field_release:SessionProtos.DataMessage.openGroupInvitation)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::SessionProtos::DataMessage_OpenGroupInvitation* temp = _impl_.opengroupinvitation_;
  _impl_.opengroupinvitation_ = nullptr;
  return temp;
}
inline ::SessionProtos::DataMessage_OpenGroupInvitation* DataMessage::_internal_mutable_opengroupinvitation() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.opengroupinvitation_ == nullptr) {
    auto* p = CreateMaybeMessage<::SessionProtos::DataMessage_OpenGroupInvitation>(GetArenaForAllocation());
    _impl_.opengroupinvitation_ = p;
  }
  return _impl_.opengroupinvitation_;
}
inline ::SessionProtos::DataMessage_OpenGroupInvitation* DataMessage::mutable_opengroupinvitation() {
  ::SessionProtos::DataMessage_OpenGroupInvitation* _msg = _internal_mutable_opengroupinvitation();
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.openGroupInvitation)
  return _msg;
}
inline void DataMessage::set_allocated_opengroupinvitation(::SessionProtos::DataMessage_OpenGroupInvitation* opengroupinvitation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.opengroupinvitation_;
  }
  if (opengroupinvitation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(opengroupinvitation);
    if (message_arena != submessage_arena) {
      opengroupinvitation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, opengroupinvitation, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.opengroupinvitation_ = opengroupinvitation;
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.DataMessage.openGroupInvitation)
}

// optional .SessionProtos.DataMessage.ClosedGroupControlMessage closedGroupControlMessage = 104;
inline bool DataMessage::_internal_has_closedgroupcontrolmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.closedgroupcontrolmessage_ != nullptr);
  return value;
}
inline bool DataMessage::has_closedgroupcontrolmessage() const {
  return _internal_has_closedgroupcontrolmessage();
}
inline void DataMessage::clear_closedgroupcontrolmessage() {
  if (_impl_.closedgroupcontrolmessage_ != nullptr) _impl_.closedgroupcontrolmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::SessionProtos::DataMessage_ClosedGroupControlMessage& DataMessage::_internal_closedgroupcontrolmessage() const {
  const ::SessionProtos::DataMessage_ClosedGroupControlMessage* p = _impl_.closedgroupcontrolmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionProtos::DataMessage_ClosedGroupControlMessage&>(
      ::SessionProtos::_DataMessage_ClosedGroupControlMessage_default_instance_);
}
inline const ::SessionProtos::DataMessage_ClosedGroupControlMessage& DataMessage::closedgroupcontrolmessage() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.closedGroupControlMessage)
  return _internal_closedgroupcontrolmessage();
}
inline void DataMessage::unsafe_arena_set_allocated_closedgroupcontrolmessage(
    ::SessionProtos::DataMessage_ClosedGroupControlMessage* closedgroupcontrolmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.closedgroupcontrolmessage_);
  }
  _impl_.closedgroupcontrolmessage_ = closedgroupcontrolmessage;
  if (closedgroupcontrolmessage) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SessionProtos.DataMessage.closedGroupControlMessage)
}
inline ::SessionProtos::DataMessage_ClosedGroupControlMessage* DataMessage::release_closedgroupcontrolmessage() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::SessionProtos::DataMessage_ClosedGroupControlMessage* temp = _impl_.closedgroupcontrolmessage_;
  _impl_.closedgroupcontrolmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SessionProtos::DataMessage_ClosedGroupControlMessage* DataMessage::unsafe_arena_release_closedgroupcontrolmessage() {
  // @@protoc_insertion_point(field_release:SessionProtos.DataMessage.closedGroupControlMessage)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::SessionProtos::DataMessage_ClosedGroupControlMessage* temp = _impl_.closedgroupcontrolmessage_;
  _impl_.closedgroupcontrolmessage_ = nullptr;
  return temp;
}
inline ::SessionProtos::DataMessage_ClosedGroupControlMessage* DataMessage::_internal_mutable_closedgroupcontrolmessage() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.closedgroupcontrolmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::SessionProtos::DataMessage_ClosedGroupControlMessage>(GetArenaForAllocation());
    _impl_.closedgroupcontrolmessage_ = p;
  }
  return _impl_.closedgroupcontrolmessage_;
}
inline ::SessionProtos::DataMessage_ClosedGroupControlMessage* DataMessage::mutable_closedgroupcontrolmessage() {
  ::SessionProtos::DataMessage_ClosedGroupControlMessage* _msg = _internal_mutable_closedgroupcontrolmessage();
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.closedGroupControlMessage)
  return _msg;
}
inline void DataMessage::set_allocated_closedgroupcontrolmessage(::SessionProtos::DataMessage_ClosedGroupControlMessage* closedgroupcontrolmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.closedgroupcontrolmessage_;
  }
  if (closedgroupcontrolmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(closedgroupcontrolmessage);
    if (message_arena != submessage_arena) {
      closedgroupcontrolmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, closedgroupcontrolmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.closedgroupcontrolmessage_ = closedgroupcontrolmessage;
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.DataMessage.closedGroupControlMessage)
}

// optional string syncTarget = 105;
inline bool DataMessage::_internal_has_synctarget() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DataMessage::has_synctarget() const {
  return _internal_has_synctarget();
}
inline void DataMessage::clear_synctarget() {
  _impl_.synctarget_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DataMessage::synctarget() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.syncTarget)
  return _internal_synctarget();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMessage::set_synctarget(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.synctarget_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.syncTarget)
}
inline std::string* DataMessage::mutable_synctarget() {
  std::string* _s = _internal_mutable_synctarget();
  // @@protoc_insertion_point(field_mutable:SessionProtos.DataMessage.syncTarget)
  return _s;
}
inline const std::string& DataMessage::_internal_synctarget() const {
  return _impl_.synctarget_.Get();
}
inline void DataMessage::_internal_set_synctarget(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.synctarget_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMessage::_internal_mutable_synctarget() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.synctarget_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMessage::release_synctarget() {
  // @@protoc_insertion_point(field_release:SessionProtos.DataMessage.syncTarget)
  if (!_internal_has_synctarget()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.synctarget_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.synctarget_.IsDefault()) {
    _impl_.synctarget_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataMessage::set_allocated_synctarget(std::string* synctarget) {
  if (synctarget != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.synctarget_.SetAllocated(synctarget, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.synctarget_.IsDefault()) {
    _impl_.synctarget_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.DataMessage.syncTarget)
}

// optional bool blocksCommunityMessageRequests = 106;
inline bool DataMessage::_internal_has_blockscommunitymessagerequests() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool DataMessage::has_blockscommunitymessagerequests() const {
  return _internal_has_blockscommunitymessagerequests();
}
inline void DataMessage::clear_blockscommunitymessagerequests() {
  _impl_.blockscommunitymessagerequests_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool DataMessage::_internal_blockscommunitymessagerequests() const {
  return _impl_.blockscommunitymessagerequests_;
}
inline bool DataMessage::blockscommunitymessagerequests() const {
  // @@protoc_insertion_point(field_get:SessionProtos.DataMessage.blocksCommunityMessageRequests)
  return _internal_blockscommunitymessagerequests();
}
inline void DataMessage::_internal_set_blockscommunitymessagerequests(bool value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.blockscommunitymessagerequests_ = value;
}
inline void DataMessage::set_blockscommunitymessagerequests(bool value) {
  _internal_set_blockscommunitymessagerequests(value);
  // @@protoc_insertion_point(field_set:SessionProtos.DataMessage.blocksCommunityMessageRequests)
}

// -------------------------------------------------------------------

// ConfigurationMessage_ClosedGroup

// optional bytes publicKey = 1;
inline bool ConfigurationMessage_ClosedGroup::_internal_has_publickey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigurationMessage_ClosedGroup::has_publickey() const {
  return _internal_has_publickey();
}
inline void ConfigurationMessage_ClosedGroup::clear_publickey() {
  _impl_.publickey_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConfigurationMessage_ClosedGroup::publickey() const {
  // @@protoc_insertion_point(field_get:SessionProtos.ConfigurationMessage.ClosedGroup.publicKey)
  return _internal_publickey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigurationMessage_ClosedGroup::set_publickey(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.publickey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.ConfigurationMessage.ClosedGroup.publicKey)
}
inline std::string* ConfigurationMessage_ClosedGroup::mutable_publickey() {
  std::string* _s = _internal_mutable_publickey();
  // @@protoc_insertion_point(field_mutable:SessionProtos.ConfigurationMessage.ClosedGroup.publicKey)
  return _s;
}
inline const std::string& ConfigurationMessage_ClosedGroup::_internal_publickey() const {
  return _impl_.publickey_.Get();
}
inline void ConfigurationMessage_ClosedGroup::_internal_set_publickey(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.publickey_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigurationMessage_ClosedGroup::_internal_mutable_publickey() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.publickey_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigurationMessage_ClosedGroup::release_publickey() {
  // @@protoc_insertion_point(field_release:SessionProtos.ConfigurationMessage.ClosedGroup.publicKey)
  if (!_internal_has_publickey()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.publickey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publickey_.IsDefault()) {
    _impl_.publickey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigurationMessage_ClosedGroup::set_allocated_publickey(std::string* publickey) {
  if (publickey != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.publickey_.SetAllocated(publickey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publickey_.IsDefault()) {
    _impl_.publickey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.ConfigurationMessage.ClosedGroup.publicKey)
}

// optional string name = 2;
inline bool ConfigurationMessage_ClosedGroup::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigurationMessage_ClosedGroup::has_name() const {
  return _internal_has_name();
}
inline void ConfigurationMessage_ClosedGroup::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConfigurationMessage_ClosedGroup::name() const {
  // @@protoc_insertion_point(field_get:SessionProtos.ConfigurationMessage.ClosedGroup.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigurationMessage_ClosedGroup::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.ConfigurationMessage.ClosedGroup.name)
}
inline std::string* ConfigurationMessage_ClosedGroup::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:SessionProtos.ConfigurationMessage.ClosedGroup.name)
  return _s;
}
inline const std::string& ConfigurationMessage_ClosedGroup::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ConfigurationMessage_ClosedGroup::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigurationMessage_ClosedGroup::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigurationMessage_ClosedGroup::release_name() {
  // @@protoc_insertion_point(field_release:SessionProtos.ConfigurationMessage.ClosedGroup.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigurationMessage_ClosedGroup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.ConfigurationMessage.ClosedGroup.name)
}

// optional .SessionProtos.KeyPair encryptionKeyPair = 3;
inline bool ConfigurationMessage_ClosedGroup::_internal_has_encryptionkeypair() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.encryptionkeypair_ != nullptr);
  return value;
}
inline bool ConfigurationMessage_ClosedGroup::has_encryptionkeypair() const {
  return _internal_has_encryptionkeypair();
}
inline void ConfigurationMessage_ClosedGroup::clear_encryptionkeypair() {
  if (_impl_.encryptionkeypair_ != nullptr) _impl_.encryptionkeypair_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::SessionProtos::KeyPair& ConfigurationMessage_ClosedGroup::_internal_encryptionkeypair() const {
  const ::SessionProtos::KeyPair* p = _impl_.encryptionkeypair_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionProtos::KeyPair&>(
      ::SessionProtos::_KeyPair_default_instance_);
}
inline const ::SessionProtos::KeyPair& ConfigurationMessage_ClosedGroup::encryptionkeypair() const {
  // @@protoc_insertion_point(field_get:SessionProtos.ConfigurationMessage.ClosedGroup.encryptionKeyPair)
  return _internal_encryptionkeypair();
}
inline void ConfigurationMessage_ClosedGroup::unsafe_arena_set_allocated_encryptionkeypair(
    ::SessionProtos::KeyPair* encryptionkeypair) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.encryptionkeypair_);
  }
  _impl_.encryptionkeypair_ = encryptionkeypair;
  if (encryptionkeypair) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SessionProtos.ConfigurationMessage.ClosedGroup.encryptionKeyPair)
}
inline ::SessionProtos::KeyPair* ConfigurationMessage_ClosedGroup::release_encryptionkeypair() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::SessionProtos::KeyPair* temp = _impl_.encryptionkeypair_;
  _impl_.encryptionkeypair_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SessionProtos::KeyPair* ConfigurationMessage_ClosedGroup::unsafe_arena_release_encryptionkeypair() {
  // @@protoc_insertion_point(field_release:SessionProtos.ConfigurationMessage.ClosedGroup.encryptionKeyPair)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::SessionProtos::KeyPair* temp = _impl_.encryptionkeypair_;
  _impl_.encryptionkeypair_ = nullptr;
  return temp;
}
inline ::SessionProtos::KeyPair* ConfigurationMessage_ClosedGroup::_internal_mutable_encryptionkeypair() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.encryptionkeypair_ == nullptr) {
    auto* p = CreateMaybeMessage<::SessionProtos::KeyPair>(GetArenaForAllocation());
    _impl_.encryptionkeypair_ = p;
  }
  return _impl_.encryptionkeypair_;
}
inline ::SessionProtos::KeyPair* ConfigurationMessage_ClosedGroup::mutable_encryptionkeypair() {
  ::SessionProtos::KeyPair* _msg = _internal_mutable_encryptionkeypair();
  // @@protoc_insertion_point(field_mutable:SessionProtos.ConfigurationMessage.ClosedGroup.encryptionKeyPair)
  return _msg;
}
inline void ConfigurationMessage_ClosedGroup::set_allocated_encryptionkeypair(::SessionProtos::KeyPair* encryptionkeypair) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.encryptionkeypair_;
  }
  if (encryptionkeypair) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(encryptionkeypair);
    if (message_arena != submessage_arena) {
      encryptionkeypair = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, encryptionkeypair, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.encryptionkeypair_ = encryptionkeypair;
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.ConfigurationMessage.ClosedGroup.encryptionKeyPair)
}

// repeated bytes members = 4;
inline int ConfigurationMessage_ClosedGroup::_internal_members_size() const {
  return _impl_.members_.size();
}
inline int ConfigurationMessage_ClosedGroup::members_size() const {
  return _internal_members_size();
}
inline void ConfigurationMessage_ClosedGroup::clear_members() {
  _impl_.members_.Clear();
}
inline std::string* ConfigurationMessage_ClosedGroup::add_members() {
  std::string* _s = _internal_add_members();
  // @@protoc_insertion_point(field_add_mutable:SessionProtos.ConfigurationMessage.ClosedGroup.members)
  return _s;
}
inline const std::string& ConfigurationMessage_ClosedGroup::_internal_members(int index) const {
  return _impl_.members_.Get(index);
}
inline const std::string& ConfigurationMessage_ClosedGroup::members(int index) const {
  // @@protoc_insertion_point(field_get:SessionProtos.ConfigurationMessage.ClosedGroup.members)
  return _internal_members(index);
}
inline std::string* ConfigurationMessage_ClosedGroup::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:SessionProtos.ConfigurationMessage.ClosedGroup.members)
  return _impl_.members_.Mutable(index);
}
inline void ConfigurationMessage_ClosedGroup::set_members(int index, const std::string& value) {
  _impl_.members_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SessionProtos.ConfigurationMessage.ClosedGroup.members)
}
inline void ConfigurationMessage_ClosedGroup::set_members(int index, std::string&& value) {
  _impl_.members_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SessionProtos.ConfigurationMessage.ClosedGroup.members)
}
inline void ConfigurationMessage_ClosedGroup::set_members(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.members_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SessionProtos.ConfigurationMessage.ClosedGroup.members)
}
inline void ConfigurationMessage_ClosedGroup::set_members(int index, const void* value, size_t size) {
  _impl_.members_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SessionProtos.ConfigurationMessage.ClosedGroup.members)
}
inline std::string* ConfigurationMessage_ClosedGroup::_internal_add_members() {
  return _impl_.members_.Add();
}
inline void ConfigurationMessage_ClosedGroup::add_members(const std::string& value) {
  _impl_.members_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SessionProtos.ConfigurationMessage.ClosedGroup.members)
}
inline void ConfigurationMessage_ClosedGroup::add_members(std::string&& value) {
  _impl_.members_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SessionProtos.ConfigurationMessage.ClosedGroup.members)
}
inline void ConfigurationMessage_ClosedGroup::add_members(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.members_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SessionProtos.ConfigurationMessage.ClosedGroup.members)
}
inline void ConfigurationMessage_ClosedGroup::add_members(const void* value, size_t size) {
  _impl_.members_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SessionProtos.ConfigurationMessage.ClosedGroup.members)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConfigurationMessage_ClosedGroup::members() const {
  // @@protoc_insertion_point(field_list:SessionProtos.ConfigurationMessage.ClosedGroup.members)
  return _impl_.members_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConfigurationMessage_ClosedGroup::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:SessionProtos.ConfigurationMessage.ClosedGroup.members)
  return &_impl_.members_;
}

// repeated bytes admins = 5;
inline int ConfigurationMessage_ClosedGroup::_internal_admins_size() const {
  return _impl_.admins_.size();
}
inline int ConfigurationMessage_ClosedGroup::admins_size() const {
  return _internal_admins_size();
}
inline void ConfigurationMessage_ClosedGroup::clear_admins() {
  _impl_.admins_.Clear();
}
inline std::string* ConfigurationMessage_ClosedGroup::add_admins() {
  std::string* _s = _internal_add_admins();
  // @@protoc_insertion_point(field_add_mutable:SessionProtos.ConfigurationMessage.ClosedGroup.admins)
  return _s;
}
inline const std::string& ConfigurationMessage_ClosedGroup::_internal_admins(int index) const {
  return _impl_.admins_.Get(index);
}
inline const std::string& ConfigurationMessage_ClosedGroup::admins(int index) const {
  // @@protoc_insertion_point(field_get:SessionProtos.ConfigurationMessage.ClosedGroup.admins)
  return _internal_admins(index);
}
inline std::string* ConfigurationMessage_ClosedGroup::mutable_admins(int index) {
  // @@protoc_insertion_point(field_mutable:SessionProtos.ConfigurationMessage.ClosedGroup.admins)
  return _impl_.admins_.Mutable(index);
}
inline void ConfigurationMessage_ClosedGroup::set_admins(int index, const std::string& value) {
  _impl_.admins_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SessionProtos.ConfigurationMessage.ClosedGroup.admins)
}
inline void ConfigurationMessage_ClosedGroup::set_admins(int index, std::string&& value) {
  _impl_.admins_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SessionProtos.ConfigurationMessage.ClosedGroup.admins)
}
inline void ConfigurationMessage_ClosedGroup::set_admins(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.admins_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SessionProtos.ConfigurationMessage.ClosedGroup.admins)
}
inline void ConfigurationMessage_ClosedGroup::set_admins(int index, const void* value, size_t size) {
  _impl_.admins_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SessionProtos.ConfigurationMessage.ClosedGroup.admins)
}
inline std::string* ConfigurationMessage_ClosedGroup::_internal_add_admins() {
  return _impl_.admins_.Add();
}
inline void ConfigurationMessage_ClosedGroup::add_admins(const std::string& value) {
  _impl_.admins_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SessionProtos.ConfigurationMessage.ClosedGroup.admins)
}
inline void ConfigurationMessage_ClosedGroup::add_admins(std::string&& value) {
  _impl_.admins_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SessionProtos.ConfigurationMessage.ClosedGroup.admins)
}
inline void ConfigurationMessage_ClosedGroup::add_admins(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.admins_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SessionProtos.ConfigurationMessage.ClosedGroup.admins)
}
inline void ConfigurationMessage_ClosedGroup::add_admins(const void* value, size_t size) {
  _impl_.admins_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SessionProtos.ConfigurationMessage.ClosedGroup.admins)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConfigurationMessage_ClosedGroup::admins() const {
  // @@protoc_insertion_point(field_list:SessionProtos.ConfigurationMessage.ClosedGroup.admins)
  return _impl_.admins_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConfigurationMessage_ClosedGroup::mutable_admins() {
  // @@protoc_insertion_point(field_mutable_list:SessionProtos.ConfigurationMessage.ClosedGroup.admins)
  return &_impl_.admins_;
}

// optional uint32 expirationTimer = 6;
inline bool ConfigurationMessage_ClosedGroup::_internal_has_expirationtimer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConfigurationMessage_ClosedGroup::has_expirationtimer() const {
  return _internal_has_expirationtimer();
}
inline void ConfigurationMessage_ClosedGroup::clear_expirationtimer() {
  _impl_.expirationtimer_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ConfigurationMessage_ClosedGroup::_internal_expirationtimer() const {
  return _impl_.expirationtimer_;
}
inline uint32_t ConfigurationMessage_ClosedGroup::expirationtimer() const {
  // @@protoc_insertion_point(field_get:SessionProtos.ConfigurationMessage.ClosedGroup.expirationTimer)
  return _internal_expirationtimer();
}
inline void ConfigurationMessage_ClosedGroup::_internal_set_expirationtimer(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.expirationtimer_ = value;
}
inline void ConfigurationMessage_ClosedGroup::set_expirationtimer(uint32_t value) {
  _internal_set_expirationtimer(value);
  // @@protoc_insertion_point(field_set:SessionProtos.ConfigurationMessage.ClosedGroup.expirationTimer)
}

// -------------------------------------------------------------------

// ConfigurationMessage_Contact

// required bytes publicKey = 1;
inline bool ConfigurationMessage_Contact::_internal_has_publickey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigurationMessage_Contact::has_publickey() const {
  return _internal_has_publickey();
}
inline void ConfigurationMessage_Contact::clear_publickey() {
  _impl_.publickey_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConfigurationMessage_Contact::publickey() const {
  // @@protoc_insertion_point(field_get:SessionProtos.ConfigurationMessage.Contact.publicKey)
  return _internal_publickey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigurationMessage_Contact::set_publickey(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.publickey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.ConfigurationMessage.Contact.publicKey)
}
inline std::string* ConfigurationMessage_Contact::mutable_publickey() {
  std::string* _s = _internal_mutable_publickey();
  // @@protoc_insertion_point(field_mutable:SessionProtos.ConfigurationMessage.Contact.publicKey)
  return _s;
}
inline const std::string& ConfigurationMessage_Contact::_internal_publickey() const {
  return _impl_.publickey_.Get();
}
inline void ConfigurationMessage_Contact::_internal_set_publickey(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.publickey_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigurationMessage_Contact::_internal_mutable_publickey() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.publickey_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigurationMessage_Contact::release_publickey() {
  // @@protoc_insertion_point(field_release:SessionProtos.ConfigurationMessage.Contact.publicKey)
  if (!_internal_has_publickey()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.publickey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publickey_.IsDefault()) {
    _impl_.publickey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigurationMessage_Contact::set_allocated_publickey(std::string* publickey) {
  if (publickey != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.publickey_.SetAllocated(publickey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publickey_.IsDefault()) {
    _impl_.publickey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.ConfigurationMessage.Contact.publicKey)
}

// required string name = 2;
inline bool ConfigurationMessage_Contact::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigurationMessage_Contact::has_name() const {
  return _internal_has_name();
}
inline void ConfigurationMessage_Contact::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConfigurationMessage_Contact::name() const {
  // @@protoc_insertion_point(field_get:SessionProtos.ConfigurationMessage.Contact.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigurationMessage_Contact::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.ConfigurationMessage.Contact.name)
}
inline std::string* ConfigurationMessage_Contact::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:SessionProtos.ConfigurationMessage.Contact.name)
  return _s;
}
inline const std::string& ConfigurationMessage_Contact::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ConfigurationMessage_Contact::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigurationMessage_Contact::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigurationMessage_Contact::release_name() {
  // @@protoc_insertion_point(field_release:SessionProtos.ConfigurationMessage.Contact.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigurationMessage_Contact::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.ConfigurationMessage.Contact.name)
}

// optional string profilePicture = 3;
inline bool ConfigurationMessage_Contact::_internal_has_profilepicture() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigurationMessage_Contact::has_profilepicture() const {
  return _internal_has_profilepicture();
}
inline void ConfigurationMessage_Contact::clear_profilepicture() {
  _impl_.profilepicture_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ConfigurationMessage_Contact::profilepicture() const {
  // @@protoc_insertion_point(field_get:SessionProtos.ConfigurationMessage.Contact.profilePicture)
  return _internal_profilepicture();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigurationMessage_Contact::set_profilepicture(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.profilepicture_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.ConfigurationMessage.Contact.profilePicture)
}
inline std::string* ConfigurationMessage_Contact::mutable_profilepicture() {
  std::string* _s = _internal_mutable_profilepicture();
  // @@protoc_insertion_point(field_mutable:SessionProtos.ConfigurationMessage.Contact.profilePicture)
  return _s;
}
inline const std::string& ConfigurationMessage_Contact::_internal_profilepicture() const {
  return _impl_.profilepicture_.Get();
}
inline void ConfigurationMessage_Contact::_internal_set_profilepicture(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.profilepicture_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigurationMessage_Contact::_internal_mutable_profilepicture() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.profilepicture_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigurationMessage_Contact::release_profilepicture() {
  // @@protoc_insertion_point(field_release:SessionProtos.ConfigurationMessage.Contact.profilePicture)
  if (!_internal_has_profilepicture()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.profilepicture_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.profilepicture_.IsDefault()) {
    _impl_.profilepicture_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigurationMessage_Contact::set_allocated_profilepicture(std::string* profilepicture) {
  if (profilepicture != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.profilepicture_.SetAllocated(profilepicture, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.profilepicture_.IsDefault()) {
    _impl_.profilepicture_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.ConfigurationMessage.Contact.profilePicture)
}

// optional bytes profileKey = 4;
inline bool ConfigurationMessage_Contact::_internal_has_profilekey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConfigurationMessage_Contact::has_profilekey() const {
  return _internal_has_profilekey();
}
inline void ConfigurationMessage_Contact::clear_profilekey() {
  _impl_.profilekey_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ConfigurationMessage_Contact::profilekey() const {
  // @@protoc_insertion_point(field_get:SessionProtos.ConfigurationMessage.Contact.profileKey)
  return _internal_profilekey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigurationMessage_Contact::set_profilekey(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.profilekey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.ConfigurationMessage.Contact.profileKey)
}
inline std::string* ConfigurationMessage_Contact::mutable_profilekey() {
  std::string* _s = _internal_mutable_profilekey();
  // @@protoc_insertion_point(field_mutable:SessionProtos.ConfigurationMessage.Contact.profileKey)
  return _s;
}
inline const std::string& ConfigurationMessage_Contact::_internal_profilekey() const {
  return _impl_.profilekey_.Get();
}
inline void ConfigurationMessage_Contact::_internal_set_profilekey(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.profilekey_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigurationMessage_Contact::_internal_mutable_profilekey() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.profilekey_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigurationMessage_Contact::release_profilekey() {
  // @@protoc_insertion_point(field_release:SessionProtos.ConfigurationMessage.Contact.profileKey)
  if (!_internal_has_profilekey()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.profilekey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.profilekey_.IsDefault()) {
    _impl_.profilekey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigurationMessage_Contact::set_allocated_profilekey(std::string* profilekey) {
  if (profilekey != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.profilekey_.SetAllocated(profilekey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.profilekey_.IsDefault()) {
    _impl_.profilekey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.ConfigurationMessage.Contact.profileKey)
}

// optional bool isApproved = 5;
inline bool ConfigurationMessage_Contact::_internal_has_isapproved() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ConfigurationMessage_Contact::has_isapproved() const {
  return _internal_has_isapproved();
}
inline void ConfigurationMessage_Contact::clear_isapproved() {
  _impl_.isapproved_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool ConfigurationMessage_Contact::_internal_isapproved() const {
  return _impl_.isapproved_;
}
inline bool ConfigurationMessage_Contact::isapproved() const {
  // @@protoc_insertion_point(field_get:SessionProtos.ConfigurationMessage.Contact.isApproved)
  return _internal_isapproved();
}
inline void ConfigurationMessage_Contact::_internal_set_isapproved(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.isapproved_ = value;
}
inline void ConfigurationMessage_Contact::set_isapproved(bool value) {
  _internal_set_isapproved(value);
  // @@protoc_insertion_point(field_set:SessionProtos.ConfigurationMessage.Contact.isApproved)
}

// optional bool isBlocked = 6;
inline bool ConfigurationMessage_Contact::_internal_has_isblocked() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ConfigurationMessage_Contact::has_isblocked() const {
  return _internal_has_isblocked();
}
inline void ConfigurationMessage_Contact::clear_isblocked() {
  _impl_.isblocked_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool ConfigurationMessage_Contact::_internal_isblocked() const {
  return _impl_.isblocked_;
}
inline bool ConfigurationMessage_Contact::isblocked() const {
  // @@protoc_insertion_point(field_get:SessionProtos.ConfigurationMessage.Contact.isBlocked)
  return _internal_isblocked();
}
inline void ConfigurationMessage_Contact::_internal_set_isblocked(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.isblocked_ = value;
}
inline void ConfigurationMessage_Contact::set_isblocked(bool value) {
  _internal_set_isblocked(value);
  // @@protoc_insertion_point(field_set:SessionProtos.ConfigurationMessage.Contact.isBlocked)
}

// optional bool didApproveMe = 7;
inline bool ConfigurationMessage_Contact::_internal_has_didapproveme() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ConfigurationMessage_Contact::has_didapproveme() const {
  return _internal_has_didapproveme();
}
inline void ConfigurationMessage_Contact::clear_didapproveme() {
  _impl_.didapproveme_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool ConfigurationMessage_Contact::_internal_didapproveme() const {
  return _impl_.didapproveme_;
}
inline bool ConfigurationMessage_Contact::didapproveme() const {
  // @@protoc_insertion_point(field_get:SessionProtos.ConfigurationMessage.Contact.didApproveMe)
  return _internal_didapproveme();
}
inline void ConfigurationMessage_Contact::_internal_set_didapproveme(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.didapproveme_ = value;
}
inline void ConfigurationMessage_Contact::set_didapproveme(bool value) {
  _internal_set_didapproveme(value);
  // @@protoc_insertion_point(field_set:SessionProtos.ConfigurationMessage.Contact.didApproveMe)
}

// -------------------------------------------------------------------

// ConfigurationMessage

// repeated .SessionProtos.ConfigurationMessage.ClosedGroup closedGroups = 1;
inline int ConfigurationMessage::_internal_closedgroups_size() const {
  return _impl_.closedgroups_.size();
}
inline int ConfigurationMessage::closedgroups_size() const {
  return _internal_closedgroups_size();
}
inline void ConfigurationMessage::clear_closedgroups() {
  _impl_.closedgroups_.Clear();
}
inline ::SessionProtos::ConfigurationMessage_ClosedGroup* ConfigurationMessage::mutable_closedgroups(int index) {
  // @@protoc_insertion_point(field_mutable:SessionProtos.ConfigurationMessage.closedGroups)
  return _impl_.closedgroups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::ConfigurationMessage_ClosedGroup >*
ConfigurationMessage::mutable_closedgroups() {
  // @@protoc_insertion_point(field_mutable_list:SessionProtos.ConfigurationMessage.closedGroups)
  return &_impl_.closedgroups_;
}
inline const ::SessionProtos::ConfigurationMessage_ClosedGroup& ConfigurationMessage::_internal_closedgroups(int index) const {
  return _impl_.closedgroups_.Get(index);
}
inline const ::SessionProtos::ConfigurationMessage_ClosedGroup& ConfigurationMessage::closedgroups(int index) const {
  // @@protoc_insertion_point(field_get:SessionProtos.ConfigurationMessage.closedGroups)
  return _internal_closedgroups(index);
}
inline ::SessionProtos::ConfigurationMessage_ClosedGroup* ConfigurationMessage::_internal_add_closedgroups() {
  return _impl_.closedgroups_.Add();
}
inline ::SessionProtos::ConfigurationMessage_ClosedGroup* ConfigurationMessage::add_closedgroups() {
  ::SessionProtos::ConfigurationMessage_ClosedGroup* _add = _internal_add_closedgroups();
  // @@protoc_insertion_point(field_add:SessionProtos.ConfigurationMessage.closedGroups)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::ConfigurationMessage_ClosedGroup >&
ConfigurationMessage::closedgroups() const {
  // @@protoc_insertion_point(field_list:SessionProtos.ConfigurationMessage.closedGroups)
  return _impl_.closedgroups_;
}

// repeated string openGroups = 2;
inline int ConfigurationMessage::_internal_opengroups_size() const {
  return _impl_.opengroups_.size();
}
inline int ConfigurationMessage::opengroups_size() const {
  return _internal_opengroups_size();
}
inline void ConfigurationMessage::clear_opengroups() {
  _impl_.opengroups_.Clear();
}
inline std::string* ConfigurationMessage::add_opengroups() {
  std::string* _s = _internal_add_opengroups();
  // @@protoc_insertion_point(field_add_mutable:SessionProtos.ConfigurationMessage.openGroups)
  return _s;
}
inline const std::string& ConfigurationMessage::_internal_opengroups(int index) const {
  return _impl_.opengroups_.Get(index);
}
inline const std::string& ConfigurationMessage::opengroups(int index) const {
  // @@protoc_insertion_point(field_get:SessionProtos.ConfigurationMessage.openGroups)
  return _internal_opengroups(index);
}
inline std::string* ConfigurationMessage::mutable_opengroups(int index) {
  // @@protoc_insertion_point(field_mutable:SessionProtos.ConfigurationMessage.openGroups)
  return _impl_.opengroups_.Mutable(index);
}
inline void ConfigurationMessage::set_opengroups(int index, const std::string& value) {
  _impl_.opengroups_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SessionProtos.ConfigurationMessage.openGroups)
}
inline void ConfigurationMessage::set_opengroups(int index, std::string&& value) {
  _impl_.opengroups_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SessionProtos.ConfigurationMessage.openGroups)
}
inline void ConfigurationMessage::set_opengroups(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.opengroups_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SessionProtos.ConfigurationMessage.openGroups)
}
inline void ConfigurationMessage::set_opengroups(int index, const char* value, size_t size) {
  _impl_.opengroups_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SessionProtos.ConfigurationMessage.openGroups)
}
inline std::string* ConfigurationMessage::_internal_add_opengroups() {
  return _impl_.opengroups_.Add();
}
inline void ConfigurationMessage::add_opengroups(const std::string& value) {
  _impl_.opengroups_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SessionProtos.ConfigurationMessage.openGroups)
}
inline void ConfigurationMessage::add_opengroups(std::string&& value) {
  _impl_.opengroups_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SessionProtos.ConfigurationMessage.openGroups)
}
inline void ConfigurationMessage::add_opengroups(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.opengroups_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SessionProtos.ConfigurationMessage.openGroups)
}
inline void ConfigurationMessage::add_opengroups(const char* value, size_t size) {
  _impl_.opengroups_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SessionProtos.ConfigurationMessage.openGroups)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConfigurationMessage::opengroups() const {
  // @@protoc_insertion_point(field_list:SessionProtos.ConfigurationMessage.openGroups)
  return _impl_.opengroups_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConfigurationMessage::mutable_opengroups() {
  // @@protoc_insertion_point(field_mutable_list:SessionProtos.ConfigurationMessage.openGroups)
  return &_impl_.opengroups_;
}

// optional string displayName = 3;
inline bool ConfigurationMessage::_internal_has_displayname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigurationMessage::has_displayname() const {
  return _internal_has_displayname();
}
inline void ConfigurationMessage::clear_displayname() {
  _impl_.displayname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConfigurationMessage::displayname() const {
  // @@protoc_insertion_point(field_get:SessionProtos.ConfigurationMessage.displayName)
  return _internal_displayname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigurationMessage::set_displayname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.displayname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.ConfigurationMessage.displayName)
}
inline std::string* ConfigurationMessage::mutable_displayname() {
  std::string* _s = _internal_mutable_displayname();
  // @@protoc_insertion_point(field_mutable:SessionProtos.ConfigurationMessage.displayName)
  return _s;
}
inline const std::string& ConfigurationMessage::_internal_displayname() const {
  return _impl_.displayname_.Get();
}
inline void ConfigurationMessage::_internal_set_displayname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.displayname_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigurationMessage::_internal_mutable_displayname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.displayname_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigurationMessage::release_displayname() {
  // @@protoc_insertion_point(field_release:SessionProtos.ConfigurationMessage.displayName)
  if (!_internal_has_displayname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.displayname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.displayname_.IsDefault()) {
    _impl_.displayname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigurationMessage::set_allocated_displayname(std::string* displayname) {
  if (displayname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.displayname_.SetAllocated(displayname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.displayname_.IsDefault()) {
    _impl_.displayname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.ConfigurationMessage.displayName)
}

// optional string profilePicture = 4;
inline bool ConfigurationMessage::_internal_has_profilepicture() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigurationMessage::has_profilepicture() const {
  return _internal_has_profilepicture();
}
inline void ConfigurationMessage::clear_profilepicture() {
  _impl_.profilepicture_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConfigurationMessage::profilepicture() const {
  // @@protoc_insertion_point(field_get:SessionProtos.ConfigurationMessage.profilePicture)
  return _internal_profilepicture();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigurationMessage::set_profilepicture(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.profilepicture_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.ConfigurationMessage.profilePicture)
}
inline std::string* ConfigurationMessage::mutable_profilepicture() {
  std::string* _s = _internal_mutable_profilepicture();
  // @@protoc_insertion_point(field_mutable:SessionProtos.ConfigurationMessage.profilePicture)
  return _s;
}
inline const std::string& ConfigurationMessage::_internal_profilepicture() const {
  return _impl_.profilepicture_.Get();
}
inline void ConfigurationMessage::_internal_set_profilepicture(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.profilepicture_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigurationMessage::_internal_mutable_profilepicture() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.profilepicture_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigurationMessage::release_profilepicture() {
  // @@protoc_insertion_point(field_release:SessionProtos.ConfigurationMessage.profilePicture)
  if (!_internal_has_profilepicture()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.profilepicture_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.profilepicture_.IsDefault()) {
    _impl_.profilepicture_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigurationMessage::set_allocated_profilepicture(std::string* profilepicture) {
  if (profilepicture != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.profilepicture_.SetAllocated(profilepicture, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.profilepicture_.IsDefault()) {
    _impl_.profilepicture_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.ConfigurationMessage.profilePicture)
}

// optional bytes profileKey = 5;
inline bool ConfigurationMessage::_internal_has_profilekey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigurationMessage::has_profilekey() const {
  return _internal_has_profilekey();
}
inline void ConfigurationMessage::clear_profilekey() {
  _impl_.profilekey_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ConfigurationMessage::profilekey() const {
  // @@protoc_insertion_point(field_get:SessionProtos.ConfigurationMessage.profileKey)
  return _internal_profilekey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigurationMessage::set_profilekey(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.profilekey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.ConfigurationMessage.profileKey)
}
inline std::string* ConfigurationMessage::mutable_profilekey() {
  std::string* _s = _internal_mutable_profilekey();
  // @@protoc_insertion_point(field_mutable:SessionProtos.ConfigurationMessage.profileKey)
  return _s;
}
inline const std::string& ConfigurationMessage::_internal_profilekey() const {
  return _impl_.profilekey_.Get();
}
inline void ConfigurationMessage::_internal_set_profilekey(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.profilekey_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigurationMessage::_internal_mutable_profilekey() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.profilekey_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigurationMessage::release_profilekey() {
  // @@protoc_insertion_point(field_release:SessionProtos.ConfigurationMessage.profileKey)
  if (!_internal_has_profilekey()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.profilekey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.profilekey_.IsDefault()) {
    _impl_.profilekey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigurationMessage::set_allocated_profilekey(std::string* profilekey) {
  if (profilekey != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.profilekey_.SetAllocated(profilekey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.profilekey_.IsDefault()) {
    _impl_.profilekey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.ConfigurationMessage.profileKey)
}

// repeated .SessionProtos.ConfigurationMessage.Contact contacts = 6;
inline int ConfigurationMessage::_internal_contacts_size() const {
  return _impl_.contacts_.size();
}
inline int ConfigurationMessage::contacts_size() const {
  return _internal_contacts_size();
}
inline void ConfigurationMessage::clear_contacts() {
  _impl_.contacts_.Clear();
}
inline ::SessionProtos::ConfigurationMessage_Contact* ConfigurationMessage::mutable_contacts(int index) {
  // @@protoc_insertion_point(field_mutable:SessionProtos.ConfigurationMessage.contacts)
  return _impl_.contacts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::ConfigurationMessage_Contact >*
ConfigurationMessage::mutable_contacts() {
  // @@protoc_insertion_point(field_mutable_list:SessionProtos.ConfigurationMessage.contacts)
  return &_impl_.contacts_;
}
inline const ::SessionProtos::ConfigurationMessage_Contact& ConfigurationMessage::_internal_contacts(int index) const {
  return _impl_.contacts_.Get(index);
}
inline const ::SessionProtos::ConfigurationMessage_Contact& ConfigurationMessage::contacts(int index) const {
  // @@protoc_insertion_point(field_get:SessionProtos.ConfigurationMessage.contacts)
  return _internal_contacts(index);
}
inline ::SessionProtos::ConfigurationMessage_Contact* ConfigurationMessage::_internal_add_contacts() {
  return _impl_.contacts_.Add();
}
inline ::SessionProtos::ConfigurationMessage_Contact* ConfigurationMessage::add_contacts() {
  ::SessionProtos::ConfigurationMessage_Contact* _add = _internal_add_contacts();
  // @@protoc_insertion_point(field_add:SessionProtos.ConfigurationMessage.contacts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SessionProtos::ConfigurationMessage_Contact >&
ConfigurationMessage::contacts() const {
  // @@protoc_insertion_point(field_list:SessionProtos.ConfigurationMessage.contacts)
  return _impl_.contacts_;
}

// -------------------------------------------------------------------

// ReceiptMessage

// required .SessionProtos.ReceiptMessage.Type type = 1;
inline bool ReceiptMessage::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReceiptMessage::has_type() const {
  return _internal_has_type();
}
inline void ReceiptMessage::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::SessionProtos::ReceiptMessage_Type ReceiptMessage::_internal_type() const {
  return static_cast< ::SessionProtos::ReceiptMessage_Type >(_impl_.type_);
}
inline ::SessionProtos::ReceiptMessage_Type ReceiptMessage::type() const {
  // @@protoc_insertion_point(field_get:SessionProtos.ReceiptMessage.type)
  return _internal_type();
}
inline void ReceiptMessage::_internal_set_type(::SessionProtos::ReceiptMessage_Type value) {
  assert(::SessionProtos::ReceiptMessage_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void ReceiptMessage::set_type(::SessionProtos::ReceiptMessage_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:SessionProtos.ReceiptMessage.type)
}

// repeated uint64 timestamp = 2;
inline int ReceiptMessage::_internal_timestamp_size() const {
  return _impl_.timestamp_.size();
}
inline int ReceiptMessage::timestamp_size() const {
  return _internal_timestamp_size();
}
inline void ReceiptMessage::clear_timestamp() {
  _impl_.timestamp_.Clear();
}
inline uint64_t ReceiptMessage::_internal_timestamp(int index) const {
  return _impl_.timestamp_.Get(index);
}
inline uint64_t ReceiptMessage::timestamp(int index) const {
  // @@protoc_insertion_point(field_get:SessionProtos.ReceiptMessage.timestamp)
  return _internal_timestamp(index);
}
inline void ReceiptMessage::set_timestamp(int index, uint64_t value) {
  _impl_.timestamp_.Set(index, value);
  // @@protoc_insertion_point(field_set:SessionProtos.ReceiptMessage.timestamp)
}
inline void ReceiptMessage::_internal_add_timestamp(uint64_t value) {
  _impl_.timestamp_.Add(value);
}
inline void ReceiptMessage::add_timestamp(uint64_t value) {
  _internal_add_timestamp(value);
  // @@protoc_insertion_point(field_add:SessionProtos.ReceiptMessage.timestamp)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
ReceiptMessage::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
ReceiptMessage::timestamp() const {
  // @@protoc_insertion_point(field_list:SessionProtos.ReceiptMessage.timestamp)
  return _internal_timestamp();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
ReceiptMessage::_internal_mutable_timestamp() {
  return &_impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
ReceiptMessage::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable_list:SessionProtos.ReceiptMessage.timestamp)
  return _internal_mutable_timestamp();
}

// -------------------------------------------------------------------

// AttachmentPointer

// required fixed64 id = 1;
inline bool AttachmentPointer::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool AttachmentPointer::has_id() const {
  return _internal_has_id();
}
inline void AttachmentPointer::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint64_t AttachmentPointer::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t AttachmentPointer::id() const {
  // @@protoc_insertion_point(field_get:SessionProtos.AttachmentPointer.id)
  return _internal_id();
}
inline void AttachmentPointer::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.id_ = value;
}
inline void AttachmentPointer::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:SessionProtos.AttachmentPointer.id)
}

// optional string contentType = 2;
inline bool AttachmentPointer::_internal_has_contenttype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AttachmentPointer::has_contenttype() const {
  return _internal_has_contenttype();
}
inline void AttachmentPointer::clear_contenttype() {
  _impl_.contenttype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AttachmentPointer::contenttype() const {
  // @@protoc_insertion_point(field_get:SessionProtos.AttachmentPointer.contentType)
  return _internal_contenttype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AttachmentPointer::set_contenttype(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.contenttype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.AttachmentPointer.contentType)
}
inline std::string* AttachmentPointer::mutable_contenttype() {
  std::string* _s = _internal_mutable_contenttype();
  // @@protoc_insertion_point(field_mutable:SessionProtos.AttachmentPointer.contentType)
  return _s;
}
inline const std::string& AttachmentPointer::_internal_contenttype() const {
  return _impl_.contenttype_.Get();
}
inline void AttachmentPointer::_internal_set_contenttype(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.contenttype_.Set(value, GetArenaForAllocation());
}
inline std::string* AttachmentPointer::_internal_mutable_contenttype() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.contenttype_.Mutable(GetArenaForAllocation());
}
inline std::string* AttachmentPointer::release_contenttype() {
  // @@protoc_insertion_point(field_release:SessionProtos.AttachmentPointer.contentType)
  if (!_internal_has_contenttype()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.contenttype_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contenttype_.IsDefault()) {
    _impl_.contenttype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AttachmentPointer::set_allocated_contenttype(std::string* contenttype) {
  if (contenttype != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.contenttype_.SetAllocated(contenttype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contenttype_.IsDefault()) {
    _impl_.contenttype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.AttachmentPointer.contentType)
}

// optional bytes key = 3;
inline bool AttachmentPointer::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AttachmentPointer::has_key() const {
  return _internal_has_key();
}
inline void AttachmentPointer::clear_key() {
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AttachmentPointer::key() const {
  // @@protoc_insertion_point(field_get:SessionProtos.AttachmentPointer.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AttachmentPointer::set_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.AttachmentPointer.key)
}
inline std::string* AttachmentPointer::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:SessionProtos.AttachmentPointer.key)
  return _s;
}
inline const std::string& AttachmentPointer::_internal_key() const {
  return _impl_.key_.Get();
}
inline void AttachmentPointer::_internal_set_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* AttachmentPointer::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* AttachmentPointer::release_key() {
  // @@protoc_insertion_point(field_release:SessionProtos.AttachmentPointer.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AttachmentPointer::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.AttachmentPointer.key)
}

// optional uint32 size = 4;
inline bool AttachmentPointer::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool AttachmentPointer::has_size() const {
  return _internal_has_size();
}
inline void AttachmentPointer::clear_size() {
  _impl_.size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t AttachmentPointer::_internal_size() const {
  return _impl_.size_;
}
inline uint32_t AttachmentPointer::size() const {
  // @@protoc_insertion_point(field_get:SessionProtos.AttachmentPointer.size)
  return _internal_size();
}
inline void AttachmentPointer::_internal_set_size(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.size_ = value;
}
inline void AttachmentPointer::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:SessionProtos.AttachmentPointer.size)
}

// optional bytes thumbnail = 5;
inline bool AttachmentPointer::_internal_has_thumbnail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AttachmentPointer::has_thumbnail() const {
  return _internal_has_thumbnail();
}
inline void AttachmentPointer::clear_thumbnail() {
  _impl_.thumbnail_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AttachmentPointer::thumbnail() const {
  // @@protoc_insertion_point(field_get:SessionProtos.AttachmentPointer.thumbnail)
  return _internal_thumbnail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AttachmentPointer::set_thumbnail(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.thumbnail_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.AttachmentPointer.thumbnail)
}
inline std::string* AttachmentPointer::mutable_thumbnail() {
  std::string* _s = _internal_mutable_thumbnail();
  // @@protoc_insertion_point(field_mutable:SessionProtos.AttachmentPointer.thumbnail)
  return _s;
}
inline const std::string& AttachmentPointer::_internal_thumbnail() const {
  return _impl_.thumbnail_.Get();
}
inline void AttachmentPointer::_internal_set_thumbnail(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.thumbnail_.Set(value, GetArenaForAllocation());
}
inline std::string* AttachmentPointer::_internal_mutable_thumbnail() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.thumbnail_.Mutable(GetArenaForAllocation());
}
inline std::string* AttachmentPointer::release_thumbnail() {
  // @@protoc_insertion_point(field_release:SessionProtos.AttachmentPointer.thumbnail)
  if (!_internal_has_thumbnail()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.thumbnail_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnail_.IsDefault()) {
    _impl_.thumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AttachmentPointer::set_allocated_thumbnail(std::string* thumbnail) {
  if (thumbnail != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.thumbnail_.SetAllocated(thumbnail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnail_.IsDefault()) {
    _impl_.thumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.AttachmentPointer.thumbnail)
}

// optional bytes digest = 6;
inline bool AttachmentPointer::_internal_has_digest() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AttachmentPointer::has_digest() const {
  return _internal_has_digest();
}
inline void AttachmentPointer::clear_digest() {
  _impl_.digest_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AttachmentPointer::digest() const {
  // @@protoc_insertion_point(field_get:SessionProtos.AttachmentPointer.digest)
  return _internal_digest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AttachmentPointer::set_digest(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.digest_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.AttachmentPointer.digest)
}
inline std::string* AttachmentPointer::mutable_digest() {
  std::string* _s = _internal_mutable_digest();
  // @@protoc_insertion_point(field_mutable:SessionProtos.AttachmentPointer.digest)
  return _s;
}
inline const std::string& AttachmentPointer::_internal_digest() const {
  return _impl_.digest_.Get();
}
inline void AttachmentPointer::_internal_set_digest(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.digest_.Set(value, GetArenaForAllocation());
}
inline std::string* AttachmentPointer::_internal_mutable_digest() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.digest_.Mutable(GetArenaForAllocation());
}
inline std::string* AttachmentPointer::release_digest() {
  // @@protoc_insertion_point(field_release:SessionProtos.AttachmentPointer.digest)
  if (!_internal_has_digest()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.digest_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.digest_.IsDefault()) {
    _impl_.digest_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AttachmentPointer::set_allocated_digest(std::string* digest) {
  if (digest != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.digest_.SetAllocated(digest, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.digest_.IsDefault()) {
    _impl_.digest_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.AttachmentPointer.digest)
}

// optional string fileName = 7;
inline bool AttachmentPointer::_internal_has_filename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AttachmentPointer::has_filename() const {
  return _internal_has_filename();
}
inline void AttachmentPointer::clear_filename() {
  _impl_.filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& AttachmentPointer::filename() const {
  // @@protoc_insertion_point(field_get:SessionProtos.AttachmentPointer.fileName)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AttachmentPointer::set_filename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.AttachmentPointer.fileName)
}
inline std::string* AttachmentPointer::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:SessionProtos.AttachmentPointer.fileName)
  return _s;
}
inline const std::string& AttachmentPointer::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void AttachmentPointer::_internal_set_filename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* AttachmentPointer::_internal_mutable_filename() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* AttachmentPointer::release_filename() {
  // @@protoc_insertion_point(field_release:SessionProtos.AttachmentPointer.fileName)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.filename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AttachmentPointer::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.AttachmentPointer.fileName)
}

// optional uint32 flags = 8;
inline bool AttachmentPointer::_internal_has_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool AttachmentPointer::has_flags() const {
  return _internal_has_flags();
}
inline void AttachmentPointer::clear_flags() {
  _impl_.flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t AttachmentPointer::_internal_flags() const {
  return _impl_.flags_;
}
inline uint32_t AttachmentPointer::flags() const {
  // @@protoc_insertion_point(field_get:SessionProtos.AttachmentPointer.flags)
  return _internal_flags();
}
inline void AttachmentPointer::_internal_set_flags(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.flags_ = value;
}
inline void AttachmentPointer::set_flags(uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:SessionProtos.AttachmentPointer.flags)
}

// optional uint32 width = 9;
inline bool AttachmentPointer::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool AttachmentPointer::has_width() const {
  return _internal_has_width();
}
inline void AttachmentPointer::clear_width() {
  _impl_.width_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline uint32_t AttachmentPointer::_internal_width() const {
  return _impl_.width_;
}
inline uint32_t AttachmentPointer::width() const {
  // @@protoc_insertion_point(field_get:SessionProtos.AttachmentPointer.width)
  return _internal_width();
}
inline void AttachmentPointer::_internal_set_width(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.width_ = value;
}
inline void AttachmentPointer::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:SessionProtos.AttachmentPointer.width)
}

// optional uint32 height = 10;
inline bool AttachmentPointer::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool AttachmentPointer::has_height() const {
  return _internal_has_height();
}
inline void AttachmentPointer::clear_height() {
  _impl_.height_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline uint32_t AttachmentPointer::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t AttachmentPointer::height() const {
  // @@protoc_insertion_point(field_get:SessionProtos.AttachmentPointer.height)
  return _internal_height();
}
inline void AttachmentPointer::_internal_set_height(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.height_ = value;
}
inline void AttachmentPointer::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:SessionProtos.AttachmentPointer.height)
}

// optional string caption = 11;
inline bool AttachmentPointer::_internal_has_caption() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool AttachmentPointer::has_caption() const {
  return _internal_has_caption();
}
inline void AttachmentPointer::clear_caption() {
  _impl_.caption_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& AttachmentPointer::caption() const {
  // @@protoc_insertion_point(field_get:SessionProtos.AttachmentPointer.caption)
  return _internal_caption();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AttachmentPointer::set_caption(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.caption_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.AttachmentPointer.caption)
}
inline std::string* AttachmentPointer::mutable_caption() {
  std::string* _s = _internal_mutable_caption();
  // @@protoc_insertion_point(field_mutable:SessionProtos.AttachmentPointer.caption)
  return _s;
}
inline const std::string& AttachmentPointer::_internal_caption() const {
  return _impl_.caption_.Get();
}
inline void AttachmentPointer::_internal_set_caption(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.caption_.Set(value, GetArenaForAllocation());
}
inline std::string* AttachmentPointer::_internal_mutable_caption() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.caption_.Mutable(GetArenaForAllocation());
}
inline std::string* AttachmentPointer::release_caption() {
  // @@protoc_insertion_point(field_release:SessionProtos.AttachmentPointer.caption)
  if (!_internal_has_caption()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.caption_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.caption_.IsDefault()) {
    _impl_.caption_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AttachmentPointer::set_allocated_caption(std::string* caption) {
  if (caption != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.caption_.SetAllocated(caption, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.caption_.IsDefault()) {
    _impl_.caption_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.AttachmentPointer.caption)
}

// optional string url = 101;
inline bool AttachmentPointer::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool AttachmentPointer::has_url() const {
  return _internal_has_url();
}
inline void AttachmentPointer::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& AttachmentPointer::url() const {
  // @@protoc_insertion_point(field_get:SessionProtos.AttachmentPointer.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AttachmentPointer::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.AttachmentPointer.url)
}
inline std::string* AttachmentPointer::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:SessionProtos.AttachmentPointer.url)
  return _s;
}
inline const std::string& AttachmentPointer::_internal_url() const {
  return _impl_.url_.Get();
}
inline void AttachmentPointer::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* AttachmentPointer::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* AttachmentPointer::release_url() {
  // @@protoc_insertion_point(field_release:SessionProtos.AttachmentPointer.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AttachmentPointer::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.AttachmentPointer.url)
}

// -------------------------------------------------------------------

// SharedConfigMessage

// required .SessionProtos.SharedConfigMessage.Kind kind = 1;
inline bool SharedConfigMessage::_internal_has_kind() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SharedConfigMessage::has_kind() const {
  return _internal_has_kind();
}
inline void SharedConfigMessage::clear_kind() {
  _impl_.kind_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::SessionProtos::SharedConfigMessage_Kind SharedConfigMessage::_internal_kind() const {
  return static_cast< ::SessionProtos::SharedConfigMessage_Kind >(_impl_.kind_);
}
inline ::SessionProtos::SharedConfigMessage_Kind SharedConfigMessage::kind() const {
  // @@protoc_insertion_point(field_get:SessionProtos.SharedConfigMessage.kind)
  return _internal_kind();
}
inline void SharedConfigMessage::_internal_set_kind(::SessionProtos::SharedConfigMessage_Kind value) {
  assert(::SessionProtos::SharedConfigMessage_Kind_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.kind_ = value;
}
inline void SharedConfigMessage::set_kind(::SessionProtos::SharedConfigMessage_Kind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:SessionProtos.SharedConfigMessage.kind)
}

// required int64 seqno = 2;
inline bool SharedConfigMessage::_internal_has_seqno() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SharedConfigMessage::has_seqno() const {
  return _internal_has_seqno();
}
inline void SharedConfigMessage::clear_seqno() {
  _impl_.seqno_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t SharedConfigMessage::_internal_seqno() const {
  return _impl_.seqno_;
}
inline int64_t SharedConfigMessage::seqno() const {
  // @@protoc_insertion_point(field_get:SessionProtos.SharedConfigMessage.seqno)
  return _internal_seqno();
}
inline void SharedConfigMessage::_internal_set_seqno(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.seqno_ = value;
}
inline void SharedConfigMessage::set_seqno(int64_t value) {
  _internal_set_seqno(value);
  // @@protoc_insertion_point(field_set:SessionProtos.SharedConfigMessage.seqno)
}

// required bytes data = 3;
inline bool SharedConfigMessage::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SharedConfigMessage::has_data() const {
  return _internal_has_data();
}
inline void SharedConfigMessage::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SharedConfigMessage::data() const {
  // @@protoc_insertion_point(field_get:SessionProtos.SharedConfigMessage.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SharedConfigMessage::set_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SessionProtos.SharedConfigMessage.data)
}
inline std::string* SharedConfigMessage::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:SessionProtos.SharedConfigMessage.data)
  return _s;
}
inline const std::string& SharedConfigMessage::_internal_data() const {
  return _impl_.data_.Get();
}
inline void SharedConfigMessage::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* SharedConfigMessage::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* SharedConfigMessage::release_data() {
  // @@protoc_insertion_point(field_release:SessionProtos.SharedConfigMessage.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SharedConfigMessage::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SessionProtos.SharedConfigMessage.data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SessionProtos

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::SessionProtos::Envelope_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::SessionProtos::TypingMessage_Action> : ::std::true_type {};
template <> struct is_proto_enum< ::SessionProtos::CallMessage_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::SessionProtos::DataExtractionNotification_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::SessionProtos::DataMessage_Quote_QuotedAttachment_Flags> : ::std::true_type {};
template <> struct is_proto_enum< ::SessionProtos::DataMessage_Reaction_Action> : ::std::true_type {};
template <> struct is_proto_enum< ::SessionProtos::DataMessage_ClosedGroupControlMessage_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::SessionProtos::DataMessage_Flags> : ::std::true_type {};
template <> struct is_proto_enum< ::SessionProtos::ReceiptMessage_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::SessionProtos::AttachmentPointer_Flags> : ::std::true_type {};
template <> struct is_proto_enum< ::SessionProtos::SharedConfigMessage_Kind> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_SessionProtos_2eproto
