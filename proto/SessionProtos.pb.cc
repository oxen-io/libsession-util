// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SessionProtos.proto

#include "SessionProtos.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace SessionProtos {
PROTOBUF_CONSTEXPR Envelope::Envelope(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.source_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.content_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.timestamp_)*/uint64_t{0u}
  , /*decltype(_impl_.servertimestamp_)*/uint64_t{0u}
  , /*decltype(_impl_.sourcedevice_)*/0u
  , /*decltype(_impl_.type_)*/6} {}
struct EnvelopeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EnvelopeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EnvelopeDefaultTypeInternal() {}
  union {
    Envelope _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EnvelopeDefaultTypeInternal _Envelope_default_instance_;
PROTOBUF_CONSTEXPR TypingMessage::TypingMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.timestamp_)*/uint64_t{0u}
  , /*decltype(_impl_.action_)*/0} {}
struct TypingMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TypingMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TypingMessageDefaultTypeInternal() {}
  union {
    TypingMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TypingMessageDefaultTypeInternal _TypingMessage_default_instance_;
PROTOBUF_CONSTEXPR UnsendRequest::UnsendRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.author_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.timestamp_)*/uint64_t{0u}} {}
struct UnsendRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UnsendRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UnsendRequestDefaultTypeInternal() {}
  union {
    UnsendRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UnsendRequestDefaultTypeInternal _UnsendRequest_default_instance_;
PROTOBUF_CONSTEXPR MessageRequestResponse::MessageRequestResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.profilekey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.profile_)*/nullptr
  , /*decltype(_impl_.isapproved_)*/false} {}
struct MessageRequestResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MessageRequestResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MessageRequestResponseDefaultTypeInternal() {}
  union {
    MessageRequestResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MessageRequestResponseDefaultTypeInternal _MessageRequestResponse_default_instance_;
PROTOBUF_CONSTEXPR Content::Content(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.datamessage_)*/nullptr
  , /*decltype(_impl_.callmessage_)*/nullptr
  , /*decltype(_impl_.receiptmessage_)*/nullptr
  , /*decltype(_impl_.typingmessage_)*/nullptr
  , /*decltype(_impl_.configurationmessage_)*/nullptr
  , /*decltype(_impl_.dataextractionnotification_)*/nullptr
  , /*decltype(_impl_.unsendrequest_)*/nullptr
  , /*decltype(_impl_.messagerequestresponse_)*/nullptr
  , /*decltype(_impl_.sharedconfigmessage_)*/nullptr} {}
struct ContentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContentDefaultTypeInternal() {}
  union {
    Content _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContentDefaultTypeInternal _Content_default_instance_;
PROTOBUF_CONSTEXPR CallMessage::CallMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sdps_)*/{}
  , /*decltype(_impl_.sdpmlineindexes_)*/{}
  , /*decltype(_impl_.sdpmids_)*/{}
  , /*decltype(_impl_.uuid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/6} {}
struct CallMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CallMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CallMessageDefaultTypeInternal() {}
  union {
    CallMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CallMessageDefaultTypeInternal _CallMessage_default_instance_;
PROTOBUF_CONSTEXPR KeyPair::KeyPair(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.publickey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.privatekey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct KeyPairDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeyPairDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeyPairDefaultTypeInternal() {}
  union {
    KeyPair _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyPairDefaultTypeInternal _KeyPair_default_instance_;
PROTOBUF_CONSTEXPR DataExtractionNotification::DataExtractionNotification(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.timestamp_)*/uint64_t{0u}
  , /*decltype(_impl_.type_)*/1} {}
struct DataExtractionNotificationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DataExtractionNotificationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DataExtractionNotificationDefaultTypeInternal() {}
  union {
    DataExtractionNotification _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DataExtractionNotificationDefaultTypeInternal _DataExtractionNotification_default_instance_;
PROTOBUF_CONSTEXPR LokiProfile::LokiProfile(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.displayname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.profilepicture_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct LokiProfileDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LokiProfileDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LokiProfileDefaultTypeInternal() {}
  union {
    LokiProfile _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LokiProfileDefaultTypeInternal _LokiProfile_default_instance_;
PROTOBUF_CONSTEXPR DataMessage_Quote_QuotedAttachment::DataMessage_Quote_QuotedAttachment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.contenttype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.filename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.thumbnail_)*/nullptr
  , /*decltype(_impl_.flags_)*/0u} {}
struct DataMessage_Quote_QuotedAttachmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DataMessage_Quote_QuotedAttachmentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DataMessage_Quote_QuotedAttachmentDefaultTypeInternal() {}
  union {
    DataMessage_Quote_QuotedAttachment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DataMessage_Quote_QuotedAttachmentDefaultTypeInternal _DataMessage_Quote_QuotedAttachment_default_instance_;
PROTOBUF_CONSTEXPR DataMessage_Quote::DataMessage_Quote(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attachments_)*/{}
  , /*decltype(_impl_.author_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/uint64_t{0u}} {}
struct DataMessage_QuoteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DataMessage_QuoteDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DataMessage_QuoteDefaultTypeInternal() {}
  union {
    DataMessage_Quote _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DataMessage_QuoteDefaultTypeInternal _DataMessage_Quote_default_instance_;
PROTOBUF_CONSTEXPR DataMessage_Preview::DataMessage_Preview(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.image_)*/nullptr} {}
struct DataMessage_PreviewDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DataMessage_PreviewDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DataMessage_PreviewDefaultTypeInternal() {}
  union {
    DataMessage_Preview _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DataMessage_PreviewDefaultTypeInternal _DataMessage_Preview_default_instance_;
PROTOBUF_CONSTEXPR DataMessage_Reaction::DataMessage_Reaction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.author_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.emoji_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_.action_)*/0} {}
struct DataMessage_ReactionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DataMessage_ReactionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DataMessage_ReactionDefaultTypeInternal() {}
  union {
    DataMessage_Reaction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DataMessage_ReactionDefaultTypeInternal _DataMessage_Reaction_default_instance_;
PROTOBUF_CONSTEXPR DataMessage_OpenGroupInvitation::DataMessage_OpenGroupInvitation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DataMessage_OpenGroupInvitationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DataMessage_OpenGroupInvitationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DataMessage_OpenGroupInvitationDefaultTypeInternal() {}
  union {
    DataMessage_OpenGroupInvitation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DataMessage_OpenGroupInvitationDefaultTypeInternal _DataMessage_OpenGroupInvitation_default_instance_;
PROTOBUF_CONSTEXPR DataMessage_ClosedGroupControlMessage_KeyPairWrapper::DataMessage_ClosedGroupControlMessage_KeyPairWrapper(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.publickey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.encryptedkeypair_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DataMessage_ClosedGroupControlMessage_KeyPairWrapperDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DataMessage_ClosedGroupControlMessage_KeyPairWrapperDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DataMessage_ClosedGroupControlMessage_KeyPairWrapperDefaultTypeInternal() {}
  union {
    DataMessage_ClosedGroupControlMessage_KeyPairWrapper _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DataMessage_ClosedGroupControlMessage_KeyPairWrapperDefaultTypeInternal _DataMessage_ClosedGroupControlMessage_KeyPairWrapper_default_instance_;
PROTOBUF_CONSTEXPR DataMessage_ClosedGroupControlMessage::DataMessage_ClosedGroupControlMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.members_)*/{}
  , /*decltype(_impl_.admins_)*/{}
  , /*decltype(_impl_.wrappers_)*/{}
  , /*decltype(_impl_.publickey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.encryptionkeypair_)*/nullptr
  , /*decltype(_impl_.expirationtimer_)*/0u
  , /*decltype(_impl_.type_)*/1} {}
struct DataMessage_ClosedGroupControlMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DataMessage_ClosedGroupControlMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DataMessage_ClosedGroupControlMessageDefaultTypeInternal() {}
  union {
    DataMessage_ClosedGroupControlMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DataMessage_ClosedGroupControlMessageDefaultTypeInternal _DataMessage_ClosedGroupControlMessage_default_instance_;
PROTOBUF_CONSTEXPR DataMessage::DataMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attachments_)*/{}
  , /*decltype(_impl_.preview_)*/{}
  , /*decltype(_impl_.body_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.profilekey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.synctarget_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.quote_)*/nullptr
  , /*decltype(_impl_.reaction_)*/nullptr
  , /*decltype(_impl_.profile_)*/nullptr
  , /*decltype(_impl_.opengroupinvitation_)*/nullptr
  , /*decltype(_impl_.closedgroupcontrolmessage_)*/nullptr
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.expiretimer_)*/0u
  , /*decltype(_impl_.timestamp_)*/uint64_t{0u}
  , /*decltype(_impl_.blockscommunitymessagerequests_)*/false} {}
struct DataMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DataMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DataMessageDefaultTypeInternal() {}
  union {
    DataMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DataMessageDefaultTypeInternal _DataMessage_default_instance_;
PROTOBUF_CONSTEXPR ConfigurationMessage_ClosedGroup::ConfigurationMessage_ClosedGroup(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.members_)*/{}
  , /*decltype(_impl_.admins_)*/{}
  , /*decltype(_impl_.publickey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.encryptionkeypair_)*/nullptr
  , /*decltype(_impl_.expirationtimer_)*/0u} {}
struct ConfigurationMessage_ClosedGroupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfigurationMessage_ClosedGroupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfigurationMessage_ClosedGroupDefaultTypeInternal() {}
  union {
    ConfigurationMessage_ClosedGroup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigurationMessage_ClosedGroupDefaultTypeInternal _ConfigurationMessage_ClosedGroup_default_instance_;
PROTOBUF_CONSTEXPR ConfigurationMessage_Contact::ConfigurationMessage_Contact(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.publickey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.profilepicture_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.profilekey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.isapproved_)*/false
  , /*decltype(_impl_.isblocked_)*/false
  , /*decltype(_impl_.didapproveme_)*/false} {}
struct ConfigurationMessage_ContactDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfigurationMessage_ContactDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfigurationMessage_ContactDefaultTypeInternal() {}
  union {
    ConfigurationMessage_Contact _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigurationMessage_ContactDefaultTypeInternal _ConfigurationMessage_Contact_default_instance_;
PROTOBUF_CONSTEXPR ConfigurationMessage::ConfigurationMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.closedgroups_)*/{}
  , /*decltype(_impl_.opengroups_)*/{}
  , /*decltype(_impl_.contacts_)*/{}
  , /*decltype(_impl_.displayname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.profilepicture_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.profilekey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ConfigurationMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfigurationMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfigurationMessageDefaultTypeInternal() {}
  union {
    ConfigurationMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigurationMessageDefaultTypeInternal _ConfigurationMessage_default_instance_;
PROTOBUF_CONSTEXPR ReceiptMessage::ReceiptMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.timestamp_)*/{}
  , /*decltype(_impl_.type_)*/0} {}
struct ReceiptMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReceiptMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReceiptMessageDefaultTypeInternal() {}
  union {
    ReceiptMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReceiptMessageDefaultTypeInternal _ReceiptMessage_default_instance_;
PROTOBUF_CONSTEXPR AttachmentPointer::AttachmentPointer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.contenttype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.thumbnail_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.digest_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.filename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.caption_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_.size_)*/0u
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.width_)*/0u
  , /*decltype(_impl_.height_)*/0u} {}
struct AttachmentPointerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AttachmentPointerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AttachmentPointerDefaultTypeInternal() {}
  union {
    AttachmentPointer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AttachmentPointerDefaultTypeInternal _AttachmentPointer_default_instance_;
PROTOBUF_CONSTEXPR SharedConfigMessage::SharedConfigMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.seqno_)*/int64_t{0}
  , /*decltype(_impl_.kind_)*/1} {}
struct SharedConfigMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SharedConfigMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SharedConfigMessageDefaultTypeInternal() {}
  union {
    SharedConfigMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SharedConfigMessageDefaultTypeInternal _SharedConfigMessage_default_instance_;
}  // namespace SessionProtos
namespace SessionProtos {
bool Envelope_Type_IsValid(int value) {
  switch (value) {
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Envelope_Type_strings[2] = {};

static const char Envelope_Type_names[] =
  "CLOSED_GROUP_MESSAGE"
  "SESSION_MESSAGE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Envelope_Type_entries[] = {
  { {Envelope_Type_names + 0, 20}, 7 },
  { {Envelope_Type_names + 20, 15}, 6 },
};

static const int Envelope_Type_entries_by_number[] = {
  1, // 6 -> SESSION_MESSAGE
  0, // 7 -> CLOSED_GROUP_MESSAGE
};

const std::string& Envelope_Type_Name(
    Envelope_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Envelope_Type_entries,
          Envelope_Type_entries_by_number,
          2, Envelope_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Envelope_Type_entries,
      Envelope_Type_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Envelope_Type_strings[idx].get();
}
bool Envelope_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Envelope_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Envelope_Type_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<Envelope_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Envelope_Type Envelope::SESSION_MESSAGE;
constexpr Envelope_Type Envelope::CLOSED_GROUP_MESSAGE;
constexpr Envelope_Type Envelope::Type_MIN;
constexpr Envelope_Type Envelope::Type_MAX;
constexpr int Envelope::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TypingMessage_Action_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TypingMessage_Action_strings[2] = {};

static const char TypingMessage_Action_names[] =
  "STARTED"
  "STOPPED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TypingMessage_Action_entries[] = {
  { {TypingMessage_Action_names + 0, 7}, 0 },
  { {TypingMessage_Action_names + 7, 7}, 1 },
};

static const int TypingMessage_Action_entries_by_number[] = {
  0, // 0 -> STARTED
  1, // 1 -> STOPPED
};

const std::string& TypingMessage_Action_Name(
    TypingMessage_Action value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TypingMessage_Action_entries,
          TypingMessage_Action_entries_by_number,
          2, TypingMessage_Action_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TypingMessage_Action_entries,
      TypingMessage_Action_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TypingMessage_Action_strings[idx].get();
}
bool TypingMessage_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TypingMessage_Action* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TypingMessage_Action_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<TypingMessage_Action>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TypingMessage_Action TypingMessage::STARTED;
constexpr TypingMessage_Action TypingMessage::STOPPED;
constexpr TypingMessage_Action TypingMessage::Action_MIN;
constexpr TypingMessage_Action TypingMessage::Action_MAX;
constexpr int TypingMessage::Action_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CallMessage_Type_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CallMessage_Type_strings[6] = {};

static const char CallMessage_Type_names[] =
  "ANSWER"
  "END_CALL"
  "ICE_CANDIDATES"
  "OFFER"
  "PRE_OFFER"
  "PROVISIONAL_ANSWER";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CallMessage_Type_entries[] = {
  { {CallMessage_Type_names + 0, 6}, 2 },
  { {CallMessage_Type_names + 6, 8}, 5 },
  { {CallMessage_Type_names + 14, 14}, 4 },
  { {CallMessage_Type_names + 28, 5}, 1 },
  { {CallMessage_Type_names + 33, 9}, 6 },
  { {CallMessage_Type_names + 42, 18}, 3 },
};

static const int CallMessage_Type_entries_by_number[] = {
  3, // 1 -> OFFER
  0, // 2 -> ANSWER
  5, // 3 -> PROVISIONAL_ANSWER
  2, // 4 -> ICE_CANDIDATES
  1, // 5 -> END_CALL
  4, // 6 -> PRE_OFFER
};

const std::string& CallMessage_Type_Name(
    CallMessage_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CallMessage_Type_entries,
          CallMessage_Type_entries_by_number,
          6, CallMessage_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CallMessage_Type_entries,
      CallMessage_Type_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CallMessage_Type_strings[idx].get();
}
bool CallMessage_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CallMessage_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CallMessage_Type_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<CallMessage_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CallMessage_Type CallMessage::PRE_OFFER;
constexpr CallMessage_Type CallMessage::OFFER;
constexpr CallMessage_Type CallMessage::ANSWER;
constexpr CallMessage_Type CallMessage::PROVISIONAL_ANSWER;
constexpr CallMessage_Type CallMessage::ICE_CANDIDATES;
constexpr CallMessage_Type CallMessage::END_CALL;
constexpr CallMessage_Type CallMessage::Type_MIN;
constexpr CallMessage_Type CallMessage::Type_MAX;
constexpr int CallMessage::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DataExtractionNotification_Type_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DataExtractionNotification_Type_strings[2] = {};

static const char DataExtractionNotification_Type_names[] =
  "MEDIA_SAVED"
  "SCREENSHOT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DataExtractionNotification_Type_entries[] = {
  { {DataExtractionNotification_Type_names + 0, 11}, 2 },
  { {DataExtractionNotification_Type_names + 11, 10}, 1 },
};

static const int DataExtractionNotification_Type_entries_by_number[] = {
  1, // 1 -> SCREENSHOT
  0, // 2 -> MEDIA_SAVED
};

const std::string& DataExtractionNotification_Type_Name(
    DataExtractionNotification_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DataExtractionNotification_Type_entries,
          DataExtractionNotification_Type_entries_by_number,
          2, DataExtractionNotification_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DataExtractionNotification_Type_entries,
      DataExtractionNotification_Type_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DataExtractionNotification_Type_strings[idx].get();
}
bool DataExtractionNotification_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataExtractionNotification_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DataExtractionNotification_Type_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<DataExtractionNotification_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DataExtractionNotification_Type DataExtractionNotification::SCREENSHOT;
constexpr DataExtractionNotification_Type DataExtractionNotification::MEDIA_SAVED;
constexpr DataExtractionNotification_Type DataExtractionNotification::Type_MIN;
constexpr DataExtractionNotification_Type DataExtractionNotification::Type_MAX;
constexpr int DataExtractionNotification::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DataMessage_Quote_QuotedAttachment_Flags_IsValid(int value) {
  switch (value) {
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DataMessage_Quote_QuotedAttachment_Flags_strings[1] = {};

static const char DataMessage_Quote_QuotedAttachment_Flags_names[] =
  "VOICE_MESSAGE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DataMessage_Quote_QuotedAttachment_Flags_entries[] = {
  { {DataMessage_Quote_QuotedAttachment_Flags_names + 0, 13}, 1 },
};

static const int DataMessage_Quote_QuotedAttachment_Flags_entries_by_number[] = {
  0, // 1 -> VOICE_MESSAGE
};

const std::string& DataMessage_Quote_QuotedAttachment_Flags_Name(
    DataMessage_Quote_QuotedAttachment_Flags value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DataMessage_Quote_QuotedAttachment_Flags_entries,
          DataMessage_Quote_QuotedAttachment_Flags_entries_by_number,
          1, DataMessage_Quote_QuotedAttachment_Flags_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DataMessage_Quote_QuotedAttachment_Flags_entries,
      DataMessage_Quote_QuotedAttachment_Flags_entries_by_number,
      1, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DataMessage_Quote_QuotedAttachment_Flags_strings[idx].get();
}
bool DataMessage_Quote_QuotedAttachment_Flags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataMessage_Quote_QuotedAttachment_Flags* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DataMessage_Quote_QuotedAttachment_Flags_entries, 1, name, &int_value);
  if (success) {
    *value = static_cast<DataMessage_Quote_QuotedAttachment_Flags>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DataMessage_Quote_QuotedAttachment_Flags DataMessage_Quote_QuotedAttachment::VOICE_MESSAGE;
constexpr DataMessage_Quote_QuotedAttachment_Flags DataMessage_Quote_QuotedAttachment::Flags_MIN;
constexpr DataMessage_Quote_QuotedAttachment_Flags DataMessage_Quote_QuotedAttachment::Flags_MAX;
constexpr int DataMessage_Quote_QuotedAttachment::Flags_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DataMessage_Reaction_Action_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DataMessage_Reaction_Action_strings[2] = {};

static const char DataMessage_Reaction_Action_names[] =
  "REACT"
  "REMOVE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DataMessage_Reaction_Action_entries[] = {
  { {DataMessage_Reaction_Action_names + 0, 5}, 0 },
  { {DataMessage_Reaction_Action_names + 5, 6}, 1 },
};

static const int DataMessage_Reaction_Action_entries_by_number[] = {
  0, // 0 -> REACT
  1, // 1 -> REMOVE
};

const std::string& DataMessage_Reaction_Action_Name(
    DataMessage_Reaction_Action value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DataMessage_Reaction_Action_entries,
          DataMessage_Reaction_Action_entries_by_number,
          2, DataMessage_Reaction_Action_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DataMessage_Reaction_Action_entries,
      DataMessage_Reaction_Action_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DataMessage_Reaction_Action_strings[idx].get();
}
bool DataMessage_Reaction_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataMessage_Reaction_Action* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DataMessage_Reaction_Action_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<DataMessage_Reaction_Action>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DataMessage_Reaction_Action DataMessage_Reaction::REACT;
constexpr DataMessage_Reaction_Action DataMessage_Reaction::REMOVE;
constexpr DataMessage_Reaction_Action DataMessage_Reaction::Action_MIN;
constexpr DataMessage_Reaction_Action DataMessage_Reaction::Action_MAX;
constexpr int DataMessage_Reaction::Action_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DataMessage_ClosedGroupControlMessage_Type_IsValid(int value) {
  switch (value) {
    case 1:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DataMessage_ClosedGroupControlMessage_Type_strings[7] = {};

static const char DataMessage_ClosedGroupControlMessage_Type_names[] =
  "ENCRYPTION_KEY_PAIR"
  "ENCRYPTION_KEY_PAIR_REQUEST"
  "MEMBERS_ADDED"
  "MEMBERS_REMOVED"
  "MEMBER_LEFT"
  "NAME_CHANGE"
  "NEW";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DataMessage_ClosedGroupControlMessage_Type_entries[] = {
  { {DataMessage_ClosedGroupControlMessage_Type_names + 0, 19}, 3 },
  { {DataMessage_ClosedGroupControlMessage_Type_names + 19, 27}, 8 },
  { {DataMessage_ClosedGroupControlMessage_Type_names + 46, 13}, 5 },
  { {DataMessage_ClosedGroupControlMessage_Type_names + 59, 15}, 6 },
  { {DataMessage_ClosedGroupControlMessage_Type_names + 74, 11}, 7 },
  { {DataMessage_ClosedGroupControlMessage_Type_names + 85, 11}, 4 },
  { {DataMessage_ClosedGroupControlMessage_Type_names + 96, 3}, 1 },
};

static const int DataMessage_ClosedGroupControlMessage_Type_entries_by_number[] = {
  6, // 1 -> NEW
  0, // 3 -> ENCRYPTION_KEY_PAIR
  5, // 4 -> NAME_CHANGE
  2, // 5 -> MEMBERS_ADDED
  3, // 6 -> MEMBERS_REMOVED
  4, // 7 -> MEMBER_LEFT
  1, // 8 -> ENCRYPTION_KEY_PAIR_REQUEST
};

const std::string& DataMessage_ClosedGroupControlMessage_Type_Name(
    DataMessage_ClosedGroupControlMessage_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DataMessage_ClosedGroupControlMessage_Type_entries,
          DataMessage_ClosedGroupControlMessage_Type_entries_by_number,
          7, DataMessage_ClosedGroupControlMessage_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DataMessage_ClosedGroupControlMessage_Type_entries,
      DataMessage_ClosedGroupControlMessage_Type_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DataMessage_ClosedGroupControlMessage_Type_strings[idx].get();
}
bool DataMessage_ClosedGroupControlMessage_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataMessage_ClosedGroupControlMessage_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DataMessage_ClosedGroupControlMessage_Type_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<DataMessage_ClosedGroupControlMessage_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DataMessage_ClosedGroupControlMessage_Type DataMessage_ClosedGroupControlMessage::NEW;
constexpr DataMessage_ClosedGroupControlMessage_Type DataMessage_ClosedGroupControlMessage::ENCRYPTION_KEY_PAIR;
constexpr DataMessage_ClosedGroupControlMessage_Type DataMessage_ClosedGroupControlMessage::NAME_CHANGE;
constexpr DataMessage_ClosedGroupControlMessage_Type DataMessage_ClosedGroupControlMessage::MEMBERS_ADDED;
constexpr DataMessage_ClosedGroupControlMessage_Type DataMessage_ClosedGroupControlMessage::MEMBERS_REMOVED;
constexpr DataMessage_ClosedGroupControlMessage_Type DataMessage_ClosedGroupControlMessage::MEMBER_LEFT;
constexpr DataMessage_ClosedGroupControlMessage_Type DataMessage_ClosedGroupControlMessage::ENCRYPTION_KEY_PAIR_REQUEST;
constexpr DataMessage_ClosedGroupControlMessage_Type DataMessage_ClosedGroupControlMessage::Type_MIN;
constexpr DataMessage_ClosedGroupControlMessage_Type DataMessage_ClosedGroupControlMessage::Type_MAX;
constexpr int DataMessage_ClosedGroupControlMessage::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DataMessage_Flags_IsValid(int value) {
  switch (value) {
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DataMessage_Flags_strings[1] = {};

static const char DataMessage_Flags_names[] =
  "EXPIRATION_TIMER_UPDATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DataMessage_Flags_entries[] = {
  { {DataMessage_Flags_names + 0, 23}, 2 },
};

static const int DataMessage_Flags_entries_by_number[] = {
  0, // 2 -> EXPIRATION_TIMER_UPDATE
};

const std::string& DataMessage_Flags_Name(
    DataMessage_Flags value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DataMessage_Flags_entries,
          DataMessage_Flags_entries_by_number,
          1, DataMessage_Flags_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DataMessage_Flags_entries,
      DataMessage_Flags_entries_by_number,
      1, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DataMessage_Flags_strings[idx].get();
}
bool DataMessage_Flags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataMessage_Flags* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DataMessage_Flags_entries, 1, name, &int_value);
  if (success) {
    *value = static_cast<DataMessage_Flags>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DataMessage_Flags DataMessage::EXPIRATION_TIMER_UPDATE;
constexpr DataMessage_Flags DataMessage::Flags_MIN;
constexpr DataMessage_Flags DataMessage::Flags_MAX;
constexpr int DataMessage::Flags_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ReceiptMessage_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ReceiptMessage_Type_strings[2] = {};

static const char ReceiptMessage_Type_names[] =
  "DELIVERY"
  "READ";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ReceiptMessage_Type_entries[] = {
  { {ReceiptMessage_Type_names + 0, 8}, 0 },
  { {ReceiptMessage_Type_names + 8, 4}, 1 },
};

static const int ReceiptMessage_Type_entries_by_number[] = {
  0, // 0 -> DELIVERY
  1, // 1 -> READ
};

const std::string& ReceiptMessage_Type_Name(
    ReceiptMessage_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ReceiptMessage_Type_entries,
          ReceiptMessage_Type_entries_by_number,
          2, ReceiptMessage_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ReceiptMessage_Type_entries,
      ReceiptMessage_Type_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ReceiptMessage_Type_strings[idx].get();
}
bool ReceiptMessage_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReceiptMessage_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ReceiptMessage_Type_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<ReceiptMessage_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ReceiptMessage_Type ReceiptMessage::DELIVERY;
constexpr ReceiptMessage_Type ReceiptMessage::READ;
constexpr ReceiptMessage_Type ReceiptMessage::Type_MIN;
constexpr ReceiptMessage_Type ReceiptMessage::Type_MAX;
constexpr int ReceiptMessage::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AttachmentPointer_Flags_IsValid(int value) {
  switch (value) {
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AttachmentPointer_Flags_strings[1] = {};

static const char AttachmentPointer_Flags_names[] =
  "VOICE_MESSAGE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AttachmentPointer_Flags_entries[] = {
  { {AttachmentPointer_Flags_names + 0, 13}, 1 },
};

static const int AttachmentPointer_Flags_entries_by_number[] = {
  0, // 1 -> VOICE_MESSAGE
};

const std::string& AttachmentPointer_Flags_Name(
    AttachmentPointer_Flags value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AttachmentPointer_Flags_entries,
          AttachmentPointer_Flags_entries_by_number,
          1, AttachmentPointer_Flags_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AttachmentPointer_Flags_entries,
      AttachmentPointer_Flags_entries_by_number,
      1, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AttachmentPointer_Flags_strings[idx].get();
}
bool AttachmentPointer_Flags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AttachmentPointer_Flags* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AttachmentPointer_Flags_entries, 1, name, &int_value);
  if (success) {
    *value = static_cast<AttachmentPointer_Flags>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AttachmentPointer_Flags AttachmentPointer::VOICE_MESSAGE;
constexpr AttachmentPointer_Flags AttachmentPointer::Flags_MIN;
constexpr AttachmentPointer_Flags AttachmentPointer::Flags_MAX;
constexpr int AttachmentPointer::Flags_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SharedConfigMessage_Kind_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SharedConfigMessage_Kind_strings[4] = {};

static const char SharedConfigMessage_Kind_names[] =
  "CONTACTS"
  "CONVO_INFO_VOLATILE"
  "USER_GROUPS"
  "USER_PROFILE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SharedConfigMessage_Kind_entries[] = {
  { {SharedConfigMessage_Kind_names + 0, 8}, 2 },
  { {SharedConfigMessage_Kind_names + 8, 19}, 3 },
  { {SharedConfigMessage_Kind_names + 27, 11}, 4 },
  { {SharedConfigMessage_Kind_names + 38, 12}, 1 },
};

static const int SharedConfigMessage_Kind_entries_by_number[] = {
  3, // 1 -> USER_PROFILE
  0, // 2 -> CONTACTS
  1, // 3 -> CONVO_INFO_VOLATILE
  2, // 4 -> USER_GROUPS
};

const std::string& SharedConfigMessage_Kind_Name(
    SharedConfigMessage_Kind value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SharedConfigMessage_Kind_entries,
          SharedConfigMessage_Kind_entries_by_number,
          4, SharedConfigMessage_Kind_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SharedConfigMessage_Kind_entries,
      SharedConfigMessage_Kind_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SharedConfigMessage_Kind_strings[idx].get();
}
bool SharedConfigMessage_Kind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SharedConfigMessage_Kind* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SharedConfigMessage_Kind_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<SharedConfigMessage_Kind>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SharedConfigMessage_Kind SharedConfigMessage::USER_PROFILE;
constexpr SharedConfigMessage_Kind SharedConfigMessage::CONTACTS;
constexpr SharedConfigMessage_Kind SharedConfigMessage::CONVO_INFO_VOLATILE;
constexpr SharedConfigMessage_Kind SharedConfigMessage::USER_GROUPS;
constexpr SharedConfigMessage_Kind SharedConfigMessage::Kind_MIN;
constexpr SharedConfigMessage_Kind SharedConfigMessage::Kind_MAX;
constexpr int SharedConfigMessage::Kind_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class Envelope::_Internal {
 public:
  using HasBits = decltype(std::declval<Envelope>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_source(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sourcedevice(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_content(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_servertimestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000024) ^ 0x00000024) != 0;
  }
};

Envelope::Envelope(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SessionProtos.Envelope)
}
Envelope::Envelope(const Envelope& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Envelope* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.source_){}
    , decltype(_impl_.content_){}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.servertimestamp_){}
    , decltype(_impl_.sourcedevice_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.source_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.source_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_source()) {
    _this->_impl_.source_.Set(from._internal_source(), 
      _this->GetArenaForAllocation());
  }
  _impl_.content_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_content()) {
    _this->_impl_.content_.Set(from._internal_content(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:SessionProtos.Envelope)
}

inline void Envelope::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.source_){}
    , decltype(_impl_.content_){}
    , decltype(_impl_.timestamp_){uint64_t{0u}}
    , decltype(_impl_.servertimestamp_){uint64_t{0u}}
    , decltype(_impl_.sourcedevice_){0u}
    , decltype(_impl_.type_){6}
  };
  _impl_.source_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.source_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.content_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Envelope::~Envelope() {
  // @@protoc_insertion_point(destructor:SessionProtos.Envelope)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Envelope::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.source_.Destroy();
  _impl_.content_.Destroy();
}

void Envelope::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Envelope::Clear() {
// @@protoc_insertion_point(message_clear_start:SessionProtos.Envelope)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.source_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.content_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.sourcedevice_) -
        reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.sourcedevice_));
    _impl_.type_ = 6;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Envelope::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .SessionProtos.Envelope.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SessionProtos::Envelope_Type_IsValid(val))) {
            _internal_set_type(static_cast<::SessionProtos::Envelope_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string source = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_source();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 timestamp = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sourceDevice = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_sourcedevice(&has_bits);
          _impl_.sourcedevice_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes content = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_content();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 serverTimestamp = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_servertimestamp(&has_bits);
          _impl_.servertimestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Envelope::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SessionProtos.Envelope)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .SessionProtos.Envelope.Type type = 1;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional string source = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_source(), target);
  }

  // required uint64 timestamp = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_timestamp(), target);
  }

  // optional uint32 sourceDevice = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_sourcedevice(), target);
  }

  // optional bytes content = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_content(), target);
  }

  // optional uint64 serverTimestamp = 10;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(10, this->_internal_servertimestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SessionProtos.Envelope)
  return target;
}

size_t Envelope::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:SessionProtos.Envelope)
  size_t total_size = 0;

  if (_internal_has_timestamp()) {
    // required uint64 timestamp = 5;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_timestamp());
  }

  if (_internal_has_type()) {
    // required .SessionProtos.Envelope.Type type = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t Envelope::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SessionProtos.Envelope)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000024) ^ 0x00000024) == 0) {  // All required fields are present.
    // required uint64 timestamp = 5;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_timestamp());

    // required .SessionProtos.Envelope.Type type = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string source = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_source());
    }

    // optional bytes content = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_content());
    }

  }
  if (cached_has_bits & 0x00000018u) {
    // optional uint64 serverTimestamp = 10;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_servertimestamp());
    }

    // optional uint32 sourceDevice = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sourcedevice());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Envelope::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Envelope*>(
      &from));
}

void Envelope::MergeFrom(const Envelope& from) {
  Envelope* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:SessionProtos.Envelope)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_source(from._internal_source());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_content(from._internal_content());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.servertimestamp_ = from._impl_.servertimestamp_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.sourcedevice_ = from._impl_.sourcedevice_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Envelope::CopyFrom(const Envelope& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SessionProtos.Envelope)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Envelope::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Envelope::InternalSwap(Envelope* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.source_, lhs_arena,
      &other->_impl_.source_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.content_, lhs_arena,
      &other->_impl_.content_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Envelope, _impl_.sourcedevice_)
      + sizeof(Envelope::_impl_.sourcedevice_)
      - PROTOBUF_FIELD_OFFSET(Envelope, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
  swap(_impl_.type_, other->_impl_.type_);
}

std::string Envelope::GetTypeName() const {
  return "SessionProtos.Envelope";
}


// ===================================================================

class TypingMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<TypingMessage>()._impl_._has_bits_);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_action(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TypingMessage::TypingMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SessionProtos.TypingMessage)
}
TypingMessage::TypingMessage(const TypingMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TypingMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.action_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.action_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.action_));
  // @@protoc_insertion_point(copy_constructor:SessionProtos.TypingMessage)
}

inline void TypingMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){uint64_t{0u}}
    , decltype(_impl_.action_){0}
  };
}

TypingMessage::~TypingMessage() {
  // @@protoc_insertion_point(destructor:SessionProtos.TypingMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TypingMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TypingMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TypingMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:SessionProtos.TypingMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.action_) -
        reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.action_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TypingMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .SessionProtos.TypingMessage.Action action = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SessionProtos::TypingMessage_Action_IsValid(val))) {
            _internal_set_action(static_cast<::SessionProtos::TypingMessage_Action>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TypingMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SessionProtos.TypingMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 timestamp = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_timestamp(), target);
  }

  // required .SessionProtos.TypingMessage.Action action = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_action(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SessionProtos.TypingMessage)
  return target;
}

size_t TypingMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:SessionProtos.TypingMessage)
  size_t total_size = 0;

  if (_internal_has_timestamp()) {
    // required uint64 timestamp = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_timestamp());
  }

  if (_internal_has_action()) {
    // required .SessionProtos.TypingMessage.Action action = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_action());
  }

  return total_size;
}
size_t TypingMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SessionProtos.TypingMessage)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 timestamp = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_timestamp());

    // required .SessionProtos.TypingMessage.Action action = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_action());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TypingMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TypingMessage*>(
      &from));
}

void TypingMessage::MergeFrom(const TypingMessage& from) {
  TypingMessage* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:SessionProtos.TypingMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.action_ = from._impl_.action_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TypingMessage::CopyFrom(const TypingMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SessionProtos.TypingMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TypingMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TypingMessage::InternalSwap(TypingMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TypingMessage, _impl_.action_)
      + sizeof(TypingMessage::_impl_.action_)
      - PROTOBUF_FIELD_OFFSET(TypingMessage, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

std::string TypingMessage::GetTypeName() const {
  return "SessionProtos.TypingMessage";
}


// ===================================================================

class UnsendRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<UnsendRequest>()._impl_._has_bits_);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_author(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

UnsendRequest::UnsendRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SessionProtos.UnsendRequest)
}
UnsendRequest::UnsendRequest(const UnsendRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UnsendRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.author_){}
    , decltype(_impl_.timestamp_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.author_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.author_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_author()) {
    _this->_impl_.author_.Set(from._internal_author(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.timestamp_ = from._impl_.timestamp_;
  // @@protoc_insertion_point(copy_constructor:SessionProtos.UnsendRequest)
}

inline void UnsendRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.author_){}
    , decltype(_impl_.timestamp_){uint64_t{0u}}
  };
  _impl_.author_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.author_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UnsendRequest::~UnsendRequest() {
  // @@protoc_insertion_point(destructor:SessionProtos.UnsendRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UnsendRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.author_.Destroy();
}

void UnsendRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UnsendRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:SessionProtos.UnsendRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.author_.ClearNonDefaultToEmpty();
  }
  _impl_.timestamp_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UnsendRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string author = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_author();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UnsendRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SessionProtos.UnsendRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 timestamp = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_timestamp(), target);
  }

  // required string author = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_author(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SessionProtos.UnsendRequest)
  return target;
}

size_t UnsendRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:SessionProtos.UnsendRequest)
  size_t total_size = 0;

  if (_internal_has_author()) {
    // required string author = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_author());
  }

  if (_internal_has_timestamp()) {
    // required uint64 timestamp = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_timestamp());
  }

  return total_size;
}
size_t UnsendRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SessionProtos.UnsendRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string author = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_author());

    // required uint64 timestamp = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_timestamp());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UnsendRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UnsendRequest*>(
      &from));
}

void UnsendRequest::MergeFrom(const UnsendRequest& from) {
  UnsendRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:SessionProtos.UnsendRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_author(from._internal_author());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UnsendRequest::CopyFrom(const UnsendRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SessionProtos.UnsendRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnsendRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void UnsendRequest::InternalSwap(UnsendRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.author_, lhs_arena,
      &other->_impl_.author_, rhs_arena
  );
  swap(_impl_.timestamp_, other->_impl_.timestamp_);
}

std::string UnsendRequest::GetTypeName() const {
  return "SessionProtos.UnsendRequest";
}


// ===================================================================

class MessageRequestResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<MessageRequestResponse>()._impl_._has_bits_);
  static void set_has_isapproved(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_profilekey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::SessionProtos::LokiProfile& profile(const MessageRequestResponse* msg);
  static void set_has_profile(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000004) ^ 0x00000004) != 0;
  }
};

const ::SessionProtos::LokiProfile&
MessageRequestResponse::_Internal::profile(const MessageRequestResponse* msg) {
  return *msg->_impl_.profile_;
}
MessageRequestResponse::MessageRequestResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SessionProtos.MessageRequestResponse)
}
MessageRequestResponse::MessageRequestResponse(const MessageRequestResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MessageRequestResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.profilekey_){}
    , decltype(_impl_.profile_){nullptr}
    , decltype(_impl_.isapproved_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.profilekey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profilekey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_profilekey()) {
    _this->_impl_.profilekey_.Set(from._internal_profilekey(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_profile()) {
    _this->_impl_.profile_ = new ::SessionProtos::LokiProfile(*from._impl_.profile_);
  }
  _this->_impl_.isapproved_ = from._impl_.isapproved_;
  // @@protoc_insertion_point(copy_constructor:SessionProtos.MessageRequestResponse)
}

inline void MessageRequestResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.profilekey_){}
    , decltype(_impl_.profile_){nullptr}
    , decltype(_impl_.isapproved_){false}
  };
  _impl_.profilekey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profilekey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MessageRequestResponse::~MessageRequestResponse() {
  // @@protoc_insertion_point(destructor:SessionProtos.MessageRequestResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MessageRequestResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.profilekey_.Destroy();
  if (this != internal_default_instance()) delete _impl_.profile_;
}

void MessageRequestResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MessageRequestResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:SessionProtos.MessageRequestResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.profilekey_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.profile_ != nullptr);
      _impl_.profile_->Clear();
    }
  }
  _impl_.isapproved_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MessageRequestResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bool isApproved = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_isapproved(&has_bits);
          _impl_.isapproved_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes profileKey = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_profilekey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SessionProtos.LokiProfile profile = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_profile(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MessageRequestResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SessionProtos.MessageRequestResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bool isApproved = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_isapproved(), target);
  }

  // optional bytes profileKey = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_profilekey(), target);
  }

  // optional .SessionProtos.LokiProfile profile = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::profile(this),
        _Internal::profile(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SessionProtos.MessageRequestResponse)
  return target;
}

size_t MessageRequestResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SessionProtos.MessageRequestResponse)
  size_t total_size = 0;

  // required bool isApproved = 1;
  if (_internal_has_isapproved()) {
    total_size += 1 + 1;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes profileKey = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_profilekey());
    }

    // optional .SessionProtos.LokiProfile profile = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.profile_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MessageRequestResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MessageRequestResponse*>(
      &from));
}

void MessageRequestResponse::MergeFrom(const MessageRequestResponse& from) {
  MessageRequestResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:SessionProtos.MessageRequestResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_profilekey(from._internal_profilekey());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_profile()->::SessionProtos::LokiProfile::MergeFrom(
          from._internal_profile());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.isapproved_ = from._impl_.isapproved_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MessageRequestResponse::CopyFrom(const MessageRequestResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SessionProtos.MessageRequestResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageRequestResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void MessageRequestResponse::InternalSwap(MessageRequestResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.profilekey_, lhs_arena,
      &other->_impl_.profilekey_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MessageRequestResponse, _impl_.isapproved_)
      + sizeof(MessageRequestResponse::_impl_.isapproved_)
      - PROTOBUF_FIELD_OFFSET(MessageRequestResponse, _impl_.profile_)>(
          reinterpret_cast<char*>(&_impl_.profile_),
          reinterpret_cast<char*>(&other->_impl_.profile_));
}

std::string MessageRequestResponse::GetTypeName() const {
  return "SessionProtos.MessageRequestResponse";
}


// ===================================================================

class Content::_Internal {
 public:
  using HasBits = decltype(std::declval<Content>()._impl_._has_bits_);
  static const ::SessionProtos::DataMessage& datamessage(const Content* msg);
  static void set_has_datamessage(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::SessionProtos::CallMessage& callmessage(const Content* msg);
  static void set_has_callmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::SessionProtos::ReceiptMessage& receiptmessage(const Content* msg);
  static void set_has_receiptmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::SessionProtos::TypingMessage& typingmessage(const Content* msg);
  static void set_has_typingmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::SessionProtos::ConfigurationMessage& configurationmessage(const Content* msg);
  static void set_has_configurationmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::SessionProtos::DataExtractionNotification& dataextractionnotification(const Content* msg);
  static void set_has_dataextractionnotification(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::SessionProtos::UnsendRequest& unsendrequest(const Content* msg);
  static void set_has_unsendrequest(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::SessionProtos::MessageRequestResponse& messagerequestresponse(const Content* msg);
  static void set_has_messagerequestresponse(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::SessionProtos::SharedConfigMessage& sharedconfigmessage(const Content* msg);
  static void set_has_sharedconfigmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::SessionProtos::DataMessage&
Content::_Internal::datamessage(const Content* msg) {
  return *msg->_impl_.datamessage_;
}
const ::SessionProtos::CallMessage&
Content::_Internal::callmessage(const Content* msg) {
  return *msg->_impl_.callmessage_;
}
const ::SessionProtos::ReceiptMessage&
Content::_Internal::receiptmessage(const Content* msg) {
  return *msg->_impl_.receiptmessage_;
}
const ::SessionProtos::TypingMessage&
Content::_Internal::typingmessage(const Content* msg) {
  return *msg->_impl_.typingmessage_;
}
const ::SessionProtos::ConfigurationMessage&
Content::_Internal::configurationmessage(const Content* msg) {
  return *msg->_impl_.configurationmessage_;
}
const ::SessionProtos::DataExtractionNotification&
Content::_Internal::dataextractionnotification(const Content* msg) {
  return *msg->_impl_.dataextractionnotification_;
}
const ::SessionProtos::UnsendRequest&
Content::_Internal::unsendrequest(const Content* msg) {
  return *msg->_impl_.unsendrequest_;
}
const ::SessionProtos::MessageRequestResponse&
Content::_Internal::messagerequestresponse(const Content* msg) {
  return *msg->_impl_.messagerequestresponse_;
}
const ::SessionProtos::SharedConfigMessage&
Content::_Internal::sharedconfigmessage(const Content* msg) {
  return *msg->_impl_.sharedconfigmessage_;
}
Content::Content(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SessionProtos.Content)
}
Content::Content(const Content& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Content* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.datamessage_){nullptr}
    , decltype(_impl_.callmessage_){nullptr}
    , decltype(_impl_.receiptmessage_){nullptr}
    , decltype(_impl_.typingmessage_){nullptr}
    , decltype(_impl_.configurationmessage_){nullptr}
    , decltype(_impl_.dataextractionnotification_){nullptr}
    , decltype(_impl_.unsendrequest_){nullptr}
    , decltype(_impl_.messagerequestresponse_){nullptr}
    , decltype(_impl_.sharedconfigmessage_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_datamessage()) {
    _this->_impl_.datamessage_ = new ::SessionProtos::DataMessage(*from._impl_.datamessage_);
  }
  if (from._internal_has_callmessage()) {
    _this->_impl_.callmessage_ = new ::SessionProtos::CallMessage(*from._impl_.callmessage_);
  }
  if (from._internal_has_receiptmessage()) {
    _this->_impl_.receiptmessage_ = new ::SessionProtos::ReceiptMessage(*from._impl_.receiptmessage_);
  }
  if (from._internal_has_typingmessage()) {
    _this->_impl_.typingmessage_ = new ::SessionProtos::TypingMessage(*from._impl_.typingmessage_);
  }
  if (from._internal_has_configurationmessage()) {
    _this->_impl_.configurationmessage_ = new ::SessionProtos::ConfigurationMessage(*from._impl_.configurationmessage_);
  }
  if (from._internal_has_dataextractionnotification()) {
    _this->_impl_.dataextractionnotification_ = new ::SessionProtos::DataExtractionNotification(*from._impl_.dataextractionnotification_);
  }
  if (from._internal_has_unsendrequest()) {
    _this->_impl_.unsendrequest_ = new ::SessionProtos::UnsendRequest(*from._impl_.unsendrequest_);
  }
  if (from._internal_has_messagerequestresponse()) {
    _this->_impl_.messagerequestresponse_ = new ::SessionProtos::MessageRequestResponse(*from._impl_.messagerequestresponse_);
  }
  if (from._internal_has_sharedconfigmessage()) {
    _this->_impl_.sharedconfigmessage_ = new ::SessionProtos::SharedConfigMessage(*from._impl_.sharedconfigmessage_);
  }
  // @@protoc_insertion_point(copy_constructor:SessionProtos.Content)
}

inline void Content::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.datamessage_){nullptr}
    , decltype(_impl_.callmessage_){nullptr}
    , decltype(_impl_.receiptmessage_){nullptr}
    , decltype(_impl_.typingmessage_){nullptr}
    , decltype(_impl_.configurationmessage_){nullptr}
    , decltype(_impl_.dataextractionnotification_){nullptr}
    , decltype(_impl_.unsendrequest_){nullptr}
    , decltype(_impl_.messagerequestresponse_){nullptr}
    , decltype(_impl_.sharedconfigmessage_){nullptr}
  };
}

Content::~Content() {
  // @@protoc_insertion_point(destructor:SessionProtos.Content)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Content::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.datamessage_;
  if (this != internal_default_instance()) delete _impl_.callmessage_;
  if (this != internal_default_instance()) delete _impl_.receiptmessage_;
  if (this != internal_default_instance()) delete _impl_.typingmessage_;
  if (this != internal_default_instance()) delete _impl_.configurationmessage_;
  if (this != internal_default_instance()) delete _impl_.dataextractionnotification_;
  if (this != internal_default_instance()) delete _impl_.unsendrequest_;
  if (this != internal_default_instance()) delete _impl_.messagerequestresponse_;
  if (this != internal_default_instance()) delete _impl_.sharedconfigmessage_;
}

void Content::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Content::Clear() {
// @@protoc_insertion_point(message_clear_start:SessionProtos.Content)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.datamessage_ != nullptr);
      _impl_.datamessage_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.callmessage_ != nullptr);
      _impl_.callmessage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.receiptmessage_ != nullptr);
      _impl_.receiptmessage_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.typingmessage_ != nullptr);
      _impl_.typingmessage_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.configurationmessage_ != nullptr);
      _impl_.configurationmessage_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.dataextractionnotification_ != nullptr);
      _impl_.dataextractionnotification_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.unsendrequest_ != nullptr);
      _impl_.unsendrequest_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.messagerequestresponse_ != nullptr);
      _impl_.messagerequestresponse_->Clear();
    }
  }
  if (cached_has_bits & 0x00000100u) {
    GOOGLE_DCHECK(_impl_.sharedconfigmessage_ != nullptr);
    _impl_.sharedconfigmessage_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Content::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .SessionProtos.DataMessage dataMessage = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_datamessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SessionProtos.CallMessage callMessage = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_callmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SessionProtos.ReceiptMessage receiptMessage = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_receiptmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SessionProtos.TypingMessage typingMessage = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_typingmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SessionProtos.ConfigurationMessage configurationMessage = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_configurationmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SessionProtos.DataExtractionNotification dataExtractionNotification = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_dataextractionnotification(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SessionProtos.UnsendRequest unsendRequest = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_unsendrequest(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SessionProtos.MessageRequestResponse messageRequestResponse = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_messagerequestresponse(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SessionProtos.SharedConfigMessage sharedConfigMessage = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_sharedconfigmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Content::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SessionProtos.Content)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .SessionProtos.DataMessage dataMessage = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::datamessage(this),
        _Internal::datamessage(this).GetCachedSize(), target, stream);
  }

  // optional .SessionProtos.CallMessage callMessage = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::callmessage(this),
        _Internal::callmessage(this).GetCachedSize(), target, stream);
  }

  // optional .SessionProtos.ReceiptMessage receiptMessage = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::receiptmessage(this),
        _Internal::receiptmessage(this).GetCachedSize(), target, stream);
  }

  // optional .SessionProtos.TypingMessage typingMessage = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::typingmessage(this),
        _Internal::typingmessage(this).GetCachedSize(), target, stream);
  }

  // optional .SessionProtos.ConfigurationMessage configurationMessage = 7;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::configurationmessage(this),
        _Internal::configurationmessage(this).GetCachedSize(), target, stream);
  }

  // optional .SessionProtos.DataExtractionNotification dataExtractionNotification = 8;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::dataextractionnotification(this),
        _Internal::dataextractionnotification(this).GetCachedSize(), target, stream);
  }

  // optional .SessionProtos.UnsendRequest unsendRequest = 9;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::unsendrequest(this),
        _Internal::unsendrequest(this).GetCachedSize(), target, stream);
  }

  // optional .SessionProtos.MessageRequestResponse messageRequestResponse = 10;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::messagerequestresponse(this),
        _Internal::messagerequestresponse(this).GetCachedSize(), target, stream);
  }

  // optional .SessionProtos.SharedConfigMessage sharedConfigMessage = 11;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::sharedconfigmessage(this),
        _Internal::sharedconfigmessage(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SessionProtos.Content)
  return target;
}

size_t Content::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SessionProtos.Content)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .SessionProtos.DataMessage dataMessage = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.datamessage_);
    }

    // optional .SessionProtos.CallMessage callMessage = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.callmessage_);
    }

    // optional .SessionProtos.ReceiptMessage receiptMessage = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.receiptmessage_);
    }

    // optional .SessionProtos.TypingMessage typingMessage = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.typingmessage_);
    }

    // optional .SessionProtos.ConfigurationMessage configurationMessage = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.configurationmessage_);
    }

    // optional .SessionProtos.DataExtractionNotification dataExtractionNotification = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataextractionnotification_);
    }

    // optional .SessionProtos.UnsendRequest unsendRequest = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.unsendrequest_);
    }

    // optional .SessionProtos.MessageRequestResponse messageRequestResponse = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.messagerequestresponse_);
    }

  }
  // optional .SessionProtos.SharedConfigMessage sharedConfigMessage = 11;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sharedconfigmessage_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Content::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Content*>(
      &from));
}

void Content::MergeFrom(const Content& from) {
  Content* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:SessionProtos.Content)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_datamessage()->::SessionProtos::DataMessage::MergeFrom(
          from._internal_datamessage());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_callmessage()->::SessionProtos::CallMessage::MergeFrom(
          from._internal_callmessage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_receiptmessage()->::SessionProtos::ReceiptMessage::MergeFrom(
          from._internal_receiptmessage());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_typingmessage()->::SessionProtos::TypingMessage::MergeFrom(
          from._internal_typingmessage());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_configurationmessage()->::SessionProtos::ConfigurationMessage::MergeFrom(
          from._internal_configurationmessage());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_dataextractionnotification()->::SessionProtos::DataExtractionNotification::MergeFrom(
          from._internal_dataextractionnotification());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_unsendrequest()->::SessionProtos::UnsendRequest::MergeFrom(
          from._internal_unsendrequest());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_messagerequestresponse()->::SessionProtos::MessageRequestResponse::MergeFrom(
          from._internal_messagerequestresponse());
    }
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_mutable_sharedconfigmessage()->::SessionProtos::SharedConfigMessage::MergeFrom(
        from._internal_sharedconfigmessage());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Content::CopyFrom(const Content& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SessionProtos.Content)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Content::IsInitialized() const {
  if (_internal_has_datamessage()) {
    if (!_impl_.datamessage_->IsInitialized()) return false;
  }
  if (_internal_has_callmessage()) {
    if (!_impl_.callmessage_->IsInitialized()) return false;
  }
  if (_internal_has_receiptmessage()) {
    if (!_impl_.receiptmessage_->IsInitialized()) return false;
  }
  if (_internal_has_typingmessage()) {
    if (!_impl_.typingmessage_->IsInitialized()) return false;
  }
  if (_internal_has_configurationmessage()) {
    if (!_impl_.configurationmessage_->IsInitialized()) return false;
  }
  if (_internal_has_dataextractionnotification()) {
    if (!_impl_.dataextractionnotification_->IsInitialized()) return false;
  }
  if (_internal_has_unsendrequest()) {
    if (!_impl_.unsendrequest_->IsInitialized()) return false;
  }
  if (_internal_has_messagerequestresponse()) {
    if (!_impl_.messagerequestresponse_->IsInitialized()) return false;
  }
  if (_internal_has_sharedconfigmessage()) {
    if (!_impl_.sharedconfigmessage_->IsInitialized()) return false;
  }
  return true;
}

void Content::InternalSwap(Content* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Content, _impl_.sharedconfigmessage_)
      + sizeof(Content::_impl_.sharedconfigmessage_)
      - PROTOBUF_FIELD_OFFSET(Content, _impl_.datamessage_)>(
          reinterpret_cast<char*>(&_impl_.datamessage_),
          reinterpret_cast<char*>(&other->_impl_.datamessage_));
}

std::string Content::GetTypeName() const {
  return "SessionProtos.Content";
}


// ===================================================================

class CallMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<CallMessage>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_uuid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CallMessage::CallMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SessionProtos.CallMessage)
}
CallMessage::CallMessage(const CallMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CallMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sdps_){from._impl_.sdps_}
    , decltype(_impl_.sdpmlineindexes_){from._impl_.sdpmlineindexes_}
    , decltype(_impl_.sdpmids_){from._impl_.sdpmids_}
    , decltype(_impl_.uuid_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_uuid()) {
    _this->_impl_.uuid_.Set(from._internal_uuid(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:SessionProtos.CallMessage)
}

inline void CallMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sdps_){arena}
    , decltype(_impl_.sdpmlineindexes_){arena}
    , decltype(_impl_.sdpmids_){arena}
    , decltype(_impl_.uuid_){}
    , decltype(_impl_.type_){6}
  };
  _impl_.uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CallMessage::~CallMessage() {
  // @@protoc_insertion_point(destructor:SessionProtos.CallMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CallMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sdps_.~RepeatedPtrField();
  _impl_.sdpmlineindexes_.~RepeatedField();
  _impl_.sdpmids_.~RepeatedPtrField();
  _impl_.uuid_.Destroy();
}

void CallMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CallMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:SessionProtos.CallMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sdps_.Clear();
  _impl_.sdpmlineindexes_.Clear();
  _impl_.sdpmids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.uuid_.ClearNonDefaultToEmpty();
    }
    _impl_.type_ = 6;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CallMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .SessionProtos.CallMessage.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SessionProtos::CallMessage_Type_IsValid(val))) {
            _internal_set_type(static_cast<::SessionProtos::CallMessage_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated string sdps = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_sdps();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 sdpMLineIndexes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_sdpmlineindexes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_sdpmlineindexes(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string sdpMids = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_sdpmids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required string uuid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_uuid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CallMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SessionProtos.CallMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .SessionProtos.CallMessage.Type type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // repeated string sdps = 2;
  for (int i = 0, n = this->_internal_sdps_size(); i < n; i++) {
    const auto& s = this->_internal_sdps(i);
    target = stream->WriteString(2, s, target);
  }

  // repeated uint32 sdpMLineIndexes = 3;
  for (int i = 0, n = this->_internal_sdpmlineindexes_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_sdpmlineindexes(i), target);
  }

  // repeated string sdpMids = 4;
  for (int i = 0, n = this->_internal_sdpmids_size(); i < n; i++) {
    const auto& s = this->_internal_sdpmids(i);
    target = stream->WriteString(4, s, target);
  }

  // required string uuid = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_uuid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SessionProtos.CallMessage)
  return target;
}

size_t CallMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:SessionProtos.CallMessage)
  size_t total_size = 0;

  if (_internal_has_uuid()) {
    // required string uuid = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_uuid());
  }

  if (_internal_has_type()) {
    // required .SessionProtos.CallMessage.Type type = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t CallMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SessionProtos.CallMessage)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string uuid = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_uuid());

    // required .SessionProtos.CallMessage.Type type = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string sdps = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.sdps_.size());
  for (int i = 0, n = _impl_.sdps_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.sdps_.Get(i));
  }

  // repeated uint32 sdpMLineIndexes = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.sdpmlineindexes_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_sdpmlineindexes_size());
    total_size += data_size;
  }

  // repeated string sdpMids = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.sdpmids_.size());
  for (int i = 0, n = _impl_.sdpmids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.sdpmids_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CallMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CallMessage*>(
      &from));
}

void CallMessage::MergeFrom(const CallMessage& from) {
  CallMessage* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:SessionProtos.CallMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.sdps_.MergeFrom(from._impl_.sdps_);
  _this->_impl_.sdpmlineindexes_.MergeFrom(from._impl_.sdpmlineindexes_);
  _this->_impl_.sdpmids_.MergeFrom(from._impl_.sdpmids_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_uuid(from._internal_uuid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CallMessage::CopyFrom(const CallMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SessionProtos.CallMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CallMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void CallMessage::InternalSwap(CallMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.sdps_.InternalSwap(&other->_impl_.sdps_);
  _impl_.sdpmlineindexes_.InternalSwap(&other->_impl_.sdpmlineindexes_);
  _impl_.sdpmids_.InternalSwap(&other->_impl_.sdpmids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.uuid_, lhs_arena,
      &other->_impl_.uuid_, rhs_arena
  );
  swap(_impl_.type_, other->_impl_.type_);
}

std::string CallMessage::GetTypeName() const {
  return "SessionProtos.CallMessage";
}


// ===================================================================

class KeyPair::_Internal {
 public:
  using HasBits = decltype(std::declval<KeyPair>()._impl_._has_bits_);
  static void set_has_publickey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_privatekey(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

KeyPair::KeyPair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SessionProtos.KeyPair)
}
KeyPair::KeyPair(const KeyPair& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KeyPair* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.publickey_){}
    , decltype(_impl_.privatekey_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.publickey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.publickey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_publickey()) {
    _this->_impl_.publickey_.Set(from._internal_publickey(), 
      _this->GetArenaForAllocation());
  }
  _impl_.privatekey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.privatekey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_privatekey()) {
    _this->_impl_.privatekey_.Set(from._internal_privatekey(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:SessionProtos.KeyPair)
}

inline void KeyPair::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.publickey_){}
    , decltype(_impl_.privatekey_){}
  };
  _impl_.publickey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.publickey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.privatekey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.privatekey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KeyPair::~KeyPair() {
  // @@protoc_insertion_point(destructor:SessionProtos.KeyPair)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KeyPair::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.publickey_.Destroy();
  _impl_.privatekey_.Destroy();
}

void KeyPair::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KeyPair::Clear() {
// @@protoc_insertion_point(message_clear_start:SessionProtos.KeyPair)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.publickey_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.privatekey_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KeyPair::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes publicKey = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_publickey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes privateKey = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_privatekey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeyPair::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SessionProtos.KeyPair)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes publicKey = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_publickey(), target);
  }

  // required bytes privateKey = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_privatekey(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SessionProtos.KeyPair)
  return target;
}

size_t KeyPair::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:SessionProtos.KeyPair)
  size_t total_size = 0;

  if (_internal_has_publickey()) {
    // required bytes publicKey = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_publickey());
  }

  if (_internal_has_privatekey()) {
    // required bytes privateKey = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_privatekey());
  }

  return total_size;
}
size_t KeyPair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SessionProtos.KeyPair)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes publicKey = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_publickey());

    // required bytes privateKey = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_privatekey());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KeyPair::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KeyPair*>(
      &from));
}

void KeyPair::MergeFrom(const KeyPair& from) {
  KeyPair* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:SessionProtos.KeyPair)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_publickey(from._internal_publickey());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_privatekey(from._internal_privatekey());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KeyPair::CopyFrom(const KeyPair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SessionProtos.KeyPair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyPair::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void KeyPair::InternalSwap(KeyPair* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.publickey_, lhs_arena,
      &other->_impl_.publickey_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.privatekey_, lhs_arena,
      &other->_impl_.privatekey_, rhs_arena
  );
}

std::string KeyPair::GetTypeName() const {
  return "SessionProtos.KeyPair";
}


// ===================================================================

class DataExtractionNotification::_Internal {
 public:
  using HasBits = decltype(std::declval<DataExtractionNotification>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

DataExtractionNotification::DataExtractionNotification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SessionProtos.DataExtractionNotification)
}
DataExtractionNotification::DataExtractionNotification(const DataExtractionNotification& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DataExtractionNotification* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:SessionProtos.DataExtractionNotification)
}

inline void DataExtractionNotification::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){uint64_t{0u}}
    , decltype(_impl_.type_){1}
  };
}

DataExtractionNotification::~DataExtractionNotification() {
  // @@protoc_insertion_point(destructor:SessionProtos.DataExtractionNotification)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DataExtractionNotification::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DataExtractionNotification::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DataExtractionNotification::Clear() {
// @@protoc_insertion_point(message_clear_start:SessionProtos.DataExtractionNotification)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.timestamp_ = uint64_t{0u};
    _impl_.type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DataExtractionNotification::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .SessionProtos.DataExtractionNotification.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SessionProtos::DataExtractionNotification_Type_IsValid(val))) {
            _internal_set_type(static_cast<::SessionProtos::DataExtractionNotification_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint64 timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DataExtractionNotification::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SessionProtos.DataExtractionNotification)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .SessionProtos.DataExtractionNotification.Type type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional uint64 timestamp = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SessionProtos.DataExtractionNotification)
  return target;
}

size_t DataExtractionNotification::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SessionProtos.DataExtractionNotification)
  size_t total_size = 0;

  // required .SessionProtos.DataExtractionNotification.Type type = 1;
  if (_internal_has_type()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 timestamp = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_timestamp());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DataExtractionNotification::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DataExtractionNotification*>(
      &from));
}

void DataExtractionNotification::MergeFrom(const DataExtractionNotification& from) {
  DataExtractionNotification* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:SessionProtos.DataExtractionNotification)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DataExtractionNotification::CopyFrom(const DataExtractionNotification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SessionProtos.DataExtractionNotification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataExtractionNotification::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void DataExtractionNotification::InternalSwap(DataExtractionNotification* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.timestamp_, other->_impl_.timestamp_);
  swap(_impl_.type_, other->_impl_.type_);
}

std::string DataExtractionNotification::GetTypeName() const {
  return "SessionProtos.DataExtractionNotification";
}


// ===================================================================

class LokiProfile::_Internal {
 public:
  using HasBits = decltype(std::declval<LokiProfile>()._impl_._has_bits_);
  static void set_has_displayname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_profilepicture(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

LokiProfile::LokiProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SessionProtos.LokiProfile)
}
LokiProfile::LokiProfile(const LokiProfile& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LokiProfile* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.displayname_){}
    , decltype(_impl_.profilepicture_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.displayname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.displayname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_displayname()) {
    _this->_impl_.displayname_.Set(from._internal_displayname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.profilepicture_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profilepicture_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_profilepicture()) {
    _this->_impl_.profilepicture_.Set(from._internal_profilepicture(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:SessionProtos.LokiProfile)
}

inline void LokiProfile::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.displayname_){}
    , decltype(_impl_.profilepicture_){}
  };
  _impl_.displayname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.displayname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.profilepicture_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profilepicture_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LokiProfile::~LokiProfile() {
  // @@protoc_insertion_point(destructor:SessionProtos.LokiProfile)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LokiProfile::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.displayname_.Destroy();
  _impl_.profilepicture_.Destroy();
}

void LokiProfile::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LokiProfile::Clear() {
// @@protoc_insertion_point(message_clear_start:SessionProtos.LokiProfile)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.displayname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.profilepicture_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LokiProfile::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string displayName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_displayname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string profilePicture = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_profilepicture();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LokiProfile::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SessionProtos.LokiProfile)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string displayName = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_displayname(), target);
  }

  // optional string profilePicture = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_profilepicture(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SessionProtos.LokiProfile)
  return target;
}

size_t LokiProfile::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SessionProtos.LokiProfile)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string displayName = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_displayname());
    }

    // optional string profilePicture = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_profilepicture());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LokiProfile::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LokiProfile*>(
      &from));
}

void LokiProfile::MergeFrom(const LokiProfile& from) {
  LokiProfile* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:SessionProtos.LokiProfile)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_displayname(from._internal_displayname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_profilepicture(from._internal_profilepicture());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LokiProfile::CopyFrom(const LokiProfile& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SessionProtos.LokiProfile)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LokiProfile::IsInitialized() const {
  return true;
}

void LokiProfile::InternalSwap(LokiProfile* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.displayname_, lhs_arena,
      &other->_impl_.displayname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.profilepicture_, lhs_arena,
      &other->_impl_.profilepicture_, rhs_arena
  );
}

std::string LokiProfile::GetTypeName() const {
  return "SessionProtos.LokiProfile";
}


// ===================================================================

class DataMessage_Quote_QuotedAttachment::_Internal {
 public:
  using HasBits = decltype(std::declval<DataMessage_Quote_QuotedAttachment>()._impl_._has_bits_);
  static void set_has_contenttype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::SessionProtos::AttachmentPointer& thumbnail(const DataMessage_Quote_QuotedAttachment* msg);
  static void set_has_thumbnail(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::SessionProtos::AttachmentPointer&
DataMessage_Quote_QuotedAttachment::_Internal::thumbnail(const DataMessage_Quote_QuotedAttachment* msg) {
  return *msg->_impl_.thumbnail_;
}
DataMessage_Quote_QuotedAttachment::DataMessage_Quote_QuotedAttachment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SessionProtos.DataMessage.Quote.QuotedAttachment)
}
DataMessage_Quote_QuotedAttachment::DataMessage_Quote_QuotedAttachment(const DataMessage_Quote_QuotedAttachment& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DataMessage_Quote_QuotedAttachment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.contenttype_){}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.thumbnail_){nullptr}
    , decltype(_impl_.flags_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.contenttype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contenttype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contenttype()) {
    _this->_impl_.contenttype_.Set(from._internal_contenttype(), 
      _this->GetArenaForAllocation());
  }
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_filename()) {
    _this->_impl_.filename_.Set(from._internal_filename(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_thumbnail()) {
    _this->_impl_.thumbnail_ = new ::SessionProtos::AttachmentPointer(*from._impl_.thumbnail_);
  }
  _this->_impl_.flags_ = from._impl_.flags_;
  // @@protoc_insertion_point(copy_constructor:SessionProtos.DataMessage.Quote.QuotedAttachment)
}

inline void DataMessage_Quote_QuotedAttachment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.contenttype_){}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.thumbnail_){nullptr}
    , decltype(_impl_.flags_){0u}
  };
  _impl_.contenttype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contenttype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DataMessage_Quote_QuotedAttachment::~DataMessage_Quote_QuotedAttachment() {
  // @@protoc_insertion_point(destructor:SessionProtos.DataMessage.Quote.QuotedAttachment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DataMessage_Quote_QuotedAttachment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contenttype_.Destroy();
  _impl_.filename_.Destroy();
  if (this != internal_default_instance()) delete _impl_.thumbnail_;
}

void DataMessage_Quote_QuotedAttachment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DataMessage_Quote_QuotedAttachment::Clear() {
// @@protoc_insertion_point(message_clear_start:SessionProtos.DataMessage.Quote.QuotedAttachment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.contenttype_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.filename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.thumbnail_ != nullptr);
      _impl_.thumbnail_->Clear();
    }
  }
  _impl_.flags_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DataMessage_Quote_QuotedAttachment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string contentType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contenttype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string fileName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SessionProtos.AttachmentPointer thumbnail = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_thumbnail(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DataMessage_Quote_QuotedAttachment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SessionProtos.DataMessage.Quote.QuotedAttachment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string contentType = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_contenttype(), target);
  }

  // optional string fileName = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_filename(), target);
  }

  // optional .SessionProtos.AttachmentPointer thumbnail = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::thumbnail(this),
        _Internal::thumbnail(this).GetCachedSize(), target, stream);
  }

  // optional uint32 flags = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SessionProtos.DataMessage.Quote.QuotedAttachment)
  return target;
}

size_t DataMessage_Quote_QuotedAttachment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SessionProtos.DataMessage.Quote.QuotedAttachment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string contentType = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contenttype());
    }

    // optional string fileName = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_filename());
    }

    // optional .SessionProtos.AttachmentPointer thumbnail = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.thumbnail_);
    }

    // optional uint32 flags = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DataMessage_Quote_QuotedAttachment::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DataMessage_Quote_QuotedAttachment*>(
      &from));
}

void DataMessage_Quote_QuotedAttachment::MergeFrom(const DataMessage_Quote_QuotedAttachment& from) {
  DataMessage_Quote_QuotedAttachment* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:SessionProtos.DataMessage.Quote.QuotedAttachment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_contenttype(from._internal_contenttype());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_filename(from._internal_filename());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_thumbnail()->::SessionProtos::AttachmentPointer::MergeFrom(
          from._internal_thumbnail());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DataMessage_Quote_QuotedAttachment::CopyFrom(const DataMessage_Quote_QuotedAttachment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SessionProtos.DataMessage.Quote.QuotedAttachment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataMessage_Quote_QuotedAttachment::IsInitialized() const {
  if (_internal_has_thumbnail()) {
    if (!_impl_.thumbnail_->IsInitialized()) return false;
  }
  return true;
}

void DataMessage_Quote_QuotedAttachment::InternalSwap(DataMessage_Quote_QuotedAttachment* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contenttype_, lhs_arena,
      &other->_impl_.contenttype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.filename_, lhs_arena,
      &other->_impl_.filename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DataMessage_Quote_QuotedAttachment, _impl_.flags_)
      + sizeof(DataMessage_Quote_QuotedAttachment::_impl_.flags_)
      - PROTOBUF_FIELD_OFFSET(DataMessage_Quote_QuotedAttachment, _impl_.thumbnail_)>(
          reinterpret_cast<char*>(&_impl_.thumbnail_),
          reinterpret_cast<char*>(&other->_impl_.thumbnail_));
}

std::string DataMessage_Quote_QuotedAttachment::GetTypeName() const {
  return "SessionProtos.DataMessage.Quote.QuotedAttachment";
}


// ===================================================================

class DataMessage_Quote::_Internal {
 public:
  using HasBits = decltype(std::declval<DataMessage_Quote>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_author(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_text(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000005) ^ 0x00000005) != 0;
  }
};

DataMessage_Quote::DataMessage_Quote(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SessionProtos.DataMessage.Quote)
}
DataMessage_Quote::DataMessage_Quote(const DataMessage_Quote& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DataMessage_Quote* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attachments_){from._impl_.attachments_}
    , decltype(_impl_.author_){}
    , decltype(_impl_.text_){}
    , decltype(_impl_.id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.author_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.author_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_author()) {
    _this->_impl_.author_.Set(from._internal_author(), 
      _this->GetArenaForAllocation());
  }
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_text()) {
    _this->_impl_.text_.Set(from._internal_text(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:SessionProtos.DataMessage.Quote)
}

inline void DataMessage_Quote::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attachments_){arena}
    , decltype(_impl_.author_){}
    , decltype(_impl_.text_){}
    , decltype(_impl_.id_){uint64_t{0u}}
  };
  _impl_.author_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.author_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DataMessage_Quote::~DataMessage_Quote() {
  // @@protoc_insertion_point(destructor:SessionProtos.DataMessage.Quote)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DataMessage_Quote::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attachments_.~RepeatedPtrField();
  _impl_.author_.Destroy();
  _impl_.text_.Destroy();
}

void DataMessage_Quote::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DataMessage_Quote::Clear() {
// @@protoc_insertion_point(message_clear_start:SessionProtos.DataMessage.Quote)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.attachments_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.author_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.text_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DataMessage_Quote::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string author = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_author();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string text = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .SessionProtos.DataMessage.Quote.QuotedAttachment attachments = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_attachments(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DataMessage_Quote::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SessionProtos.DataMessage.Quote)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // required string author = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_author(), target);
  }

  // optional string text = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_text(), target);
  }

  // repeated .SessionProtos.DataMessage.Quote.QuotedAttachment attachments = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_attachments_size()); i < n; i++) {
    const auto& repfield = this->_internal_attachments(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SessionProtos.DataMessage.Quote)
  return target;
}

size_t DataMessage_Quote::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:SessionProtos.DataMessage.Quote)
  size_t total_size = 0;

  if (_internal_has_author()) {
    // required string author = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_author());
  }

  if (_internal_has_id()) {
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  return total_size;
}
size_t DataMessage_Quote::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SessionProtos.DataMessage.Quote)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000005) ^ 0x00000005) == 0) {  // All required fields are present.
    // required string author = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_author());

    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SessionProtos.DataMessage.Quote.QuotedAttachment attachments = 4;
  total_size += 1UL * this->_internal_attachments_size();
  for (const auto& msg : this->_impl_.attachments_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string text = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_text());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DataMessage_Quote::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DataMessage_Quote*>(
      &from));
}

void DataMessage_Quote::MergeFrom(const DataMessage_Quote& from) {
  DataMessage_Quote* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:SessionProtos.DataMessage.Quote)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.attachments_.MergeFrom(from._impl_.attachments_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_author(from._internal_author());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_text(from._internal_text());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DataMessage_Quote::CopyFrom(const DataMessage_Quote& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SessionProtos.DataMessage.Quote)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataMessage_Quote::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.attachments_))
    return false;
  return true;
}

void DataMessage_Quote::InternalSwap(DataMessage_Quote* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.attachments_.InternalSwap(&other->_impl_.attachments_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.author_, lhs_arena,
      &other->_impl_.author_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.text_, lhs_arena,
      &other->_impl_.text_, rhs_arena
  );
  swap(_impl_.id_, other->_impl_.id_);
}

std::string DataMessage_Quote::GetTypeName() const {
  return "SessionProtos.DataMessage.Quote";
}


// ===================================================================

class DataMessage_Preview::_Internal {
 public:
  using HasBits = decltype(std::declval<DataMessage_Preview>()._impl_._has_bits_);
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_title(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::SessionProtos::AttachmentPointer& image(const DataMessage_Preview* msg);
  static void set_has_image(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::SessionProtos::AttachmentPointer&
DataMessage_Preview::_Internal::image(const DataMessage_Preview* msg) {
  return *msg->_impl_.image_;
}
DataMessage_Preview::DataMessage_Preview(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SessionProtos.DataMessage.Preview)
}
DataMessage_Preview::DataMessage_Preview(const DataMessage_Preview& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DataMessage_Preview* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.url_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.image_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_title()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_image()) {
    _this->_impl_.image_ = new ::SessionProtos::AttachmentPointer(*from._impl_.image_);
  }
  // @@protoc_insertion_point(copy_constructor:SessionProtos.DataMessage.Preview)
}

inline void DataMessage_Preview::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.url_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.image_){nullptr}
  };
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DataMessage_Preview::~DataMessage_Preview() {
  // @@protoc_insertion_point(destructor:SessionProtos.DataMessage.Preview)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DataMessage_Preview::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.url_.Destroy();
  _impl_.title_.Destroy();
  if (this != internal_default_instance()) delete _impl_.image_;
}

void DataMessage_Preview::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DataMessage_Preview::Clear() {
// @@protoc_insertion_point(message_clear_start:SessionProtos.DataMessage.Preview)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.title_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.image_ != nullptr);
      _impl_.image_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DataMessage_Preview::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string title = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SessionProtos.AttachmentPointer image = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_image(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DataMessage_Preview::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SessionProtos.DataMessage.Preview)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  // optional string title = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_title(), target);
  }

  // optional .SessionProtos.AttachmentPointer image = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::image(this),
        _Internal::image(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SessionProtos.DataMessage.Preview)
  return target;
}

size_t DataMessage_Preview::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SessionProtos.DataMessage.Preview)
  size_t total_size = 0;

  // required string url = 1;
  if (_internal_has_url()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional string title = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_title());
    }

    // optional .SessionProtos.AttachmentPointer image = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.image_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DataMessage_Preview::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DataMessage_Preview*>(
      &from));
}

void DataMessage_Preview::MergeFrom(const DataMessage_Preview& from) {
  DataMessage_Preview* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:SessionProtos.DataMessage.Preview)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_title(from._internal_title());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_image()->::SessionProtos::AttachmentPointer::MergeFrom(
          from._internal_image());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DataMessage_Preview::CopyFrom(const DataMessage_Preview& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SessionProtos.DataMessage.Preview)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataMessage_Preview::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_image()) {
    if (!_impl_.image_->IsInitialized()) return false;
  }
  return true;
}

void DataMessage_Preview::InternalSwap(DataMessage_Preview* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  swap(_impl_.image_, other->_impl_.image_);
}

std::string DataMessage_Preview::GetTypeName() const {
  return "SessionProtos.DataMessage.Preview";
}


// ===================================================================

class DataMessage_Reaction::_Internal {
 public:
  using HasBits = decltype(std::declval<DataMessage_Reaction>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_author(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_emoji(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_action(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000d) ^ 0x0000000d) != 0;
  }
};

DataMessage_Reaction::DataMessage_Reaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SessionProtos.DataMessage.Reaction)
}
DataMessage_Reaction::DataMessage_Reaction(const DataMessage_Reaction& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DataMessage_Reaction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.author_){}
    , decltype(_impl_.emoji_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.action_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.author_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.author_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_author()) {
    _this->_impl_.author_.Set(from._internal_author(), 
      _this->GetArenaForAllocation());
  }
  _impl_.emoji_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.emoji_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_emoji()) {
    _this->_impl_.emoji_.Set(from._internal_emoji(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.action_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.action_));
  // @@protoc_insertion_point(copy_constructor:SessionProtos.DataMessage.Reaction)
}

inline void DataMessage_Reaction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.author_){}
    , decltype(_impl_.emoji_){}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_.action_){0}
  };
  _impl_.author_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.author_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.emoji_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.emoji_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DataMessage_Reaction::~DataMessage_Reaction() {
  // @@protoc_insertion_point(destructor:SessionProtos.DataMessage.Reaction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DataMessage_Reaction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.author_.Destroy();
  _impl_.emoji_.Destroy();
}

void DataMessage_Reaction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DataMessage_Reaction::Clear() {
// @@protoc_insertion_point(message_clear_start:SessionProtos.DataMessage.Reaction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.author_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.emoji_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.action_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.action_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DataMessage_Reaction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string author = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_author();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string emoji = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_emoji();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .SessionProtos.DataMessage.Reaction.Action action = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SessionProtos::DataMessage_Reaction_Action_IsValid(val))) {
            _internal_set_action(static_cast<::SessionProtos::DataMessage_Reaction_Action>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DataMessage_Reaction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SessionProtos.DataMessage.Reaction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // required string author = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_author(), target);
  }

  // optional string emoji = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_emoji(), target);
  }

  // required .SessionProtos.DataMessage.Reaction.Action action = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_action(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SessionProtos.DataMessage.Reaction)
  return target;
}

size_t DataMessage_Reaction::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:SessionProtos.DataMessage.Reaction)
  size_t total_size = 0;

  if (_internal_has_author()) {
    // required string author = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_author());
  }

  if (_internal_has_id()) {
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  if (_internal_has_action()) {
    // required .SessionProtos.DataMessage.Reaction.Action action = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_action());
  }

  return total_size;
}
size_t DataMessage_Reaction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SessionProtos.DataMessage.Reaction)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000d) ^ 0x0000000d) == 0) {  // All required fields are present.
    // required string author = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_author());

    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());

    // required .SessionProtos.DataMessage.Reaction.Action action = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_action());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string emoji = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_emoji());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DataMessage_Reaction::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DataMessage_Reaction*>(
      &from));
}

void DataMessage_Reaction::MergeFrom(const DataMessage_Reaction& from) {
  DataMessage_Reaction* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:SessionProtos.DataMessage.Reaction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_author(from._internal_author());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_emoji(from._internal_emoji());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.action_ = from._impl_.action_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DataMessage_Reaction::CopyFrom(const DataMessage_Reaction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SessionProtos.DataMessage.Reaction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataMessage_Reaction::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void DataMessage_Reaction::InternalSwap(DataMessage_Reaction* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.author_, lhs_arena,
      &other->_impl_.author_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.emoji_, lhs_arena,
      &other->_impl_.emoji_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DataMessage_Reaction, _impl_.action_)
      + sizeof(DataMessage_Reaction::_impl_.action_)
      - PROTOBUF_FIELD_OFFSET(DataMessage_Reaction, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

std::string DataMessage_Reaction::GetTypeName() const {
  return "SessionProtos.DataMessage.Reaction";
}


// ===================================================================

class DataMessage_OpenGroupInvitation::_Internal {
 public:
  using HasBits = decltype(std::declval<DataMessage_OpenGroupInvitation>()._impl_._has_bits_);
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

DataMessage_OpenGroupInvitation::DataMessage_OpenGroupInvitation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SessionProtos.DataMessage.OpenGroupInvitation)
}
DataMessage_OpenGroupInvitation::DataMessage_OpenGroupInvitation(const DataMessage_OpenGroupInvitation& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DataMessage_OpenGroupInvitation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.url_){}
    , decltype(_impl_.name_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:SessionProtos.DataMessage.OpenGroupInvitation)
}

inline void DataMessage_OpenGroupInvitation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.url_){}
    , decltype(_impl_.name_){}
  };
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DataMessage_OpenGroupInvitation::~DataMessage_OpenGroupInvitation() {
  // @@protoc_insertion_point(destructor:SessionProtos.DataMessage.OpenGroupInvitation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DataMessage_OpenGroupInvitation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.url_.Destroy();
  _impl_.name_.Destroy();
}

void DataMessage_OpenGroupInvitation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DataMessage_OpenGroupInvitation::Clear() {
// @@protoc_insertion_point(message_clear_start:SessionProtos.DataMessage.OpenGroupInvitation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DataMessage_OpenGroupInvitation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DataMessage_OpenGroupInvitation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SessionProtos.DataMessage.OpenGroupInvitation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  // required string name = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SessionProtos.DataMessage.OpenGroupInvitation)
  return target;
}

size_t DataMessage_OpenGroupInvitation::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:SessionProtos.DataMessage.OpenGroupInvitation)
  size_t total_size = 0;

  if (_internal_has_url()) {
    // required string url = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());
  }

  if (_internal_has_name()) {
    // required string name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return total_size;
}
size_t DataMessage_OpenGroupInvitation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SessionProtos.DataMessage.OpenGroupInvitation)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string url = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());

    // required string name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DataMessage_OpenGroupInvitation::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DataMessage_OpenGroupInvitation*>(
      &from));
}

void DataMessage_OpenGroupInvitation::MergeFrom(const DataMessage_OpenGroupInvitation& from) {
  DataMessage_OpenGroupInvitation* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:SessionProtos.DataMessage.OpenGroupInvitation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_name(from._internal_name());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DataMessage_OpenGroupInvitation::CopyFrom(const DataMessage_OpenGroupInvitation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SessionProtos.DataMessage.OpenGroupInvitation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataMessage_OpenGroupInvitation::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void DataMessage_OpenGroupInvitation::InternalSwap(DataMessage_OpenGroupInvitation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

std::string DataMessage_OpenGroupInvitation::GetTypeName() const {
  return "SessionProtos.DataMessage.OpenGroupInvitation";
}


// ===================================================================

class DataMessage_ClosedGroupControlMessage_KeyPairWrapper::_Internal {
 public:
  using HasBits = decltype(std::declval<DataMessage_ClosedGroupControlMessage_KeyPairWrapper>()._impl_._has_bits_);
  static void set_has_publickey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_encryptedkeypair(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

DataMessage_ClosedGroupControlMessage_KeyPairWrapper::DataMessage_ClosedGroupControlMessage_KeyPairWrapper(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper)
}
DataMessage_ClosedGroupControlMessage_KeyPairWrapper::DataMessage_ClosedGroupControlMessage_KeyPairWrapper(const DataMessage_ClosedGroupControlMessage_KeyPairWrapper& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DataMessage_ClosedGroupControlMessage_KeyPairWrapper* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.publickey_){}
    , decltype(_impl_.encryptedkeypair_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.publickey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.publickey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_publickey()) {
    _this->_impl_.publickey_.Set(from._internal_publickey(), 
      _this->GetArenaForAllocation());
  }
  _impl_.encryptedkeypair_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encryptedkeypair_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_encryptedkeypair()) {
    _this->_impl_.encryptedkeypair_.Set(from._internal_encryptedkeypair(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper)
}

inline void DataMessage_ClosedGroupControlMessage_KeyPairWrapper::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.publickey_){}
    , decltype(_impl_.encryptedkeypair_){}
  };
  _impl_.publickey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.publickey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.encryptedkeypair_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encryptedkeypair_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DataMessage_ClosedGroupControlMessage_KeyPairWrapper::~DataMessage_ClosedGroupControlMessage_KeyPairWrapper() {
  // @@protoc_insertion_point(destructor:SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DataMessage_ClosedGroupControlMessage_KeyPairWrapper::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.publickey_.Destroy();
  _impl_.encryptedkeypair_.Destroy();
}

void DataMessage_ClosedGroupControlMessage_KeyPairWrapper::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DataMessage_ClosedGroupControlMessage_KeyPairWrapper::Clear() {
// @@protoc_insertion_point(message_clear_start:SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.publickey_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.encryptedkeypair_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DataMessage_ClosedGroupControlMessage_KeyPairWrapper::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes publicKey = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_publickey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes encryptedKeyPair = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_encryptedkeypair();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DataMessage_ClosedGroupControlMessage_KeyPairWrapper::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes publicKey = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_publickey(), target);
  }

  // required bytes encryptedKeyPair = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_encryptedkeypair(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper)
  return target;
}

size_t DataMessage_ClosedGroupControlMessage_KeyPairWrapper::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper)
  size_t total_size = 0;

  if (_internal_has_publickey()) {
    // required bytes publicKey = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_publickey());
  }

  if (_internal_has_encryptedkeypair()) {
    // required bytes encryptedKeyPair = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_encryptedkeypair());
  }

  return total_size;
}
size_t DataMessage_ClosedGroupControlMessage_KeyPairWrapper::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes publicKey = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_publickey());

    // required bytes encryptedKeyPair = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_encryptedkeypair());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DataMessage_ClosedGroupControlMessage_KeyPairWrapper::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DataMessage_ClosedGroupControlMessage_KeyPairWrapper*>(
      &from));
}

void DataMessage_ClosedGroupControlMessage_KeyPairWrapper::MergeFrom(const DataMessage_ClosedGroupControlMessage_KeyPairWrapper& from) {
  DataMessage_ClosedGroupControlMessage_KeyPairWrapper* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_publickey(from._internal_publickey());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_encryptedkeypair(from._internal_encryptedkeypair());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DataMessage_ClosedGroupControlMessage_KeyPairWrapper::CopyFrom(const DataMessage_ClosedGroupControlMessage_KeyPairWrapper& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataMessage_ClosedGroupControlMessage_KeyPairWrapper::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void DataMessage_ClosedGroupControlMessage_KeyPairWrapper::InternalSwap(DataMessage_ClosedGroupControlMessage_KeyPairWrapper* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.publickey_, lhs_arena,
      &other->_impl_.publickey_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.encryptedkeypair_, lhs_arena,
      &other->_impl_.encryptedkeypair_, rhs_arena
  );
}

std::string DataMessage_ClosedGroupControlMessage_KeyPairWrapper::GetTypeName() const {
  return "SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper";
}


// ===================================================================

class DataMessage_ClosedGroupControlMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<DataMessage_ClosedGroupControlMessage>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_publickey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::SessionProtos::KeyPair& encryptionkeypair(const DataMessage_ClosedGroupControlMessage* msg);
  static void set_has_encryptionkeypair(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_expirationtimer(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000010) ^ 0x00000010) != 0;
  }
};

const ::SessionProtos::KeyPair&
DataMessage_ClosedGroupControlMessage::_Internal::encryptionkeypair(const DataMessage_ClosedGroupControlMessage* msg) {
  return *msg->_impl_.encryptionkeypair_;
}
DataMessage_ClosedGroupControlMessage::DataMessage_ClosedGroupControlMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SessionProtos.DataMessage.ClosedGroupControlMessage)
}
DataMessage_ClosedGroupControlMessage::DataMessage_ClosedGroupControlMessage(const DataMessage_ClosedGroupControlMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DataMessage_ClosedGroupControlMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_){from._impl_.members_}
    , decltype(_impl_.admins_){from._impl_.admins_}
    , decltype(_impl_.wrappers_){from._impl_.wrappers_}
    , decltype(_impl_.publickey_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.encryptionkeypair_){nullptr}
    , decltype(_impl_.expirationtimer_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.publickey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.publickey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_publickey()) {
    _this->_impl_.publickey_.Set(from._internal_publickey(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_encryptionkeypair()) {
    _this->_impl_.encryptionkeypair_ = new ::SessionProtos::KeyPair(*from._impl_.encryptionkeypair_);
  }
  ::memcpy(&_impl_.expirationtimer_, &from._impl_.expirationtimer_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.expirationtimer_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:SessionProtos.DataMessage.ClosedGroupControlMessage)
}

inline void DataMessage_ClosedGroupControlMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_){arena}
    , decltype(_impl_.admins_){arena}
    , decltype(_impl_.wrappers_){arena}
    , decltype(_impl_.publickey_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.encryptionkeypair_){nullptr}
    , decltype(_impl_.expirationtimer_){0u}
    , decltype(_impl_.type_){1}
  };
  _impl_.publickey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.publickey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DataMessage_ClosedGroupControlMessage::~DataMessage_ClosedGroupControlMessage() {
  // @@protoc_insertion_point(destructor:SessionProtos.DataMessage.ClosedGroupControlMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DataMessage_ClosedGroupControlMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.members_.~RepeatedPtrField();
  _impl_.admins_.~RepeatedPtrField();
  _impl_.wrappers_.~RepeatedPtrField();
  _impl_.publickey_.Destroy();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.encryptionkeypair_;
}

void DataMessage_ClosedGroupControlMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DataMessage_ClosedGroupControlMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:SessionProtos.DataMessage.ClosedGroupControlMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.members_.Clear();
  _impl_.admins_.Clear();
  _impl_.wrappers_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.publickey_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.encryptionkeypair_ != nullptr);
      _impl_.encryptionkeypair_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    _impl_.expirationtimer_ = 0u;
    _impl_.type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DataMessage_ClosedGroupControlMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .SessionProtos.DataMessage.ClosedGroupControlMessage.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SessionProtos::DataMessage_ClosedGroupControlMessage_Type_IsValid(val))) {
            _internal_set_type(static_cast<::SessionProtos::DataMessage_ClosedGroupControlMessage_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes publicKey = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_publickey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SessionProtos.KeyPair encryptionKeyPair = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_encryptionkeypair(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes members = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_members();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated bytes admins = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_admins();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper wrappers = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_wrappers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 expirationTimer = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_expirationtimer(&has_bits);
          _impl_.expirationtimer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DataMessage_ClosedGroupControlMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SessionProtos.DataMessage.ClosedGroupControlMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .SessionProtos.DataMessage.ClosedGroupControlMessage.Type type = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional bytes publicKey = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_publickey(), target);
  }

  // optional string name = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // optional .SessionProtos.KeyPair encryptionKeyPair = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::encryptionkeypair(this),
        _Internal::encryptionkeypair(this).GetCachedSize(), target, stream);
  }

  // repeated bytes members = 5;
  for (int i = 0, n = this->_internal_members_size(); i < n; i++) {
    const auto& s = this->_internal_members(i);
    target = stream->WriteBytes(5, s, target);
  }

  // repeated bytes admins = 6;
  for (int i = 0, n = this->_internal_admins_size(); i < n; i++) {
    const auto& s = this->_internal_admins(i);
    target = stream->WriteBytes(6, s, target);
  }

  // repeated .SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper wrappers = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_wrappers_size()); i < n; i++) {
    const auto& repfield = this->_internal_wrappers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 expirationTimer = 8;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_expirationtimer(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SessionProtos.DataMessage.ClosedGroupControlMessage)
  return target;
}

size_t DataMessage_ClosedGroupControlMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SessionProtos.DataMessage.ClosedGroupControlMessage)
  size_t total_size = 0;

  // required .SessionProtos.DataMessage.ClosedGroupControlMessage.Type type = 1;
  if (_internal_has_type()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes members = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.members_.size());
  for (int i = 0, n = _impl_.members_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.members_.Get(i));
  }

  // repeated bytes admins = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.admins_.size());
  for (int i = 0, n = _impl_.admins_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.admins_.Get(i));
  }

  // repeated .SessionProtos.DataMessage.ClosedGroupControlMessage.KeyPairWrapper wrappers = 7;
  total_size += 1UL * this->_internal_wrappers_size();
  for (const auto& msg : this->_impl_.wrappers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes publicKey = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_publickey());
    }

    // optional string name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional .SessionProtos.KeyPair encryptionKeyPair = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.encryptionkeypair_);
    }

    // optional uint32 expirationTimer = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_expirationtimer());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DataMessage_ClosedGroupControlMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DataMessage_ClosedGroupControlMessage*>(
      &from));
}

void DataMessage_ClosedGroupControlMessage::MergeFrom(const DataMessage_ClosedGroupControlMessage& from) {
  DataMessage_ClosedGroupControlMessage* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:SessionProtos.DataMessage.ClosedGroupControlMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.members_.MergeFrom(from._impl_.members_);
  _this->_impl_.admins_.MergeFrom(from._impl_.admins_);
  _this->_impl_.wrappers_.MergeFrom(from._impl_.wrappers_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_publickey(from._internal_publickey());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_encryptionkeypair()->::SessionProtos::KeyPair::MergeFrom(
          from._internal_encryptionkeypair());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.expirationtimer_ = from._impl_.expirationtimer_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DataMessage_ClosedGroupControlMessage::CopyFrom(const DataMessage_ClosedGroupControlMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SessionProtos.DataMessage.ClosedGroupControlMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataMessage_ClosedGroupControlMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.wrappers_))
    return false;
  if (_internal_has_encryptionkeypair()) {
    if (!_impl_.encryptionkeypair_->IsInitialized()) return false;
  }
  return true;
}

void DataMessage_ClosedGroupControlMessage::InternalSwap(DataMessage_ClosedGroupControlMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.members_.InternalSwap(&other->_impl_.members_);
  _impl_.admins_.InternalSwap(&other->_impl_.admins_);
  _impl_.wrappers_.InternalSwap(&other->_impl_.wrappers_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.publickey_, lhs_arena,
      &other->_impl_.publickey_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DataMessage_ClosedGroupControlMessage, _impl_.expirationtimer_)
      + sizeof(DataMessage_ClosedGroupControlMessage::_impl_.expirationtimer_)
      - PROTOBUF_FIELD_OFFSET(DataMessage_ClosedGroupControlMessage, _impl_.encryptionkeypair_)>(
          reinterpret_cast<char*>(&_impl_.encryptionkeypair_),
          reinterpret_cast<char*>(&other->_impl_.encryptionkeypair_));
  swap(_impl_.type_, other->_impl_.type_);
}

std::string DataMessage_ClosedGroupControlMessage::GetTypeName() const {
  return "SessionProtos.DataMessage.ClosedGroupControlMessage";
}


// ===================================================================

class DataMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<DataMessage>()._impl_._has_bits_);
  static void set_has_body(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_expiretimer(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_profilekey(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::SessionProtos::DataMessage_Quote& quote(const DataMessage* msg);
  static void set_has_quote(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::SessionProtos::DataMessage_Reaction& reaction(const DataMessage* msg);
  static void set_has_reaction(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::SessionProtos::LokiProfile& profile(const DataMessage* msg);
  static void set_has_profile(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::SessionProtos::DataMessage_OpenGroupInvitation& opengroupinvitation(const DataMessage* msg);
  static void set_has_opengroupinvitation(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::SessionProtos::DataMessage_ClosedGroupControlMessage& closedgroupcontrolmessage(const DataMessage* msg);
  static void set_has_closedgroupcontrolmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_synctarget(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_blockscommunitymessagerequests(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

const ::SessionProtos::DataMessage_Quote&
DataMessage::_Internal::quote(const DataMessage* msg) {
  return *msg->_impl_.quote_;
}
const ::SessionProtos::DataMessage_Reaction&
DataMessage::_Internal::reaction(const DataMessage* msg) {
  return *msg->_impl_.reaction_;
}
const ::SessionProtos::LokiProfile&
DataMessage::_Internal::profile(const DataMessage* msg) {
  return *msg->_impl_.profile_;
}
const ::SessionProtos::DataMessage_OpenGroupInvitation&
DataMessage::_Internal::opengroupinvitation(const DataMessage* msg) {
  return *msg->_impl_.opengroupinvitation_;
}
const ::SessionProtos::DataMessage_ClosedGroupControlMessage&
DataMessage::_Internal::closedgroupcontrolmessage(const DataMessage* msg) {
  return *msg->_impl_.closedgroupcontrolmessage_;
}
DataMessage::DataMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SessionProtos.DataMessage)
}
DataMessage::DataMessage(const DataMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DataMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attachments_){from._impl_.attachments_}
    , decltype(_impl_.preview_){from._impl_.preview_}
    , decltype(_impl_.body_){}
    , decltype(_impl_.profilekey_){}
    , decltype(_impl_.synctarget_){}
    , decltype(_impl_.quote_){nullptr}
    , decltype(_impl_.reaction_){nullptr}
    , decltype(_impl_.profile_){nullptr}
    , decltype(_impl_.opengroupinvitation_){nullptr}
    , decltype(_impl_.closedgroupcontrolmessage_){nullptr}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.expiretimer_){}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.blockscommunitymessagerequests_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_body()) {
    _this->_impl_.body_.Set(from._internal_body(), 
      _this->GetArenaForAllocation());
  }
  _impl_.profilekey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profilekey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_profilekey()) {
    _this->_impl_.profilekey_.Set(from._internal_profilekey(), 
      _this->GetArenaForAllocation());
  }
  _impl_.synctarget_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.synctarget_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_synctarget()) {
    _this->_impl_.synctarget_.Set(from._internal_synctarget(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_quote()) {
    _this->_impl_.quote_ = new ::SessionProtos::DataMessage_Quote(*from._impl_.quote_);
  }
  if (from._internal_has_reaction()) {
    _this->_impl_.reaction_ = new ::SessionProtos::DataMessage_Reaction(*from._impl_.reaction_);
  }
  if (from._internal_has_profile()) {
    _this->_impl_.profile_ = new ::SessionProtos::LokiProfile(*from._impl_.profile_);
  }
  if (from._internal_has_opengroupinvitation()) {
    _this->_impl_.opengroupinvitation_ = new ::SessionProtos::DataMessage_OpenGroupInvitation(*from._impl_.opengroupinvitation_);
  }
  if (from._internal_has_closedgroupcontrolmessage()) {
    _this->_impl_.closedgroupcontrolmessage_ = new ::SessionProtos::DataMessage_ClosedGroupControlMessage(*from._impl_.closedgroupcontrolmessage_);
  }
  ::memcpy(&_impl_.flags_, &from._impl_.flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.blockscommunitymessagerequests_) -
    reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.blockscommunitymessagerequests_));
  // @@protoc_insertion_point(copy_constructor:SessionProtos.DataMessage)
}

inline void DataMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attachments_){arena}
    , decltype(_impl_.preview_){arena}
    , decltype(_impl_.body_){}
    , decltype(_impl_.profilekey_){}
    , decltype(_impl_.synctarget_){}
    , decltype(_impl_.quote_){nullptr}
    , decltype(_impl_.reaction_){nullptr}
    , decltype(_impl_.profile_){nullptr}
    , decltype(_impl_.opengroupinvitation_){nullptr}
    , decltype(_impl_.closedgroupcontrolmessage_){nullptr}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.expiretimer_){0u}
    , decltype(_impl_.timestamp_){uint64_t{0u}}
    , decltype(_impl_.blockscommunitymessagerequests_){false}
  };
  _impl_.body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.profilekey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profilekey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.synctarget_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.synctarget_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DataMessage::~DataMessage() {
  // @@protoc_insertion_point(destructor:SessionProtos.DataMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DataMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attachments_.~RepeatedPtrField();
  _impl_.preview_.~RepeatedPtrField();
  _impl_.body_.Destroy();
  _impl_.profilekey_.Destroy();
  _impl_.synctarget_.Destroy();
  if (this != internal_default_instance()) delete _impl_.quote_;
  if (this != internal_default_instance()) delete _impl_.reaction_;
  if (this != internal_default_instance()) delete _impl_.profile_;
  if (this != internal_default_instance()) delete _impl_.opengroupinvitation_;
  if (this != internal_default_instance()) delete _impl_.closedgroupcontrolmessage_;
}

void DataMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DataMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:SessionProtos.DataMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.attachments_.Clear();
  _impl_.preview_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.body_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.profilekey_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.synctarget_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.quote_ != nullptr);
      _impl_.quote_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.reaction_ != nullptr);
      _impl_.reaction_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.profile_ != nullptr);
      _impl_.profile_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.opengroupinvitation_ != nullptr);
      _impl_.opengroupinvitation_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.closedgroupcontrolmessage_ != nullptr);
      _impl_.closedgroupcontrolmessage_->Clear();
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.blockscommunitymessagerequests_) -
        reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.blockscommunitymessagerequests_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DataMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string body = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_body();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .SessionProtos.AttachmentPointer attachments = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_attachments(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 expireTimer = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_expiretimer(&has_bits);
          _impl_.expiretimer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes profileKey = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_profilekey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 timestamp = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SessionProtos.DataMessage.Quote quote = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_quote(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .SessionProtos.DataMessage.Preview preview = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_preview(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .SessionProtos.DataMessage.Reaction reaction = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_reaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SessionProtos.LokiProfile profile = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_profile(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SessionProtos.DataMessage.OpenGroupInvitation openGroupInvitation = 102;
      case 102:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_opengroupinvitation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SessionProtos.DataMessage.ClosedGroupControlMessage closedGroupControlMessage = 104;
      case 104:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_closedgroupcontrolmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string syncTarget = 105;
      case 105:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_synctarget();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool blocksCommunityMessageRequests = 106;
      case 106:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_blockscommunitymessagerequests(&has_bits);
          _impl_.blockscommunitymessagerequests_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DataMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SessionProtos.DataMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string body = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_body(), target);
  }

  // repeated .SessionProtos.AttachmentPointer attachments = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_attachments_size()); i < n; i++) {
    const auto& repfield = this->_internal_attachments(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 flags = 4;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_flags(), target);
  }

  // optional uint32 expireTimer = 5;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_expiretimer(), target);
  }

  // optional bytes profileKey = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_profilekey(), target);
  }

  // optional uint64 timestamp = 7;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_timestamp(), target);
  }

  // optional .SessionProtos.DataMessage.Quote quote = 8;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::quote(this),
        _Internal::quote(this).GetCachedSize(), target, stream);
  }

  // repeated .SessionProtos.DataMessage.Preview preview = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_preview_size()); i < n; i++) {
    const auto& repfield = this->_internal_preview(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .SessionProtos.DataMessage.Reaction reaction = 11;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::reaction(this),
        _Internal::reaction(this).GetCachedSize(), target, stream);
  }

  // optional .SessionProtos.LokiProfile profile = 101;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(101, _Internal::profile(this),
        _Internal::profile(this).GetCachedSize(), target, stream);
  }

  // optional .SessionProtos.DataMessage.OpenGroupInvitation openGroupInvitation = 102;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(102, _Internal::opengroupinvitation(this),
        _Internal::opengroupinvitation(this).GetCachedSize(), target, stream);
  }

  // optional .SessionProtos.DataMessage.ClosedGroupControlMessage closedGroupControlMessage = 104;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(104, _Internal::closedgroupcontrolmessage(this),
        _Internal::closedgroupcontrolmessage(this).GetCachedSize(), target, stream);
  }

  // optional string syncTarget = 105;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        105, this->_internal_synctarget(), target);
  }

  // optional bool blocksCommunityMessageRequests = 106;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(106, this->_internal_blockscommunitymessagerequests(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SessionProtos.DataMessage)
  return target;
}

size_t DataMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SessionProtos.DataMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SessionProtos.AttachmentPointer attachments = 2;
  total_size += 1UL * this->_internal_attachments_size();
  for (const auto& msg : this->_impl_.attachments_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .SessionProtos.DataMessage.Preview preview = 10;
  total_size += 1UL * this->_internal_preview_size();
  for (const auto& msg : this->_impl_.preview_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string body = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_body());
    }

    // optional bytes profileKey = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_profilekey());
    }

    // optional string syncTarget = 105;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_synctarget());
    }

    // optional .SessionProtos.DataMessage.Quote quote = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.quote_);
    }

    // optional .SessionProtos.DataMessage.Reaction reaction = 11;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.reaction_);
    }

    // optional .SessionProtos.LokiProfile profile = 101;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.profile_);
    }

    // optional .SessionProtos.DataMessage.OpenGroupInvitation openGroupInvitation = 102;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.opengroupinvitation_);
    }

    // optional .SessionProtos.DataMessage.ClosedGroupControlMessage closedGroupControlMessage = 104;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.closedgroupcontrolmessage_);
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional uint32 flags = 4;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional uint32 expireTimer = 5;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_expiretimer());
    }

    // optional uint64 timestamp = 7;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_timestamp());
    }

    // optional bool blocksCommunityMessageRequests = 106;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DataMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DataMessage*>(
      &from));
}

void DataMessage::MergeFrom(const DataMessage& from) {
  DataMessage* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:SessionProtos.DataMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.attachments_.MergeFrom(from._impl_.attachments_);
  _this->_impl_.preview_.MergeFrom(from._impl_.preview_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_body(from._internal_body());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_profilekey(from._internal_profilekey());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_synctarget(from._internal_synctarget());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_quote()->::SessionProtos::DataMessage_Quote::MergeFrom(
          from._internal_quote());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_reaction()->::SessionProtos::DataMessage_Reaction::MergeFrom(
          from._internal_reaction());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_profile()->::SessionProtos::LokiProfile::MergeFrom(
          from._internal_profile());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_opengroupinvitation()->::SessionProtos::DataMessage_OpenGroupInvitation::MergeFrom(
          from._internal_opengroupinvitation());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_closedgroupcontrolmessage()->::SessionProtos::DataMessage_ClosedGroupControlMessage::MergeFrom(
          from._internal_closedgroupcontrolmessage());
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.expiretimer_ = from._impl_.expiretimer_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.blockscommunitymessagerequests_ = from._impl_.blockscommunitymessagerequests_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DataMessage::CopyFrom(const DataMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SessionProtos.DataMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataMessage::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.attachments_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.preview_))
    return false;
  if (_internal_has_quote()) {
    if (!_impl_.quote_->IsInitialized()) return false;
  }
  if (_internal_has_reaction()) {
    if (!_impl_.reaction_->IsInitialized()) return false;
  }
  if (_internal_has_opengroupinvitation()) {
    if (!_impl_.opengroupinvitation_->IsInitialized()) return false;
  }
  if (_internal_has_closedgroupcontrolmessage()) {
    if (!_impl_.closedgroupcontrolmessage_->IsInitialized()) return false;
  }
  return true;
}

void DataMessage::InternalSwap(DataMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.attachments_.InternalSwap(&other->_impl_.attachments_);
  _impl_.preview_.InternalSwap(&other->_impl_.preview_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.body_, lhs_arena,
      &other->_impl_.body_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.profilekey_, lhs_arena,
      &other->_impl_.profilekey_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.synctarget_, lhs_arena,
      &other->_impl_.synctarget_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DataMessage, _impl_.blockscommunitymessagerequests_)
      + sizeof(DataMessage::_impl_.blockscommunitymessagerequests_)
      - PROTOBUF_FIELD_OFFSET(DataMessage, _impl_.quote_)>(
          reinterpret_cast<char*>(&_impl_.quote_),
          reinterpret_cast<char*>(&other->_impl_.quote_));
}

std::string DataMessage::GetTypeName() const {
  return "SessionProtos.DataMessage";
}


// ===================================================================

class ConfigurationMessage_ClosedGroup::_Internal {
 public:
  using HasBits = decltype(std::declval<ConfigurationMessage_ClosedGroup>()._impl_._has_bits_);
  static void set_has_publickey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::SessionProtos::KeyPair& encryptionkeypair(const ConfigurationMessage_ClosedGroup* msg);
  static void set_has_encryptionkeypair(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_expirationtimer(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::SessionProtos::KeyPair&
ConfigurationMessage_ClosedGroup::_Internal::encryptionkeypair(const ConfigurationMessage_ClosedGroup* msg) {
  return *msg->_impl_.encryptionkeypair_;
}
ConfigurationMessage_ClosedGroup::ConfigurationMessage_ClosedGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SessionProtos.ConfigurationMessage.ClosedGroup)
}
ConfigurationMessage_ClosedGroup::ConfigurationMessage_ClosedGroup(const ConfigurationMessage_ClosedGroup& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ConfigurationMessage_ClosedGroup* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_){from._impl_.members_}
    , decltype(_impl_.admins_){from._impl_.admins_}
    , decltype(_impl_.publickey_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.encryptionkeypair_){nullptr}
    , decltype(_impl_.expirationtimer_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.publickey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.publickey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_publickey()) {
    _this->_impl_.publickey_.Set(from._internal_publickey(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_encryptionkeypair()) {
    _this->_impl_.encryptionkeypair_ = new ::SessionProtos::KeyPair(*from._impl_.encryptionkeypair_);
  }
  _this->_impl_.expirationtimer_ = from._impl_.expirationtimer_;
  // @@protoc_insertion_point(copy_constructor:SessionProtos.ConfigurationMessage.ClosedGroup)
}

inline void ConfigurationMessage_ClosedGroup::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_){arena}
    , decltype(_impl_.admins_){arena}
    , decltype(_impl_.publickey_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.encryptionkeypair_){nullptr}
    , decltype(_impl_.expirationtimer_){0u}
  };
  _impl_.publickey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.publickey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ConfigurationMessage_ClosedGroup::~ConfigurationMessage_ClosedGroup() {
  // @@protoc_insertion_point(destructor:SessionProtos.ConfigurationMessage.ClosedGroup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConfigurationMessage_ClosedGroup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.members_.~RepeatedPtrField();
  _impl_.admins_.~RepeatedPtrField();
  _impl_.publickey_.Destroy();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.encryptionkeypair_;
}

void ConfigurationMessage_ClosedGroup::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConfigurationMessage_ClosedGroup::Clear() {
// @@protoc_insertion_point(message_clear_start:SessionProtos.ConfigurationMessage.ClosedGroup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.members_.Clear();
  _impl_.admins_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.publickey_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.encryptionkeypair_ != nullptr);
      _impl_.encryptionkeypair_->Clear();
    }
  }
  _impl_.expirationtimer_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConfigurationMessage_ClosedGroup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes publicKey = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_publickey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SessionProtos.KeyPair encryptionKeyPair = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_encryptionkeypair(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes members = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_members();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated bytes admins = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_admins();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 expirationTimer = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_expirationtimer(&has_bits);
          _impl_.expirationtimer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConfigurationMessage_ClosedGroup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SessionProtos.ConfigurationMessage.ClosedGroup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes publicKey = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_publickey(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional .SessionProtos.KeyPair encryptionKeyPair = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::encryptionkeypair(this),
        _Internal::encryptionkeypair(this).GetCachedSize(), target, stream);
  }

  // repeated bytes members = 4;
  for (int i = 0, n = this->_internal_members_size(); i < n; i++) {
    const auto& s = this->_internal_members(i);
    target = stream->WriteBytes(4, s, target);
  }

  // repeated bytes admins = 5;
  for (int i = 0, n = this->_internal_admins_size(); i < n; i++) {
    const auto& s = this->_internal_admins(i);
    target = stream->WriteBytes(5, s, target);
  }

  // optional uint32 expirationTimer = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_expirationtimer(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SessionProtos.ConfigurationMessage.ClosedGroup)
  return target;
}

size_t ConfigurationMessage_ClosedGroup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SessionProtos.ConfigurationMessage.ClosedGroup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes members = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.members_.size());
  for (int i = 0, n = _impl_.members_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.members_.Get(i));
  }

  // repeated bytes admins = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.admins_.size());
  for (int i = 0, n = _impl_.admins_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.admins_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes publicKey = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_publickey());
    }

    // optional string name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional .SessionProtos.KeyPair encryptionKeyPair = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.encryptionkeypair_);
    }

    // optional uint32 expirationTimer = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_expirationtimer());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConfigurationMessage_ClosedGroup::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConfigurationMessage_ClosedGroup*>(
      &from));
}

void ConfigurationMessage_ClosedGroup::MergeFrom(const ConfigurationMessage_ClosedGroup& from) {
  ConfigurationMessage_ClosedGroup* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:SessionProtos.ConfigurationMessage.ClosedGroup)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.members_.MergeFrom(from._impl_.members_);
  _this->_impl_.admins_.MergeFrom(from._impl_.admins_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_publickey(from._internal_publickey());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_encryptionkeypair()->::SessionProtos::KeyPair::MergeFrom(
          from._internal_encryptionkeypair());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.expirationtimer_ = from._impl_.expirationtimer_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConfigurationMessage_ClosedGroup::CopyFrom(const ConfigurationMessage_ClosedGroup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SessionProtos.ConfigurationMessage.ClosedGroup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigurationMessage_ClosedGroup::IsInitialized() const {
  if (_internal_has_encryptionkeypair()) {
    if (!_impl_.encryptionkeypair_->IsInitialized()) return false;
  }
  return true;
}

void ConfigurationMessage_ClosedGroup::InternalSwap(ConfigurationMessage_ClosedGroup* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.members_.InternalSwap(&other->_impl_.members_);
  _impl_.admins_.InternalSwap(&other->_impl_.admins_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.publickey_, lhs_arena,
      &other->_impl_.publickey_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConfigurationMessage_ClosedGroup, _impl_.expirationtimer_)
      + sizeof(ConfigurationMessage_ClosedGroup::_impl_.expirationtimer_)
      - PROTOBUF_FIELD_OFFSET(ConfigurationMessage_ClosedGroup, _impl_.encryptionkeypair_)>(
          reinterpret_cast<char*>(&_impl_.encryptionkeypair_),
          reinterpret_cast<char*>(&other->_impl_.encryptionkeypair_));
}

std::string ConfigurationMessage_ClosedGroup::GetTypeName() const {
  return "SessionProtos.ConfigurationMessage.ClosedGroup";
}


// ===================================================================

class ConfigurationMessage_Contact::_Internal {
 public:
  using HasBits = decltype(std::declval<ConfigurationMessage_Contact>()._impl_._has_bits_);
  static void set_has_publickey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_profilepicture(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_profilekey(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_isapproved(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_isblocked(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_didapproveme(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

ConfigurationMessage_Contact::ConfigurationMessage_Contact(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SessionProtos.ConfigurationMessage.Contact)
}
ConfigurationMessage_Contact::ConfigurationMessage_Contact(const ConfigurationMessage_Contact& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ConfigurationMessage_Contact* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.publickey_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.profilepicture_){}
    , decltype(_impl_.profilekey_){}
    , decltype(_impl_.isapproved_){}
    , decltype(_impl_.isblocked_){}
    , decltype(_impl_.didapproveme_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.publickey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.publickey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_publickey()) {
    _this->_impl_.publickey_.Set(from._internal_publickey(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.profilepicture_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profilepicture_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_profilepicture()) {
    _this->_impl_.profilepicture_.Set(from._internal_profilepicture(), 
      _this->GetArenaForAllocation());
  }
  _impl_.profilekey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profilekey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_profilekey()) {
    _this->_impl_.profilekey_.Set(from._internal_profilekey(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.isapproved_, &from._impl_.isapproved_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.didapproveme_) -
    reinterpret_cast<char*>(&_impl_.isapproved_)) + sizeof(_impl_.didapproveme_));
  // @@protoc_insertion_point(copy_constructor:SessionProtos.ConfigurationMessage.Contact)
}

inline void ConfigurationMessage_Contact::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.publickey_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.profilepicture_){}
    , decltype(_impl_.profilekey_){}
    , decltype(_impl_.isapproved_){false}
    , decltype(_impl_.isblocked_){false}
    , decltype(_impl_.didapproveme_){false}
  };
  _impl_.publickey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.publickey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.profilepicture_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profilepicture_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.profilekey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profilekey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ConfigurationMessage_Contact::~ConfigurationMessage_Contact() {
  // @@protoc_insertion_point(destructor:SessionProtos.ConfigurationMessage.Contact)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConfigurationMessage_Contact::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.publickey_.Destroy();
  _impl_.name_.Destroy();
  _impl_.profilepicture_.Destroy();
  _impl_.profilekey_.Destroy();
}

void ConfigurationMessage_Contact::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConfigurationMessage_Contact::Clear() {
// @@protoc_insertion_point(message_clear_start:SessionProtos.ConfigurationMessage.Contact)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.publickey_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.profilepicture_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.profilekey_.ClearNonDefaultToEmpty();
    }
  }
  ::memset(&_impl_.isapproved_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.didapproveme_) -
      reinterpret_cast<char*>(&_impl_.isapproved_)) + sizeof(_impl_.didapproveme_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConfigurationMessage_Contact::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes publicKey = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_publickey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string profilePicture = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_profilepicture();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes profileKey = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_profilekey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool isApproved = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_isapproved(&has_bits);
          _impl_.isapproved_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool isBlocked = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_isblocked(&has_bits);
          _impl_.isblocked_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool didApproveMe = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_didapproveme(&has_bits);
          _impl_.didapproveme_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConfigurationMessage_Contact::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SessionProtos.ConfigurationMessage.Contact)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes publicKey = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_publickey(), target);
  }

  // required string name = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional string profilePicture = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_profilepicture(), target);
  }

  // optional bytes profileKey = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_profilekey(), target);
  }

  // optional bool isApproved = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_isapproved(), target);
  }

  // optional bool isBlocked = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_isblocked(), target);
  }

  // optional bool didApproveMe = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_didapproveme(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SessionProtos.ConfigurationMessage.Contact)
  return target;
}

size_t ConfigurationMessage_Contact::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:SessionProtos.ConfigurationMessage.Contact)
  size_t total_size = 0;

  if (_internal_has_publickey()) {
    // required bytes publicKey = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_publickey());
  }

  if (_internal_has_name()) {
    // required string name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return total_size;
}
size_t ConfigurationMessage_Contact::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SessionProtos.ConfigurationMessage.Contact)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes publicKey = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_publickey());

    // required string name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007cu) {
    // optional string profilePicture = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_profilepicture());
    }

    // optional bytes profileKey = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_profilekey());
    }

    // optional bool isApproved = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool isBlocked = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool didApproveMe = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConfigurationMessage_Contact::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConfigurationMessage_Contact*>(
      &from));
}

void ConfigurationMessage_Contact::MergeFrom(const ConfigurationMessage_Contact& from) {
  ConfigurationMessage_Contact* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:SessionProtos.ConfigurationMessage.Contact)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_publickey(from._internal_publickey());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_profilepicture(from._internal_profilepicture());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_profilekey(from._internal_profilekey());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.isapproved_ = from._impl_.isapproved_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.isblocked_ = from._impl_.isblocked_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.didapproveme_ = from._impl_.didapproveme_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConfigurationMessage_Contact::CopyFrom(const ConfigurationMessage_Contact& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SessionProtos.ConfigurationMessage.Contact)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigurationMessage_Contact::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ConfigurationMessage_Contact::InternalSwap(ConfigurationMessage_Contact* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.publickey_, lhs_arena,
      &other->_impl_.publickey_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.profilepicture_, lhs_arena,
      &other->_impl_.profilepicture_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.profilekey_, lhs_arena,
      &other->_impl_.profilekey_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConfigurationMessage_Contact, _impl_.didapproveme_)
      + sizeof(ConfigurationMessage_Contact::_impl_.didapproveme_)
      - PROTOBUF_FIELD_OFFSET(ConfigurationMessage_Contact, _impl_.isapproved_)>(
          reinterpret_cast<char*>(&_impl_.isapproved_),
          reinterpret_cast<char*>(&other->_impl_.isapproved_));
}

std::string ConfigurationMessage_Contact::GetTypeName() const {
  return "SessionProtos.ConfigurationMessage.Contact";
}


// ===================================================================

class ConfigurationMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<ConfigurationMessage>()._impl_._has_bits_);
  static void set_has_displayname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_profilepicture(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_profilekey(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ConfigurationMessage::ConfigurationMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SessionProtos.ConfigurationMessage)
}
ConfigurationMessage::ConfigurationMessage(const ConfigurationMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ConfigurationMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.closedgroups_){from._impl_.closedgroups_}
    , decltype(_impl_.opengroups_){from._impl_.opengroups_}
    , decltype(_impl_.contacts_){from._impl_.contacts_}
    , decltype(_impl_.displayname_){}
    , decltype(_impl_.profilepicture_){}
    , decltype(_impl_.profilekey_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.displayname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.displayname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_displayname()) {
    _this->_impl_.displayname_.Set(from._internal_displayname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.profilepicture_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profilepicture_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_profilepicture()) {
    _this->_impl_.profilepicture_.Set(from._internal_profilepicture(), 
      _this->GetArenaForAllocation());
  }
  _impl_.profilekey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profilekey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_profilekey()) {
    _this->_impl_.profilekey_.Set(from._internal_profilekey(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:SessionProtos.ConfigurationMessage)
}

inline void ConfigurationMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.closedgroups_){arena}
    , decltype(_impl_.opengroups_){arena}
    , decltype(_impl_.contacts_){arena}
    , decltype(_impl_.displayname_){}
    , decltype(_impl_.profilepicture_){}
    , decltype(_impl_.profilekey_){}
  };
  _impl_.displayname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.displayname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.profilepicture_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profilepicture_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.profilekey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profilekey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ConfigurationMessage::~ConfigurationMessage() {
  // @@protoc_insertion_point(destructor:SessionProtos.ConfigurationMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConfigurationMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.closedgroups_.~RepeatedPtrField();
  _impl_.opengroups_.~RepeatedPtrField();
  _impl_.contacts_.~RepeatedPtrField();
  _impl_.displayname_.Destroy();
  _impl_.profilepicture_.Destroy();
  _impl_.profilekey_.Destroy();
}

void ConfigurationMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConfigurationMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:SessionProtos.ConfigurationMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.closedgroups_.Clear();
  _impl_.opengroups_.Clear();
  _impl_.contacts_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.displayname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.profilepicture_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.profilekey_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConfigurationMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .SessionProtos.ConfigurationMessage.ClosedGroup closedGroups = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_closedgroups(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string openGroups = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_opengroups();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string displayName = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_displayname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string profilePicture = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_profilepicture();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes profileKey = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_profilekey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .SessionProtos.ConfigurationMessage.Contact contacts = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_contacts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConfigurationMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SessionProtos.ConfigurationMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .SessionProtos.ConfigurationMessage.ClosedGroup closedGroups = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_closedgroups_size()); i < n; i++) {
    const auto& repfield = this->_internal_closedgroups(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string openGroups = 2;
  for (int i = 0, n = this->_internal_opengroups_size(); i < n; i++) {
    const auto& s = this->_internal_opengroups(i);
    target = stream->WriteString(2, s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string displayName = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_displayname(), target);
  }

  // optional string profilePicture = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_profilepicture(), target);
  }

  // optional bytes profileKey = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_profilekey(), target);
  }

  // repeated .SessionProtos.ConfigurationMessage.Contact contacts = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_contacts_size()); i < n; i++) {
    const auto& repfield = this->_internal_contacts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SessionProtos.ConfigurationMessage)
  return target;
}

size_t ConfigurationMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SessionProtos.ConfigurationMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SessionProtos.ConfigurationMessage.ClosedGroup closedGroups = 1;
  total_size += 1UL * this->_internal_closedgroups_size();
  for (const auto& msg : this->_impl_.closedgroups_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string openGroups = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.opengroups_.size());
  for (int i = 0, n = _impl_.opengroups_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.opengroups_.Get(i));
  }

  // repeated .SessionProtos.ConfigurationMessage.Contact contacts = 6;
  total_size += 1UL * this->_internal_contacts_size();
  for (const auto& msg : this->_impl_.contacts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string displayName = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_displayname());
    }

    // optional string profilePicture = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_profilepicture());
    }

    // optional bytes profileKey = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_profilekey());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConfigurationMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConfigurationMessage*>(
      &from));
}

void ConfigurationMessage::MergeFrom(const ConfigurationMessage& from) {
  ConfigurationMessage* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:SessionProtos.ConfigurationMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.closedgroups_.MergeFrom(from._impl_.closedgroups_);
  _this->_impl_.opengroups_.MergeFrom(from._impl_.opengroups_);
  _this->_impl_.contacts_.MergeFrom(from._impl_.contacts_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_displayname(from._internal_displayname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_profilepicture(from._internal_profilepicture());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_profilekey(from._internal_profilekey());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConfigurationMessage::CopyFrom(const ConfigurationMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SessionProtos.ConfigurationMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigurationMessage::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.closedgroups_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.contacts_))
    return false;
  return true;
}

void ConfigurationMessage::InternalSwap(ConfigurationMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.closedgroups_.InternalSwap(&other->_impl_.closedgroups_);
  _impl_.opengroups_.InternalSwap(&other->_impl_.opengroups_);
  _impl_.contacts_.InternalSwap(&other->_impl_.contacts_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.displayname_, lhs_arena,
      &other->_impl_.displayname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.profilepicture_, lhs_arena,
      &other->_impl_.profilepicture_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.profilekey_, lhs_arena,
      &other->_impl_.profilekey_, rhs_arena
  );
}

std::string ConfigurationMessage::GetTypeName() const {
  return "SessionProtos.ConfigurationMessage";
}


// ===================================================================

class ReceiptMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<ReceiptMessage>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

ReceiptMessage::ReceiptMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SessionProtos.ReceiptMessage)
}
ReceiptMessage::ReceiptMessage(const ReceiptMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ReceiptMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){from._impl_.timestamp_}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:SessionProtos.ReceiptMessage)
}

inline void ReceiptMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){arena}
    , decltype(_impl_.type_){0}
  };
}

ReceiptMessage::~ReceiptMessage() {
  // @@protoc_insertion_point(destructor:SessionProtos.ReceiptMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReceiptMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.timestamp_.~RepeatedField();
}

void ReceiptMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReceiptMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:SessionProtos.ReceiptMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.timestamp_.Clear();
  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ReceiptMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .SessionProtos.ReceiptMessage.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SessionProtos::ReceiptMessage_Type_IsValid(val))) {
            _internal_set_type(static_cast<::SessionProtos::ReceiptMessage_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_timestamp(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_timestamp(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReceiptMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SessionProtos.ReceiptMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .SessionProtos.ReceiptMessage.Type type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // repeated uint64 timestamp = 2;
  for (int i = 0, n = this->_internal_timestamp_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_timestamp(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SessionProtos.ReceiptMessage)
  return target;
}

size_t ReceiptMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SessionProtos.ReceiptMessage)
  size_t total_size = 0;

  // required .SessionProtos.ReceiptMessage.Type type = 1;
  if (_internal_has_type()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 timestamp = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.timestamp_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_timestamp_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReceiptMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ReceiptMessage*>(
      &from));
}

void ReceiptMessage::MergeFrom(const ReceiptMessage& from) {
  ReceiptMessage* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:SessionProtos.ReceiptMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.timestamp_.MergeFrom(from._impl_.timestamp_);
  if (from._internal_has_type()) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReceiptMessage::CopyFrom(const ReceiptMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SessionProtos.ReceiptMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReceiptMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ReceiptMessage::InternalSwap(ReceiptMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.timestamp_.InternalSwap(&other->_impl_.timestamp_);
  swap(_impl_.type_, other->_impl_.type_);
}

std::string ReceiptMessage::GetTypeName() const {
  return "SessionProtos.ReceiptMessage";
}


// ===================================================================

class AttachmentPointer::_Internal {
 public:
  using HasBits = decltype(std::declval<AttachmentPointer>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_contenttype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_thumbnail(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_digest(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_caption(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000080) ^ 0x00000080) != 0;
  }
};

AttachmentPointer::AttachmentPointer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SessionProtos.AttachmentPointer)
}
AttachmentPointer::AttachmentPointer(const AttachmentPointer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AttachmentPointer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.contenttype_){}
    , decltype(_impl_.key_){}
    , decltype(_impl_.thumbnail_){}
    , decltype(_impl_.digest_){}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.caption_){}
    , decltype(_impl_.url_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.width_){}
    , decltype(_impl_.height_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.contenttype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contenttype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contenttype()) {
    _this->_impl_.contenttype_.Set(from._internal_contenttype(), 
      _this->GetArenaForAllocation());
  }
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.thumbnail_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.thumbnail_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_thumbnail()) {
    _this->_impl_.thumbnail_.Set(from._internal_thumbnail(), 
      _this->GetArenaForAllocation());
  }
  _impl_.digest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.digest_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_digest()) {
    _this->_impl_.digest_.Set(from._internal_digest(), 
      _this->GetArenaForAllocation());
  }
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_filename()) {
    _this->_impl_.filename_.Set(from._internal_filename(), 
      _this->GetArenaForAllocation());
  }
  _impl_.caption_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.caption_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_caption()) {
    _this->_impl_.caption_.Set(from._internal_caption(), 
      _this->GetArenaForAllocation());
  }
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.height_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.height_));
  // @@protoc_insertion_point(copy_constructor:SessionProtos.AttachmentPointer)
}

inline void AttachmentPointer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.contenttype_){}
    , decltype(_impl_.key_){}
    , decltype(_impl_.thumbnail_){}
    , decltype(_impl_.digest_){}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.caption_){}
    , decltype(_impl_.url_){}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_.size_){0u}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.width_){0u}
    , decltype(_impl_.height_){0u}
  };
  _impl_.contenttype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contenttype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.thumbnail_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.thumbnail_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.digest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.digest_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.caption_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.caption_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AttachmentPointer::~AttachmentPointer() {
  // @@protoc_insertion_point(destructor:SessionProtos.AttachmentPointer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AttachmentPointer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contenttype_.Destroy();
  _impl_.key_.Destroy();
  _impl_.thumbnail_.Destroy();
  _impl_.digest_.Destroy();
  _impl_.filename_.Destroy();
  _impl_.caption_.Destroy();
  _impl_.url_.Destroy();
}

void AttachmentPointer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AttachmentPointer::Clear() {
// @@protoc_insertion_point(message_clear_start:SessionProtos.AttachmentPointer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.contenttype_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.thumbnail_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.digest_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.filename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.caption_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.url_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.id_ = uint64_t{0u};
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.height_) -
        reinterpret_cast<char*>(&_impl_.size_)) + sizeof(_impl_.height_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AttachmentPointer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required fixed64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional string contentType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_contenttype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes thumbnail = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_thumbnail();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes digest = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_digest();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string fileName = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 width = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_width(&has_bits);
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 height = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_height(&has_bits);
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string caption = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_caption();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string url = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AttachmentPointer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SessionProtos.AttachmentPointer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required fixed64 id = 1;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_id(), target);
  }

  // optional string contentType = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_contenttype(), target);
  }

  // optional bytes key = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_key(), target);
  }

  // optional uint32 size = 4;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_size(), target);
  }

  // optional bytes thumbnail = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_thumbnail(), target);
  }

  // optional bytes digest = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_digest(), target);
  }

  // optional string fileName = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_filename(), target);
  }

  // optional uint32 flags = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_flags(), target);
  }

  // optional uint32 width = 9;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_width(), target);
  }

  // optional uint32 height = 10;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_height(), target);
  }

  // optional string caption = 11;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_caption(), target);
  }

  // optional string url = 101;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteStringMaybeAliased(
        101, this->_internal_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SessionProtos.AttachmentPointer)
  return target;
}

size_t AttachmentPointer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SessionProtos.AttachmentPointer)
  size_t total_size = 0;

  // required fixed64 id = 1;
  if (_internal_has_id()) {
    total_size += 1 + 8;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string contentType = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contenttype());
    }

    // optional bytes key = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_key());
    }

    // optional bytes thumbnail = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_thumbnail());
    }

    // optional bytes digest = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_digest());
    }

    // optional string fileName = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_filename());
    }

    // optional string caption = 11;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_caption());
    }

    // optional string url = 101;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional uint32 size = 4;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_size());
    }

    // optional uint32 flags = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional uint32 width = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_width());
    }

    // optional uint32 height = 10;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_height());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AttachmentPointer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AttachmentPointer*>(
      &from));
}

void AttachmentPointer::MergeFrom(const AttachmentPointer& from) {
  AttachmentPointer* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:SessionProtos.AttachmentPointer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_contenttype(from._internal_contenttype());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_thumbnail(from._internal_thumbnail());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_digest(from._internal_digest());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_filename(from._internal_filename());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_caption(from._internal_caption());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AttachmentPointer::CopyFrom(const AttachmentPointer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SessionProtos.AttachmentPointer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AttachmentPointer::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void AttachmentPointer::InternalSwap(AttachmentPointer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contenttype_, lhs_arena,
      &other->_impl_.contenttype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.thumbnail_, lhs_arena,
      &other->_impl_.thumbnail_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.digest_, lhs_arena,
      &other->_impl_.digest_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.filename_, lhs_arena,
      &other->_impl_.filename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.caption_, lhs_arena,
      &other->_impl_.caption_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AttachmentPointer, _impl_.height_)
      + sizeof(AttachmentPointer::_impl_.height_)
      - PROTOBUF_FIELD_OFFSET(AttachmentPointer, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

std::string AttachmentPointer::GetTypeName() const {
  return "SessionProtos.AttachmentPointer";
}


// ===================================================================

class SharedConfigMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<SharedConfigMessage>()._impl_._has_bits_);
  static void set_has_kind(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_seqno(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

SharedConfigMessage::SharedConfigMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SessionProtos.SharedConfigMessage)
}
SharedConfigMessage::SharedConfigMessage(const SharedConfigMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SharedConfigMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.seqno_){}
    , decltype(_impl_.kind_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.seqno_, &from._impl_.seqno_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.kind_) -
    reinterpret_cast<char*>(&_impl_.seqno_)) + sizeof(_impl_.kind_));
  // @@protoc_insertion_point(copy_constructor:SessionProtos.SharedConfigMessage)
}

inline void SharedConfigMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.seqno_){int64_t{0}}
    , decltype(_impl_.kind_){1}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SharedConfigMessage::~SharedConfigMessage() {
  // @@protoc_insertion_point(destructor:SessionProtos.SharedConfigMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SharedConfigMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void SharedConfigMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SharedConfigMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:SessionProtos.SharedConfigMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    _impl_.seqno_ = int64_t{0};
    _impl_.kind_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SharedConfigMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .SessionProtos.SharedConfigMessage.Kind kind = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SessionProtos::SharedConfigMessage_Kind_IsValid(val))) {
            _internal_set_kind(static_cast<::SessionProtos::SharedConfigMessage_Kind>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required int64 seqno = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_seqno(&has_bits);
          _impl_.seqno_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SharedConfigMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SessionProtos.SharedConfigMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .SessionProtos.SharedConfigMessage.Kind kind = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_kind(), target);
  }

  // required int64 seqno = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_seqno(), target);
  }

  // required bytes data = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SessionProtos.SharedConfigMessage)
  return target;
}

size_t SharedConfigMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:SessionProtos.SharedConfigMessage)
  size_t total_size = 0;

  if (_internal_has_data()) {
    // required bytes data = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  if (_internal_has_seqno()) {
    // required int64 seqno = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqno());
  }

  if (_internal_has_kind()) {
    // required .SessionProtos.SharedConfigMessage.Kind kind = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_kind());
  }

  return total_size;
}
size_t SharedConfigMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SessionProtos.SharedConfigMessage)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required bytes data = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());

    // required int64 seqno = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqno());

    // required .SessionProtos.SharedConfigMessage.Kind kind = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_kind());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SharedConfigMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SharedConfigMessage*>(
      &from));
}

void SharedConfigMessage::MergeFrom(const SharedConfigMessage& from) {
  SharedConfigMessage* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:SessionProtos.SharedConfigMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.seqno_ = from._impl_.seqno_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.kind_ = from._impl_.kind_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SharedConfigMessage::CopyFrom(const SharedConfigMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SessionProtos.SharedConfigMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SharedConfigMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SharedConfigMessage::InternalSwap(SharedConfigMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  swap(_impl_.seqno_, other->_impl_.seqno_);
  swap(_impl_.kind_, other->_impl_.kind_);
}

std::string SharedConfigMessage::GetTypeName() const {
  return "SessionProtos.SharedConfigMessage";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace SessionProtos
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::SessionProtos::Envelope*
Arena::CreateMaybeMessage< ::SessionProtos::Envelope >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SessionProtos::Envelope >(arena);
}
template<> PROTOBUF_NOINLINE ::SessionProtos::TypingMessage*
Arena::CreateMaybeMessage< ::SessionProtos::TypingMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SessionProtos::TypingMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::SessionProtos::UnsendRequest*
Arena::CreateMaybeMessage< ::SessionProtos::UnsendRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SessionProtos::UnsendRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::SessionProtos::MessageRequestResponse*
Arena::CreateMaybeMessage< ::SessionProtos::MessageRequestResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SessionProtos::MessageRequestResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::SessionProtos::Content*
Arena::CreateMaybeMessage< ::SessionProtos::Content >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SessionProtos::Content >(arena);
}
template<> PROTOBUF_NOINLINE ::SessionProtos::CallMessage*
Arena::CreateMaybeMessage< ::SessionProtos::CallMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SessionProtos::CallMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::SessionProtos::KeyPair*
Arena::CreateMaybeMessage< ::SessionProtos::KeyPair >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SessionProtos::KeyPair >(arena);
}
template<> PROTOBUF_NOINLINE ::SessionProtos::DataExtractionNotification*
Arena::CreateMaybeMessage< ::SessionProtos::DataExtractionNotification >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SessionProtos::DataExtractionNotification >(arena);
}
template<> PROTOBUF_NOINLINE ::SessionProtos::LokiProfile*
Arena::CreateMaybeMessage< ::SessionProtos::LokiProfile >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SessionProtos::LokiProfile >(arena);
}
template<> PROTOBUF_NOINLINE ::SessionProtos::DataMessage_Quote_QuotedAttachment*
Arena::CreateMaybeMessage< ::SessionProtos::DataMessage_Quote_QuotedAttachment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SessionProtos::DataMessage_Quote_QuotedAttachment >(arena);
}
template<> PROTOBUF_NOINLINE ::SessionProtos::DataMessage_Quote*
Arena::CreateMaybeMessage< ::SessionProtos::DataMessage_Quote >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SessionProtos::DataMessage_Quote >(arena);
}
template<> PROTOBUF_NOINLINE ::SessionProtos::DataMessage_Preview*
Arena::CreateMaybeMessage< ::SessionProtos::DataMessage_Preview >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SessionProtos::DataMessage_Preview >(arena);
}
template<> PROTOBUF_NOINLINE ::SessionProtos::DataMessage_Reaction*
Arena::CreateMaybeMessage< ::SessionProtos::DataMessage_Reaction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SessionProtos::DataMessage_Reaction >(arena);
}
template<> PROTOBUF_NOINLINE ::SessionProtos::DataMessage_OpenGroupInvitation*
Arena::CreateMaybeMessage< ::SessionProtos::DataMessage_OpenGroupInvitation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SessionProtos::DataMessage_OpenGroupInvitation >(arena);
}
template<> PROTOBUF_NOINLINE ::SessionProtos::DataMessage_ClosedGroupControlMessage_KeyPairWrapper*
Arena::CreateMaybeMessage< ::SessionProtos::DataMessage_ClosedGroupControlMessage_KeyPairWrapper >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SessionProtos::DataMessage_ClosedGroupControlMessage_KeyPairWrapper >(arena);
}
template<> PROTOBUF_NOINLINE ::SessionProtos::DataMessage_ClosedGroupControlMessage*
Arena::CreateMaybeMessage< ::SessionProtos::DataMessage_ClosedGroupControlMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SessionProtos::DataMessage_ClosedGroupControlMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::SessionProtos::DataMessage*
Arena::CreateMaybeMessage< ::SessionProtos::DataMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SessionProtos::DataMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::SessionProtos::ConfigurationMessage_ClosedGroup*
Arena::CreateMaybeMessage< ::SessionProtos::ConfigurationMessage_ClosedGroup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SessionProtos::ConfigurationMessage_ClosedGroup >(arena);
}
template<> PROTOBUF_NOINLINE ::SessionProtos::ConfigurationMessage_Contact*
Arena::CreateMaybeMessage< ::SessionProtos::ConfigurationMessage_Contact >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SessionProtos::ConfigurationMessage_Contact >(arena);
}
template<> PROTOBUF_NOINLINE ::SessionProtos::ConfigurationMessage*
Arena::CreateMaybeMessage< ::SessionProtos::ConfigurationMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SessionProtos::ConfigurationMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::SessionProtos::ReceiptMessage*
Arena::CreateMaybeMessage< ::SessionProtos::ReceiptMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SessionProtos::ReceiptMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::SessionProtos::AttachmentPointer*
Arena::CreateMaybeMessage< ::SessionProtos::AttachmentPointer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SessionProtos::AttachmentPointer >(arena);
}
template<> PROTOBUF_NOINLINE ::SessionProtos::SharedConfigMessage*
Arena::CreateMaybeMessage< ::SessionProtos::SharedConfigMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SessionProtos::SharedConfigMessage >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
